<HTML>
<HEAD>
  <!-- Created with AOLpress/2.0 -->
  <!-- AP: Created on: 7-Mar-2001 -->
  <!-- AP: Last modified: 15-Mar-2005 -->
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=shift-jis">
<!--<TITLE>Frequently Asked Questions</TITLE>-->
    <TITLE>よくある質問</TITLE>
  <LINK REL="icon" href="ffanvil16.png">
</HEAD>
<BODY>
<TABLE ALIGN="Right">
  <TR>
<!--<TD><A HREF="faqFS.html" TARGET="_top">Frames</A></TD>-->
    <TD><A HREF="faqFS.html" TARGET="_top">フレームつき</A></TD>
  </TR>
</TABLE>
<H1 ALIGN=Center>
<!--Frequently Asked Questions<BR>
  <SMALL>(or many of the questions I've been asked so far)</SMALL>-->
  よくある質問 <SMALL>(と、これまで訊かれた質問の多く)</SMALL>
</H1>
<H2>
<!--General questions about FontForge -->
    FontForge に関する一般的な質問
</H2>
<UL>
  <LI>
<!--<A HREF="#font-editor">Why a font editor, aren't there enough fonts
    already?</A>-->
    <A HREF="#font-editor">なぜフォントエディタを? もう十分にフォントはあるのでは?</A>
    <UL>
      <LI>
<!--	<A HREF="#write">Why did I write it?</A>-->
	<A HREF="#write">私はなぜそれを書いたのか?</A>
      <LI>
<!--	<A HREF="#give">Why do I give it away?</A>-->
	<A HREF="#give">なぜ私はそれを人にあげてしまうことにしたか?</A>
      <LI>
<!--	<A HREF="#widget-set">Why is FontForge based on a non-standard widget set?</A>-->
	<A HREF="#widget-set">なぜ FontForge は非標準のウィジェットセットをベースにしているのか?</A>
      <LI>
<!--	<A HREF="#C-plus-plus">Why isn't FontForge written in C++? (or <I>Why C++
	is not my favorite language</I>)</A> -->
	<A HREF="#C-plus-plus">なぜ FontForge は C++ で書かれていないのか (または <I>なぜ C++ が私のお気に入りの言語でないのか</I>)?</A>
    </UL>
</UL>
<H2>
<!--General questions about fonts -->
    フォントに関する一般的な質問
</H2>
<UL>
  <LI>
<!--<A HREF="#legal">Is it legal to modify a font? Is it ethical?</A> -->
    <A HREF="#legal">フォントを改変することは合法か? 倫理上の問題はないのか?</A>
  <LI>
<!--<A HREF="#pointsize">What is a 12point font?</A> (What measurement of the
    font determines the point size) -->
    <A HREF="#pointsize">12 ポイントのフォントとは何か?</A> (ポイントサイズは、フォントのどこを計って決めるのか?)
    <UL>
      <LI>
<!--	<A HREF="#linespace">How do I set the line spacing on a font?</A> -->
	<A HREF="#linespace">フォントの行間を設定するにはどうすればよいか?</A>
    </UL>
</UL>
<H2>
<!--Using FontForge &amp; Installing fonts on various systems-->
    FontForge の使い方・各種システムへのフォントのインストール方法
</H2>
<UL>
  <LI>
<!--<A HREF="#font-install">How do I install the fonts once I've made them?</A>-->
    <A HREF="#font-install">自分が作ったフォントをどうやってインストールすればいいのか?</A>
  <LI>
<!--<A HREF="faq.html#Bad-Windows-Install">Why won't FontForge's fonts install
    on some MS Windows systems</A>-->
    <A HREF="faq.html#Bad-Windows-Install">どうして FontForge で作ったフォントが MS Windows のシステムにインストールできないことがあるのか</A>
  <LI>
<!--<A HREF="#How-mac">How do I edit fonts from my macintoy?</A>-->
    <A HREF="#How-mac">マク用のフォントを編集するにはどうすればいいの?</A>
    <UL>
      <LI>
<!--	<A HREF="#How-family">How do I create a mac font family? (How do I get the
	mac to group my fonts so that the italic and bold styles work)?</A>-->
	<A HREF="#How-family">どうすれば Mac のフォントファミリーを作れるのか? (フォントをグループ化して、イタリックやボールドのスタイル指定が動作するようにするにはどうしたらいいか?</A>
      <LI>
<!--	<A HREF="#Mac-ATM">Why doesn't ATM work with my fonts?</A> -->
	<A HREF="#Mac-ATM">なぜ自作のフォントが ATM でうまく使えないのか?</A>
    </UL>
  <LI>
<!--<A HREF="#windows">How do I edit fonts on MS windows?</A> -->
    <A HREF="#windows">MS Windows でフォントを編集するにはどうすればよいか?</A>
    <UL>
      <LI>
<!--	<A HREF="faq.html#Bad-Windows-Fonts">Why don't my fonts work on windows?</A> -->
	<A HREF="#Bad-Windows-Fonts">なぜ自作のフォントが Windowsで使えないのか?</A>
    </UL>
  <LI>
<!--<A HREF="#otf-diffs">I generated an opentype (or truetype) font and windows
    wouldn't install it. Why not?</A> -->
    <A HREF="#otf-diffs">OpenType フォントを生成したが、Windows にはインストールできない。なぜできないのか?</A>
</UL>
<H2>
<!--Font Conversions-->
    フォントの変換
</H2>
<UL>
  <LI>
<!--<A HREF="faq.html#outline-conversion">Converting from one outline format
    to another</A> -->
    <A HREF="faq.html#outline-conversion">あるアウトラインフォーマットから別の方式への変換方法</A>
  <LI>
<!--<A HREF="faq.html#bitmap-conversion">Converting from one bitmap format to
    another</A> -->
    <A HREF="faq.html#bitmap-conversion">あるビットマップフォーマットから別の方式への変換方法</A>
  <LI>
<!--<A HREF="#outline-bitmap">Converting from an outline format to a bitmap</A> -->
    <A HREF="#outline-bitmap">アウトラインからビットマップへの変換方法</A>
  <LI>
<!--<A HREF="faq.html#bitmap-outline">Converting from a bitmap format to an
    outline</A> -->
    <A HREF="faq.html#bitmap-outline">ビットマップからアウトラインへの変換方法</A>
</UL>
<H2>
<!--Questions about Hints and TrueType Instructions -->
    ヒントと TrueType 命令に関する質問
</H2>
<UL>
  <LI>
<!--<A HREF="#hint-subs">How do I make it use hint substitution?</A> -->
    <A HREF="#hint-subs">FontForge がヒント置換を行うようにするにはどうすればいいか?</A>
  <LI>
<!--<A HREF="#flex-hints">How do I make it use flex hints?</A> -->
    <A HREF="#flex-hints">FontForge が flex ヒントを使うようにするにはどうすればいいか?</A>
    <UL>
      <LI>
<!--	<A HREF="#flex2">How can I tell if it is going to use flex hints?</A> -->
	<A HREF="#flex2">flex ヒントが使われるかどうかはどうすれば分かるのか?</A></B>
    </UL>
  <LI>
<!--<A HREF="#fuzzy">My glyphs are all perfectly hinted, why do some stems have
    different widths (or appear fuzzy, or fade away completely)?</A> -->
    <A HREF="#fuzzy">どのグリフも完璧にヒントづけしたのに、幅が揃わない (またはぼやけて見えたり完全に掠れて見えなかったりする) ステムがあるのはなぜか?</A>
  <LI>
<!--<A HREF="#ttf-degrade">I loaded a ttf font, made a few changes and generated
    a new font. The changed glyphs don't look anywhere near as nice as the originals.
    Why?</A> -->
    <A HREF="#ttf-degrade">TTF フォントを読み込んで、2,3 箇所修正してから新しいフォントを出力した。変更したグリフはどこから見てもオリジナルと比べて見劣りする。なぜか?</A>
</UL>
<H2>
<!--Questions about <A HREF="bibliography.html" TARGET="_top">Font Formats</A>-->
    <A HREF="bibliography.html" TARGET="_top">フォントフォーマット</A>に関する質問
</H2>
<UL>
  <LI>
<!--<A HREF="faq.html#Open-difference">What's the difference between OpenType
    and PostScript (or TrueType) fonts?</A> -->
    <A HREF="#Open-difference">OpenType と PostScript (や TrueType) フォントはどこが違うのか?</A>
  <LI>
<!--<A HREF="#cidmaps">What on earth are the cidmap files, and should I care
    about them?</A> -->
    <A HREF="#cidmaps">cidmap ファイルって一体全体何のこと、知らないと何かまずいことがある?</A>
    <UL>
      <LI>
<!--	<A TARGET="_top" HREF="cidmenu.html#CID">(What is a CID-keyed font?)</A> -->
	<A TARGET="_top" HREF="cidmenu.html#CID">(CID キー指定フォントとは何か?)</A>
    </UL>
  <LI>
<!--<A HREF="faq.html#TeX">Why doesn't TeX work with my fonts?</A>-->
    <A HREF="#TeX">自作のフォントが TeX で使えないのはなぜか?</A>
    <UL>
      <LI>
<!--	<A HREF="#mf-files">Why doesn't FontForge let me edit an '.mf' file?</A> -->
	<A HREF="#mf-files">FontForge で '.mf' ファイルを編集できないのはなぜか?</A>
    </UL>
  <LI>
<!--<A HREF="#Open-size">Why isn't my Open Type font much smaller than the .pfb
    file?</A> -->
    <A HREF="#Open-size">自作の OpenType フォントが .pfb ファイルよりもずっと小さくならないのはなぜか?</A>
  <LI>
<!--<A HREF="#Missing-Refs">When I load an otf or a type1 font most of my references
    have been replaced by inline copies. How do I get my references back?</A> -->
    <A HREF="#Missing-Refs">OTF または Type1 フォントを読み込んだ時、ほとんどすべての参照がインラインのコピーに置き換えられてしまう。元の参照を復元するにはどうすればいいか?</A>
  <LI>
<!--<A HREF="#kern-info">Does FontForge read in the old kerning information from
    fonts?</A> -->
    <A HREF="#kern-info">FontForge は元のカーニング情報をフォントから読み込むのか?</A>
  <LI>
<!--<A HREF="#mensis">How do I set a particular bit in the OS/2 table (or any
    other)?</A> -->
    <A HREF="#mensis">OS/2 テーブル (または別のどれか) の特定のビットをセットするにはどうすればいいか?</A>
</UL>
<H2>
<!--Mathematical questions-->
    数学的な質問
</H2>
<UL>
  <LI>
<!--<A HREF="#simplify">Does the simplify command lose accuracy?</A> -->
    <A HREF="#simplify">単純化(S) コマンドを使うと文字の正確度が落ちるのか?</A>
  <LI>
<!--<A HREF="#cubic-quadratic">How does FontForge convert a cubic spline into
    a quadratic spline for truetype?</A> -->
    <A HREF="#cubic-quadratic">FontForge では、どうやって 3 次スプラインを TrueType で用いられる 2 次スプラインに変換しているのか?</A>
  <LI>
<!--<A HREF="#quadratic-cubic">How does FontForge convert a quadratic spline
    into a cubic (when reading truetype)?</A> -->
    <A HREF="#quadratic-cubic">FontForge は (TrueType を読み込む際に) どのようにして 2 次スプラインを 3 次に変換しているのか?</A>
+</UL>
<H2>
<!--Random questions -->
    雑多な質問
</H2>
<UL>
  <LI>
<!--<A HREF="#monospace">How do I mark a font as monospaced?</A>-->
    <A HREF="#monospace">フォントを等幅であると設定するにはどうすればいいのか?</A>
  <LI>
<!--<A HREF="#new-encoding">How do I tell fontforge about a new encoding?</A>-->
    <A HREF="#new-encoding">FontForge に新しいエンコーディングを追加するにはどうすればいいか?</A>
  <LI>
<!--<A HREF="#new-name">How do I add a glyph with a new name?</A> -->
    <A HREF="#new-name">新しい名前のグリフを追加するにはどうすればいいか?</A>
  <LI>
<!--<A HREF="#save-no-change">After I generate a font and quit, why does FontForge
    ask if I want to save the font? I didn't change anything.</A> -->
    <A HREF="#save-no-change">フォントを生成した後に終了しようとすると、フォントを保存するかどうか FontForge が訊いてくるのはなぜか? 私は何も変更していないのに。</A>
  <LI>
<!--<A HREF="#minify-iconify">Why does my window get iconified when I want to
    minify the view?</A> -->
    <A HREF="#minify-iconify">ビューを縮小しようとすると、ウィンドウがアイコン化されてしまうのはなぜか?</A>
  <LI>
<!--<A HREF="#no-mu">Why isn't there a character named "mu" in my greek font?</A>
    (or "Delta", or "Omega", or "pi1") -->
    <A HREF="#no-mu">作成したギリシャ語フォントに "mu" (または "Delta", "Omega", "pi1") という名前の文字が見当たらないのはなぜか?</A>
  <LI>
<!--<A HREF="#no-copy-names">Why doesn't Edit-&gt;Copy copy glyph names as well
    as glyph info?</A> -->
    <A HREF="#no-copy-names">編集(E)→コピー(C) で、グリフ情報と一緒にグリフ名がコピーされないのはなぜか?</A>
  <LI>
<!--<A HREF="#copy-names">Why does Edit-&gt;Paste complain about name
    duplication?</A> -->
    <A HREF="#copy-names">編集(E)→貼り付け(P) を行うと、名前が重複していると怒られるのはなぜか?</A>
  <LI>
<!--<A HREF="faq.html#default-char">How do I set the default glyph of a font?</A> -->
    <A HREF="#default-char">フォントのデフォルトグリフを設定するにはどうすればいいか?</A>
  <LI>
<!--<A HREF="#mingliu">I looked at kaiu.ttf or mingliu.ttf and the outlines looked
    nothing like the correct glyphs. What's wrong?</A> -->
    <A HREF="#mingliu">kaiu.ttf や mingliu.ttf を開いてみると、アウトラインは正しいグリフと全然違って見える。何がまずいのか?</A>
  <LI>
<!--<A HREF="#greek-accents">When I use Element-&gt;Build Accented Glyph to build
    one of the Extended Greek glyphs (U+1F00-U+1FFF) FontForge picks the wrong
    accents. Why?</A> -->
    <A HREF="#greek-accents">ギリシャ文字拡張 (U+1F00〜U+1FFF) のグリフを作るために エレメント(L)→アクセントつきグリフを構築(B) を使用すると、FontForge は間違ったグリフを選ぶのはなぜか?</A>
  <LI>
<!--<A HREF="#u-accents">When I use Element-&gt;Build Accented Glyph to build
    accents over "u" or "y" I get the accent over one of the stems not centered
    on the glyph. Why?</A> -->
    <A HREF="#u-accents">"u" や "y" の上にアクセントをつけるために エレメント(L)→アクセントつきグリフを構築(B) を使用すると、アクセントがどちらかのステムの真上に来てしまい、グリフの中央に来ないのはなぜか?</A>
  <LI>
<!--<A HREF="#ttf2afm">Why does ttf2afm crash on FontForge ttf files?</A>-->
    <A HREF="#ttf2afm">FontForge が出力した TTF ファイルを処理すると ttf2afm がクラッシュするのはなぜか?</A>
  <LI>
<!--<A TARGET="_top" HREF="index.html#known-bugs">Where can I find a list of
    known bugs in FontForge?</A>-->
    <A TARGET="_top" HREF="index.html#known-bugs">FontForge の既知のバグのリストはどこに行けば見つかるのか?</A>
  <LI>
<!--<A HREF="#Unstable">Why is FontForge so unstable?</A>-->
    <A HREF="#Unstable">なぜ FontForge はとても不安定なのか?</A>
</UL>
<P>
  <HR>
<DL>
  <DT>
<!--<A NAME="font-editor"><B>Why a font editor, aren't there enough fonts
    already?</B></A>-->
    <A NAME="font-editor"><B>なぜフォントエディタを? もう十分にフォントはあるのでは?</B></A>
  <DD>
<!--Well... no. Otherwise I wouldn't be writing this.-->
    それは……違います。もしそうなら私はこのソフトを書いたりしませんでした。
    <OL>
      <LI>
<!--	There are lots of latin fonts. There are far fewer greek, cyrillic, indic,
	thai, chinese, japanese, korean, unicode... -->
	ラテン文字のフォントはたくさんあります。それに比べて、ギリシャ文字・キリル文字・インド系文字・タイ語・中国語・日本語・韓国語・Unicode のフォントはずっと少ない…。
      <LI>
<!--	Researchers into old writing systems often need to design their own fonts -->
	古い書字システムの研究者は、自分自身のフォントをデザインしなければならない場合がよくあります。
      <LI>
<!--	Even for latin, traditionally each new style of art and architecture has
	an associated style of fonts. New fonts are always being created to reflect
	the esthetics of the times. -->
	ラテン文字ですら、伝統的には芸術や建築に新しいスタイルが生まれるごとにそれに伴う書体のスタイルが新しく作られました。現代では、時代の美意識を反映するために常に新しいフォントが作られています。
      <LI>
<!--	Computer font technology is constantly changing. A font-format that was useful
	10 years ago may not be so now. -->
	コンピュータフォント技術は常に変化しています。10 年前に有用であったフォントフォーマットは現在役に立ちません。
      <LI>
<!--	Even if you are satisfied with the fonts that do exist they may not be complete -->
	あなたが既存のフォントに満足だったとしても、それが完全でない可能性はあります。
	<UL>
	  <LI>
<!--	    Missing ligatures -->
	    不足の合字
	  <LI>
<!--	    Missing accented glyphs -->
	    不足のアクセントつき文字
	  <LI>
<!--	    No matching cyrillic or greek glyphs -->
	    それに合うキリル文字又はギリシャ文字のグリフ
	</UL>
      <LI>
<!--	Everybody wants a font of his/her own handwriting. -->
	誰もが、自分自身の手書き文字をフォントにしたいと思います。
      <LI>
<!--	Playing with fonts is fun. -->
	フォントで遊ぶのはとても楽しい。
    </OL>
    <P>
<!--FontForge has uses beyond simply creating and modifying fonts. It can convert
    from one format to another. It can extract information from the font file.
    Or it can simply show you what the font looks like without having to install
    it. -->
    FontForge は単にフォントを作成・編集するだけではない用途にも使えます。あるフォーマットから他のフォーマットに変換することができます。フォントファイルから情報を取り出すこともできます。または、フォントをインストールしないで、それがどのように見えるかを表示するだけのために使うこともできます。
  <DT>
<!--<A NAME="write"><B>Why did I write it?</B></A> -->
    <A NAME="write"><B>私はなぜそれを書いたのか?</B></A>
  <DD>
    <UL>
      <LI>
<!--	Because it was fun -->
	それが楽しいから。
      <LI>
<!--	Because MacroMedia stopped development on Fontographer, and Fontographer
	was lacking features that I wanted. -->
	MacroMedia が Fontgrapher の開発をやめてしまったから。それと、Fontgrapher には、私が欲しかった機能がなかったから。
    </UL>
  <DT>
<!--<A NAME="give"><B>Why do I give it away?</B></A>-->
    <A NAME="give"><B>なぜ私はそれを人にあげてしまうことにしたか?</B></A>
  <DD>
    <UL>
      <LI>
<!--	Because I approve of free software and hope that the availability of good
	products on a good operating system will encourage people not to use proprietary
	systems. -->
	私はフリーソフトウェアに賛成していて、良い製品が良いオペレーティングシステム上で得られることにより、人々が商用のオペレーティングシステムを使わないことを奨励するから。
      <LI>
<!--	Because programming is a lot more fun than marketing and giving things away
	is easier than selling them. -->
	プログラミングはマーケティングよりもずっと楽しいし、人にあげてしまう方が売るよりも簡単だから。
      <LI>
<!--	Because I'd have to spend more time doing QA if I sold it -->
	これを売ることにすると、品質保証のために大量の時間を使わなければならないから。
    </UL>
  <DT>
<!--<A NAME="widget-set"><B>Why is FontForge based on a non-standard widget
    set?</B></A>-->
    <A NAME="widget-set"><B>なぜ FontForge は非標準のウィジェットセットをベースにしているのか?</B></A>
  <DD>
<!--I wanted a widget set that would handle Unicode reasonably well. In particular
    I thought support for bidi text was important for hebrew and arabic typography.
    As I was unaware of any widget sets that did that, I wrote my own.<BR>
    I also wanted a widget set where I could actually figure out whether the
    checkbox was checked or not checked. In far too many cases my eyes can't
    work out which is which... -->
    私は、Unicode を適度にうまく扱えるウィジェットセットが欲しかったのです。とくに、私は双方向テキストがヘブライ語とアラビア語のタイポグラフィにとって重要であると考えたからです。それを行えるウィジェットセットを知らなかったので、自分で書きました。<BR>
    それと、私はチェックボックスがチェックされているかチェックされていないかが本当に見分けられるウィジェットセットが欲しかったのです。私の目にはどっちがどっちだか区別のつかない場合が多すぎたもので…。
  <DT>
<!--<A NAME="C-plus-plus">Why isn't FontForge written in C++ (or <I>Why C++ is
    not my favorite language</I>)?</A> -->
    <A NAME="C-plus-plus">なぜ FontForge は C++ で書かれていないのか (または <I>なぜ C++ が私のお気に入りの言語でないのか</I>)?</A>
  <DD>
<!--I've been a little surprised to be asked this question, I had not realized
    my choice of language needed justification, but it appears to do so... -->
    私がこの質問を受けたときはちょっと驚きました。自分の言語の選択を弁明しなければならないとは知らなかったもので。でもそうらしい……。
    <P>
<!--Basically because I don't find object-oriented practices helpful in most
    cases, and because I find C++ far too complex and badly designed, and because
    I can't debug it easily. -->
    基本的に、私はオブジェクト指向を実践することがほとんどの場合に役立たずであると考えているからで、それに加えて、私は C++ があまりに複雑で悪いデザインであると考えているうえに、私はそれを簡単にデバッグできないからです。
    <UL>
      <LI>
<!--	I grew up with SIMULA and dabbled with SmallTalk and found after a few years
	that there were very few problems where an object oriented approach seemed
	natural to me. In most cases it just seemed to impose unneeded complexities
	on the problem. -->
	私は SIMULA で育ち、SmallTalk をかじったことがある人間ですが、何年かの経験の後に、オブジェクト指向アプローチが私にとって自然に感じるような問題は非常に少ないことを悟りました。ほとんどの場合、それは単に不要な複雑さを解くべき問題に持ち込んでいるだけのように見えたのです。
      <LI>
<!--	The semantics of a C++ program cannot be specified. The compiler is free
	to generate temporaries as it wishes. In C this is not a problem, but in
	C++ the creation of a temporary can involve calling a constructor and a
	destructor which may have untold side-effects. I find this frightening. -->
	C++ プログラムのセマンティクスは仕様化することが不可能です。コンパイラは、必要だと判断したときに思いのままにテンポラリを生成することができますが、C++ ではテンポラリを作成すると、予期せぬ副作用を伴う可能性のあるコンストラクタとデストラクタの呼び出しを引き起こします。私はこれにはぞっとしますね。
      <LI>
<!--	The order of execution of external constructors is unspecified. I have seen
	many inexplicable bugs caused by this -->
	外部コンストラクタの実行順序が指定されていません。これによって説明不可能なバグがたくさん発生するのを私は経験しました。
      <LI>
<!--	I find it extremely difficult to debug C++. Stepping through a statement
	often involves many unexpected procedure calls (some of which are inlined
	and not obvious). This distracts from my main purpose in debugging. -->
	私は、C++ のデバッグが非常に難しいことに気づきました。1 個の文をステップ実行すると、予想しない手続き呼び出しがたくさん発生することがしばしばです (それらの一部は、自明ではインライン関数です)。これにより、デバッグの元来の目的から気が散らされます。
      <LI>
<!--	Finally I find the language badly specified and too complex. Its various
	concepts do not fit well together. Each compiler seems to do things slightly
	differently. -->
	もう一つ言えば、言語の仕様化がへたくそで複雑すぎると思います。その各種の概念は相互にうまく整合していません。各コンパイラはそれぞれ異なる形で処理を行っているような気がします。
	<P>
<!--	I first met C++ in about 1981 when it was called C with Classes. I wrote
	the C++ front end for Green Hills Software's compiler suite from 1987 to
	1994 and I tracked each new version of the language from 1.1 to ANSI. -->
	私は 1981 年頃に、当時 "C with Classes" と招ばれていた C++ に出会いました。私は 1987 年から 1994 年にかけて、Green Hills Software のコンパイラスイートのために C++ フロントエンドを書き、バージョン 1.1 から ANSI までのそれぞれの新バージョンを追跡してきました。
	<P>
<!--	Each version added new features which did not sit well with the old ones.
	Each version was badly specified. The reference implementation was wildly
	different from the standard. For example the behavior of virtual functions
	inside constructors was not specified until version 2 of the language and
	since this behavior was different from naive expectations this caused bugs.
	My favorite confusion occurred in (I think it was) the version 2.1 specification
	where on one page, within a few paragraphs, the following two sentences occurred:
	"Unions may contain member functions." and "Unions may not contain member
	functions.". -->
	どのバージョンにも、以前のものの上にうまく追加できない新機能がありました。どのバージョンも仕様は不完全でした。参照実装は標準とはむちゃくちゃに違っていました。例えば、コンストラクタ内の仮想関数のふるまいは言語のバージョン 2 まで規定されておらず、その規定が素朴な解釈と異なっていたためにバグが発生しました。私のお気に入りの混乱は、(私の記憶が確かならば) バージョン 2.1 の仕様で、あるページの 2,3 段落の内に、以下の 2 つの文が飛び出したことです: "共用体はメンバ関数を含むことができる" と、"共用体はメンバ関数を含むことができない"。
    </UL>
    <P>
<!--The above are my personal opinions based on my experience and are explain
    why <I>I</I> do not use C++. Your opinions may differ, few people have spent
    5 years writing C++ compilers.-->
    上に書いたのは私の個人的な経験に基づいた個人的な意見で、なぜ<I>私が</I> C++ を使わないかの説明です。あなたの意見はこれとは違うでしょう、C++ コンパイラを書くのに 5 年間を費した人はほとんどいませんから。
  <DT>
<!--<A NAME="legal"><B>Is it legal to modify a font? Is it ethical?</B></A>-->
    <A NAME="legal"><B>フォントを改変することは合法か? 倫理上の問題はないのか?</B></A>
  <DD>
<!--Legal matters vary from country to country (and perhaps within countries).
    You really should consult a lawyer for a definitive answer. Here are some
    guide lines:-->
    法律上の事柄は国ごとに様々です (恐らく国内でも違いがあります)。決定的な答えが知りたければ、弁護士に相談するべきです。ここに示すのはいくつかのガイドラインです:
    <P>
<!--Look at the license agreement you received with the font and see what it
    has to say on this issue. -->
    あなたがフォントとともに入手した使用許諾を見て、この件に関してそれには何と書かれているかを見てください。
    <P>
<!--TrueType (and OpenType and potentially CID-keyed fonts) have a field in the
    OS/2 table called FSType which allows the font designer to place restrictions
    on what other people can do with the font. If this field prohibits modification
    fontforge will ask you to make sure you have an agreement with the font designer
    which supersedes this field. -->
    TrueType (および OpenType 並びに潜在的には CID キー指定フォント) には、OS/2 テーブル内に FSType と呼ばれるフィールドがあり、そこには他の人がこのフォントに対して何をすることができるかについてフォントデザイナーが制限を課すことができます。もしこのフィールドが変更を禁止している場合、FontForge は、あなたがフォントデザイナーからこのフィールドの制限を無視することの合意を得ているかどうかを尋ねます。
    <P>
<!--My understanding of US law (but check with a lawyer before relying on this)
    is that: -->
    米国の法律についての私の理解するところは以下のとおりです (ただし、これに頼る前に弁護士のチェックを得てください):
    <UL>
      <LI>
<!--	There is no legal protection for font designs. So legally in the US glyph
	images may be traced. Obviously this is not ethical if the font designer
	is currently alive. -->
	フォントデザインに対する法的な保護は存在しない。それゆえ、米国内ではグリフ画像を合法にトレースすることができる。フォントデザイナーが現在生きている場合、これは明らかに倫理上の問題がある。
      <LI>
<!--	Font programs (such as a postscript or truetype font file, but not a bitmap
	font file) may be copyrighted. -->
	フォントプログラム (PostScript または TrueType のフォントファイルといったもの。ただしビットマップフォントファイルはこれに入らない) は著作権で保護可能である。
      <LI>
<!--	Font names may be trademarked. -->
	フォント名は商標権で保護することができる。
    </UL>
    <P>
<!--My understanding is that in most European countries there are laws against
    copying the design (the shape) of a font. -->
    私の理解では、ほとんどのヨーロッパの国々では、フォントのデザイン (形) を複製することを禁ずる法律が存在します。
    <P>
<!--I would welcome any additions or corrections here, as well as info on the
    laws governing fonts in other countries. -->
    追加、または訂正があれば歓迎します。その他の国でフォントに関する規定のある法律についてに情報も歓迎します。
  <DT>
<!--<A NAME="pointsize"><B>What is a 12 point font?</B></A> <B>(What measurement
    of the font determines the point size?)</B> -->
    <A NAME="pointsize"><B>12 ポイントのフォントとは何か?</B></A> <B>(ポイントサイズは、フォントのどこを計って決めるのか?)</B>
  <DD>
    <IMG SRC="pointsize.png" WIDTH="147" HEIGHT="96" ALIGN="Right"><!--A font is
    12 points high if the distance between the baselines of two adjacent lines
    of (unleaded) text is 12 points. -->
    あるフォントが 12 ポイントの高さをもつのは、(ベタ組みの) テキストで隣接する 2 行のベースライン同士の間隔が 12 ポイントである時です。
    <P>
<!--The pointsize is not based on the sizes of any of the glyphs of the font. -->
    ポイントサイズは、フォントのどのグリフのサイズにも基づいていません。
    <P>
<!--Back when fonts were made out of metal, the pointsize of the font was the
    height of the metal slugs used for that font. -->
    フォントが金属で作られていた時代に戻ると、フォントのポイントサイズは、そのフォントとともに用いられていた込物の高さと同じでした。
    <P>
<!--In some sense this is not a very good measure of the size of a font (some
    fonts may allow more room for accents or ascenders or descenders than others
    meaning that the height of the actual glyphs will be smaller). -->
    ある意味ではこれはフォントのサイズの計り方としてあまりいい方法ではありません (いくつかのフォントはアクセントまたはアセンダやディセンダに他のフォントより多くの空間を取っているため、実際のグリフの高さはより小さくなることになります)。
    <P>
<!--There is also a measurement scheme based on the x-height of the glyphs. -->
    グリフの x ハイトに基づいた計測体系もあります。
    <P>
<!--In England and the US a point has traditionally meant the pica point (1/72.27th
    of an inch), while in Europe the point has been the didot point (1/67.54th
    of an inch). The Europeans have a slightly larger point, but the glyphs of
    English and European fonts appear the same size. English does not use accents
    (except in very rare cases) while most European languages do, and the slight
    increase in the size of the point allows more room for accents. -->
    英米ではポイントとは伝統的にパイカポイント (1 インチの 72.27 分の 1) のことでしたが、ヨーロッパではポイントはディドーポイント (1 インチの 67.54 分の 1) のことでした。ヨーロッパではわずかに大きなポイントを使用していますが、英国とヨーロッパのフォントは同じサイズであることが分かっています。ほとんどのヨーロッパの諸言語ではアクセントを使うのに対して、英語では (ごく稀な場合を除いて) アクセントを使用しないので、ポイントのサイズがわずかに増えたことによってアクセントのための空間がより多く取ることができます。
    <P>
<!--(Of course now most Europeans are probably forced to use the pica point by
    their desktop software, while must computer fonts now contain accented glyphs,
    so the distinction and the reason for it may have vanished). -->
    (もちろん、現在ではほとんどのヨーロッパ人はデスクトップソフトウェア上でパイカポイントを使うことを強いられており、ほとんどのコンピュータフォントは現在アクセントつきグリフを含んでいます。ですからこれらの区別とその必然性は消え去ったと言えるでしょう)。
  <DT>
<!--<A NAME="linespace"><B>How do I set the line spacing on a font?</B></A>-->
    <A HREF="linespace"><B>フォントの行間を設定するにはどうすればよいか?</B></A>
  <DD>
<!--It depends on the kind of font you are generating, the operating system under
    which you are running, and luck. -->
    その方法は、出力しようとしているフォントの種類、使用しているオペレーティングシステムの種類、そして運によって異なります。
    <UL>
      <LI>
<!--	For Type1 fonts there is no way to set the line spacing. Applications will
	often take the values specified in the font's bounding box and use those
	to set the line spacing. This is a really bad idea on their part, but it
	is common practice. -->
	Type 1 フォントでは、行間を設定する方法はありません。たいていの場合、アプリケーションはフォントのバウンディングボックスで指定された値を行間の設定に用います。これは彼らの側にしてみればまったくひどい考えですが、広く実践されている方法です。
      <LI>
<!--	For True/Open Type fonts the answer is complicated. -->
	TrueType/OpenType フォントでは答えは非常に複雑です。
	<UL>
	  <LI>
<!--	    On the mac<BR>
	    The line spacing is set by the ascender and descender values of the 'hhea'
	    table. These in turn are set to the bounding box values of the font. Not
	    a good choice. -->
	    Mac では<BR>
	    ラインスペーシングは 'hhea' テーブルのアセンダとディセンダの値によって設定されます。これは、裏を返せばフォントのバウンディングボックスの値に設定されるということです。これは賢い選択ではありません。
	  <LI>
<!--	    On windows<BR>
	    Line spacing is supposed to be set to the Typo Ascent/Typo Desent values
	    specified in the OS/2 table. And these in turn are supposed to sum to the
	    emsize. (FontForge sets these values to the ascent/descent values you specify
	    for your font). Unfortunately most windows applications don't follow this
	    rule, and instead set them to the Win Ascent/Descent values of the OS/2 table.
	    These values are supposed to specify a clipping region for the font (not
	    line spacing). The clipping region should be as big as the font's bounding
	    box, but in some cases needs to be bigger. -->
	    Windows では<BR>
	    ラインスペーシングは OS/2 テーブルの Typo Ascent/ Typo Descent の値により設定されるものとされています。その一方、これらは EM サイズと一致するものと仮定されています。(FontForge はこれらの値を、ユーザがフォントに対して設定した高さ(A)/深さ(D)の値にします)。これらの値は、フォントのクリッピング領域 (ラインスペーシングではなく) を指定するものと考えられます。クリッピング領域はフォントのバウンディングボックスを含む大きさであるべきですが、ある場合にはそれより大きくする必要があります。
	    <P>
<!--	    (The clipping region should be bigger than the bounding box if a GPOS lookup
	    could move a glyph so that it extended beyond the bounding box (mark to base
	    is likely to cause problems). I'm not sure how this applies to cursive
+	    positioning in Urdu where GPOS lookups can make lines arbetrarily tall) -->
	    (GPOS の位置指定によってグリフがバウンディングボックスからはみ出る位置に移動する場合は、クリッピング領域はバウンディングボックスよりも大きくする必要があります (マークから基底文字への参照が問題を起こすようです)。GPOS によって行がいくらでも高くなる可能性があるウルドゥー語の筆記体ではこれがどのように当てはまるのかについてはよく分かりません)
	  <LI>
<!--	    On linux<BR>
	    I don't know that there is a general consensus. An application will probably
	    use one of the above methods. -->
	    Linux では<BR>
	    一般的な合意が存在するのかどうかは知りません。アプリケーションはおそらく上記の方法のいずれかを使用するでしょう。
	</UL>
    </UL>
  <DT>
<!--<A NAME="font-install"><B>How do I install the fonts once I've made
    them?</B></A> -->
    <A NAME="font-install"><B>自分が作ったフォントをどうやってインストールすればいいのか?</B></A>
  <DD>
<!--Well it rather depends on what system you are working on, and what type of
    font you've got: -->
    えーこれはあなたがどのシステムで作業中か、あなたが作ったのはどのタイプのフォントかに大きく依存します:
    <DL>
      <DT>
<!--	<STRONG>Unix &amp; X</STRONG> (<A NAME="X-Install">but</A> not KDE) -->
	<STRONG>Unix 上の X</STRONG> (KDE を<A NAME="X-Install">除く</A>)
      <DD>
<!--	I'd suggest that you look at the
	<A TARGET="_top" HREF="http://www.linuxdoc.org/HOWTO/Font-HOWTO.html">linux
	font HOWTO file</A>, and the
	<A TARGET="_top" HREF="http://www.linuxdoc.org/HOWTO/mini/FDU/">font
	deuglification HOWTO</A> as good starting points. But I'll run over the
	highlights -->
	<A TARGET="_top" HREF="http://www.linux.or.jp/JF/JFdocs/Font-HOWTO/">Linux フォント HOWTO</A> ファイルを調べることを提案します。また、<A TARGET="_top" HREF="http://www.linuxdoc.org/HOWTO/mini/FDU/">font deuglification HOWTO</A> はよい出発点となるでしょう。しかし私も要点をざっと述べておきましょう。
	<P>
<!--	Essentially you designate one (or several) directories as a "font directory".
	You move your fonts to that directory. You build up certain data structures
	that X needs, and you tell X to include this directory in your font path.
	Sadly different versions of X and the X font server use slightly different
	conventions. You may need to alter these procedures a bit. -->
	本質を言えば、1 個 (または数個) のディレクトリを「フォントディレクトリ」に割り当てます。フォントをそのディレクトリに移動します。X が必要とするいくつかのデータ構造を構築し、あなたのフォントパスにこのディレクトリを組み込むように X に指示します。残念ながら異なるバージョンの X および X フォントサーバは微妙に異なる習慣を使用します。以下に挙げる手続きはあなたの所では多少変更する必要があるでしょう。
	<P>
<!--	For example, if you want to install a <EM>bdf font </EM>called frabnuts-13.bdf
	then you might: -->
	例えば、あなたが frabnuts-13.bdf という名前の <EM>BDF フォント</EM>をインストールしたい場合、以下のようにする必要があるでしょう:
	<BLOCKQUOTE>
	  <PRE>$ mkdir my_fonts
$ mv frabnuts-13.bdf my_fonts
$ cd my_fonts
$ bdftopcf frabnuts-13.bdf &gt;frabnuts-13.pcf
$ mkfontdir
$ xset fp+ `pwd`
</PRE>
	</BLOCKQUOTE>
	<P>
<!--	and your fonts should be installed. After that, whenever you start X you
	need to remind it of where your fonts live, so you should add<BR> -->
	こうすればあなたのフォントはインストールされたことになります。この後、あなたが X を起動するたびにあなたのフォントがどこにあるかを思い出さなければなりませんので、
	<CODE>&nbsp; &nbsp; $ xset fp+ /home/me/my_fonts</CODE><BR>
<!--	to your .xsession (or equivalent). -->
	という記述を .xsession (または等価なファイル) に記述する必要があるでしょう。
	<P>
<!--	If you want to install <EM>postscript fonts</EM><BR> -->
	<EM>PostScript フォント</EM>をインストールしたい場合<BR>
<!--	You should generate them as postscript binary (.pfb) files, then move both
	the .pfb and the .afm file into (one of) your font directory(ies) and run
	<A TARGET="_top" HREF="http://rpmfind.net/linux/rpm2html/search.php?query=type1inst">type1inst</A>
	in it.<BR>
	type1inst will probably complain that your font doesn't have a foundry and
	will probably get the encoding wrong. You can either: -->
	フォントは PostScript バイナリ (.pfb) ファイルとして出力するべきです。それから .pfb と .afm の両方のファイルをフォントディレクトリ (のどれか 1 つ) に移動し、そこで <A TARGET="_top" HREF="http://rpmfind.net/linux/rpm2html/search.php?query=type1inst">type1inst</A> を実行してください。<BR>
	type1inst はおそらく、あなたのフォントに製造所 (foundry) が含まれておらず、おそらくエンコーディングが間違っているだろうと文句を言うでしょう。以下のいずれかの方法が可能です:
	<UL>
	  <LI>
<!--	    Ignore it and nothing bad will happen -->
	    無視する。悪い事は何も起こらないでしょう。
	  <LI>
<!--	    Manually edit fonts.scale after running type1inst to fix these entries -->
	    type1inst を実行した後で、これらの項目を修正するために fonts.scale を手で編集する。
	  <LI>
<!--	    Make your font's Copyright be reasonable, and then edit type1inst and add
	    your foundry (directions for this are in type1inst itself) -->
	    フォントの Copyright を適切な値に設定し、それから type1inst を編集してあなたの製造所名を追加する (このやり方は、type1inst その物に書いてあります)。
	</UL>
	<P>
<!--	If you want to install <EM>truetype fonts</EM><BR> -->
	<EM>TrueType フォント</EM>をインストールしたい場合<BR>
<!--	You move the .ttf file into your font directory and run mkttfdir and
	mkfontdir.<BR> -->
	フォントディレクトリに .ttf ファイルを移動してから mkttfdir と mkfontdir を実行します。<BR>
<!--	(<A TARGET="_top" HREF="http://rpmfind.net/linux/rpm2html/search.php?query=mkttfdir">mkttfdir</A>
	has a small problem with fonts created by FontForge, it will almost invariably
	complain that it doesn't recognize the foundry. You can safely ignore this,
	but if it bothers you then add a line to ttmkfdir.c at 936<BR> -->
	(<A TARGET="_top" HREF="http://rpmfind.net/linux/rpm2html/search.php?query=mkttfdir">mkttfdir</A> には、FontForge で作られたフォントの扱いに関する小さな問題があります。それは必ずと言っていいほど確実に製造元が認識できないと警告してきます。無視しても何ら問題はありませんが、それを煩わしく感じるならば ttmkfdir.c の 936 行目に以下の 1 行を追加してください。<BR>
	<CODE> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { "PFED", "FontForge"
	},</CODE>
	<P>
<!--	Some versions of X (ie, those shipped by redhat) rely on the x font server
	to do font work rather than the X server itself. You may need to use chkfontpath
	to add your new directory to the font server's font path (rather than xset
	fp).<BR> -->
	いくつかのバージョンの X (例えば、redhat に同梱のもの) は、フォントの処理を X サーバそれ自身で行うのではなく、X フォントサーバに頼っています。chkfontpath を使用してフォントサーバのフォントパスに新しいディレクトリを追加する必要があるでしょう (xset fp ではなく)。
<!--	You may also need to insure that the font directory (and all its parent
	directories) are readable to world. (the font server runs as a non-privileged
	user) -->
	また、フォントディレクトリ (およびその上位ディレクトリ) は万人に対して読み出し可能でなければなりません (フォントサーバは非特権ユーザとして実行されます)
	<P>
<!--	I haven't seen anything that says X supports <EM>opentype</EM> fonts yet,
	but since freetype does (and I think X's rasterizer uses freetype) then X
	might support them too. Installing them will require manual editing of
	fonts.scale though (mkttfdir uses freetype1 which doesn't support otf files). -->
	私は、X が <EM>OpenType</EM> をサポートしているという発言をまだ見たことがありませんが、FreeType はサポートしている (また、X のラスタライザは FreeType を使用しているはずである) ので、X はそれらもサポートすることができるでしょう。ただし、それをインストールするには fonts.scale を手で編集する必要があります (mkttf は、OTF ファイルをサポートしていない freetype1 を使用しています)。
	<P>
<!--	That sounds really confusing. I apologize, I'm not a good writer and there
	are too many choices in configuring X... -->
	この説明では訳が分からないでしょう。私は優秀な書き手ではないことと、X を設定する方法には多くの選択肢がありすぎることを言い訳しておきます……。
      <DT>
	<STRONG>KDE</STRONG>
      <DD>
<!--	(I don't know KDE very well, so take my experience with a grain of salt)
	Under KDE there is a tool called
	<A TARGET="_top" HREF="http://www.cpdrummond.uklinux.net/kfontinst/">kfontinst</A>
	which is supposed to do all the configuration work for you. I was only able
	to get it to work as root and had to reconfigure my system to follow its
	conventions, but once that was done it installed X fonts quite handily. I
	never did figure out how to get it to install ghostview fonts. (I experimented
	with version 0.9.2) -->
	(私は KDE について深く知りませんので、私の経験については眉に唾をつけて読んでください) KDEでは、<A TARGET="_top" HREF="http://www.cpdrummond.uklinux.net/kfontinst/">kfontinst</A> と呼ばれるツールがあり、これが必要なすべての設定を行うものと考えられています。私はこれを動かすために root になる必要があり、私のシステムを以下の習慣に従うように再設定する必要がありましたが、いったん設定が終われば X へのフォントのインストールはごく簡単に行うことができました。私は、自分が ghostview フォントをどうやってインストールするかについてはまったく分かりませんでした (私が試したのは version 0.9.2 です)。
      <DT>
	<STRONG>TeX</STRONG>
      <DD>
<!--	TeX has its own (platform independent) system for installing fonts. I've
	described my experiences so far
	<A HREF="PfaEdit-TeX.html#TeX-Install" TARGET="_top">elsewhere in this
	document</A>. -->
	TeX は独自の (プラットホーム独立な) フォントインストール用のシステムを備えています。私は自分の経験した限りの事柄を<A HREF="PfaEdit-TeX.html#TeX-Install" TARGET="_top">この文書の別の場所</A>で説明しました。
      <DT>
	<STRONG><A NAME="Windows-Install">Windows</A></STRONG>
      <DD>
<!--	You install truetype fonts on windows by dropping them into the \Windows\Fonts
	directory on your machine. You may need to set the execute permission bit
	on the font before installing it.<BR> -->
	TrueType フォントの Windows へのインストールは、そのマシンの \Windows\Fonts ディレクトリにフォントをドロップすることによって行います。フォントをインストールする前に、実行許可ビットを有効にする必要があるでしょう。<BR>
<!--	<FONT COLOR="Red"><STRONG>Do <BIG>NOT</BIG> generate the font directly into
	\Windows\Fonts</STRONG></FONT>, this doesn't seem to work (at least on under
	my XP machine). You must generate the font into another directory and drag
	&amp; drop it to \Windows\Fonts .<BR> -->
	<FONT COLOR="Red"><STRONG>フォントを直接 \Windows\Fonts に出力<BIG>しないで</BIG>ください</STRONG></FONT>。それではうまく動かないようです (少なくとも私の XP マシンでは)。フォントをいったん別のディレクトリに出力してから、\Windows\Fonts にドラッグ &amp; ドロップしてください。<BR>
<!--	If you want to use type1 fonts you will need to install adobe type manager
	and follow its instructions.<BR> -->
	Type 1 フォントを使用したい場合は、Adobe Type Manager をインストールして、以下の手順に従う必要があるでしょう。
<!--	If you want to install opentype fonts then on old systems (before windows
	2000, I think) you need to install ATM, on more recent systems opentype should
	work the same way truetype does. -->
	OpenType フォントを古いシステム (たしか、Windows 2000 よりも前だと思います) にインストールしたいときは、ATM をインストールする必要があります。最近のシステムでは OpenType は TrueType と同じように扱うことができます。
      <DT>
	<STRONG><A NAME="OS9-Install">Macintosh OS 9</A></STRONG>
      <DD>
<!--	Oh dear. The mac sticks fonts into resource forks and wraps them up in its
	own headers. Mac fonts aren't compatible with anybody else's. FontForge can
	create a resource fork if it wraps the font up in a macbinary encoding. See
	the <A HREF="faq.html#How-mac">following question</A> for more information.<BR>
	I've also written <A TARGET="_top" HREF="http://fondu.sourceforge.net/">some
	utilities </A>designed to convert from one format to another and they may
	prove useful.<BR> -->
	ったく…。Mac はフォントをリソースソースに張りつけ、独自のヘッダをつけて固めたデータ構造に納めています。Mac のフォントは他のどのシステムとも互換性がありません。FontForge は、フォントを MacBinary エンコーディングに固めたときはリソースフォークを作成することができます。より詳しい情報は<A HREF="faq.html#How-mac">以下の質問</A>を参照してください。私は、あるフォーマットから別のフォーマットに変換する<A TARGET="_top" HREF="http://fondu.sourceforge.net/">ちょっとしたユーティリティ</A>も書いていて、それらは役に立つことが実証済みです。<BR>
<!--	<A TARGET="_top" HREF="http://babel.uoregon.edu/yamada/fontconversionfaq.html">University
	of Oregon has some links that might be helpful</A>.<BR>
	<A TARGET="_top" HREF="http://babel.uoregon.edu/yamada/fontconversionfaq.html">オレゴン大学</A>は役に立つと思われるいくつかのリンクを提供しています。</A><BR>
<!--	Once you've converted your fonts you just drop them into the System Folder
	and they should be available after that. -->
	一度フォントを変換してしまえば、それをシステムフォルダにドロップするだけで、その後すぐ使えるようになるでしょう。
      <DT>
	<STRONG><A NAME="OSX-Install">Macintosh OS X</A></STRONG>
      <DD>
<!--	On OS/X fonts should be placed either in the top-level Library/Fonts directory
	(By default <CODE>/Mac OS X/Library/Fonts/</CODE>), in the System/Library/Fonts
	directory, or in the user's appropriate fonts sub-directory
	(<CODE>~/Library/Fonts</CODE>).<BR> -->
	OS X では、フォントはトップレベルの Library/Fonts ディレクトリ (デフォルトでは <CODE>/Mac OS X/Library/Fonts/</CODE>) に置くか、System/Library/Fonts ディレクトリか、またはそのユーザに一致する Fonts サブディレクトリ (<CODE>~/Library/Fonts</CODE>) に置くことができます。
<!--	Either a resource font (unwrapped from its macbinary wrapper) or a dfont
	may be used. You can also use straight ttf and otf files (ie. the same file
	OpenType dfonts do (so if you want to use Postscript use OpenType). 
	you might use on Unix or MS).<BR> -->
	リソースフォント (MacBinary ラッパから展開したもの) または dfont のどちらも使用できます。通常の TTF および OTF ファイル (つまり、Unix や MS Windows で使えるのと同じファイル) も使用できます。
<!--	As far as I can tell the old NFNT bitmap resources do not work on my OS 10.2.
	If you want to use bitmap fonts wrap them up in a ttf file or an sfnt. However
	if you want to use a Type1 resource font, you must generate a (useless) bitmap
	font and install them both. -->
	私の言える限りでは、昔の NFNT ビットマップリソースは私の OS 10.2 では動きません。ビットマップを使いたい場合は、TTF ファイルまたは sfnt に固めてください。ただし、Type1 リソースフォントを使いたい場合は、(役に立たない) ビットマップフォントも一緒に生成し、それらを両方インストールする必要があります。
    </DL>
  <DT>
<!--<A NAME="Bad-Windows-Install"><B>Why won't FontForge's fonts install on some
    MS Windows machines?</B></A>-->
    <A NAME="Bad-Windows-Install"><B>どうして FontForge で作ったフォントが MS Windows のシステムにインストールできないことがあるのか?</B></A>
  <DD>
<!--Do <FONT COLOR="Red"><STRONG>NOT</STRONG></FONT> generate a font directly
    into the \windows\fonts directory. Generate the font into a different directory
    and then use windows drag and drop to install the font. (Windows appears
    to do magic when it moves the font into that directory). -->
    フォントを直接 \windows\fonts ディレクトリに出力<FONT COLOR="Red">しないでください</FONT>。フォントを別のディレクトリに出力して、その後に Windows のドラッグ &amp; ドロップ操作で fonts ディレクトリに移動してください。<BR>
    <P>
<!--I am told that fonts produced by old versions of FontForge will not install
    on Windows 2000 (and XP) systems. -->
    古いバージョンの FontForge が出力したフォントは Windos 2000 (および XP) システムにインストールできないと聞きました。
    <P>
<!--I believe this problem is fixed now (as of 20-Oct-2003). If you have an older
    version please upgrade.<BR>-->
    私は、これらの問題は (2003年10月20日現在) すでに解決済みであると信じています。それより古いバージョンをお使いの方はアップグレードをお願いします。<BR>
<!--If you are copying a font from another machine make sure the execute bit
    is set in the permissions of the font file (I don't know how to do this with
    the Windows UI, under cygwin you say <CODE>$ chmod +x foo.ttf</CODE>-->
    フォントを別のマシンからコピーしてきた場合、フォントファイルの実行ビットが設定されていることを確認してください (これを Windows の UI 上で行う方法を知りませんが、cygwin では <CODE>$ chmod +x foo.ttf</CODE> とすれば変更できます。)
  <DT>
<!--<A NAME="How-mac"><B>How do I edit fonts from my macintoy?</B></A>-->
    <A NAME="How-mac"><B>マク用のフォントを編集するにはどうすればいいの?</B></A>
  <DD>
    <DL>
      <DT>
<!--	Mac OS/9 (or less)-->
	Mac OS/9 (またはそれ以前)
      <DD>
<!--	Traditionally the macintosh has stored fonts in the resource fork of files
	(after about OS/8.5 I believe the mac also supported bare .ttf files). This
	causes problems for any machine other than a mac, because the very concept
	of a resource fork is lacking.<BR> -->
	伝統的に Macintosh はフォントをファイルのリソースフォークに格納してきました (OS/8.5 頃から後では、Mac は裸の .ttf ファイルのサポートも行っていると思います)。これは Mac 以外のすべてのマシンでは、リソースフォークの概念がまったく無いために、問題となります。<BR>
<!--	There are several programs whose job it is to store all of a macintosh file
	in one package that can be manipulated on other systems (mac binary and binhex
	are the most common). FontForge knows how to read both of these formats and
	can extract a postscript or truetype font from either. FontForge can also
	create fonts in macbinary format (I see no reason to support both output
	formats, and macbinary is slightly simpler).<BR> -->
	Macintosh の 1 個のファイル全体を他のシステムで扱える 1 個のパッケージに格納する目的のプログラムがいくつかあります (最もよく使われているのは MacBinary と BinHex です)。FontForge はこれら両方のフォーマットをどうやって読むかを知っており、それらのどちらからでも PostScript フォントや TrueType フォントを読み出すことができます。FontForge はフォントを MacBinary フォーマットで作成することもできます (両方の出力フォーマットのサポートが必要となる理由は見当たりませんし、MacBinary のほうが少し単純だったので)。<BR>
<!--	So to edit a font on your mac: -->
	そういう訳で、Mac のフォントを編集する手順は以下のようになります:
	<OL>
	  <LI>
<!--	    Find the file in the <TT>System Folder:Fonts</TT> folder -->
	    <TT>System Folder:Fonts</TT> フォルダにあるファイルを見つける
	  <LI>
<!--	    Copy the file over to your unix machine -->
	    ファイルを Unix マシンにコピーする
	    <UL>
	      <LI>
<!--		Use Fetch and specify macbinary format -->
		Fetch を使用し、MacBinary フォーマットを指定する。
	      <LI>
<!--		Or use some tool like binhex which can create the file directly -->
		または BinHex のような、ファイルを直接作成できるツールを使う
	    </UL>
	  <LI>
<!--	    Open it in FontForge -->
	    それを FontForge で開く
	  <LI>
<!--	    Edit it -->
	    編集する
	  <LI>
<!--	    Save it back in macbinary format -->
	    フォントを再び MacBinary フォーマットで保存する
	  <LI>
<!--	    Copy it back to your mac -->
	    それを Mac に返送する
	    <UL>
	      <LI>
<!--		Fetch will automatically undo the macbinary wrappers and make it be correct -->
		Fetch は自動的に MacBinary ラッパを展開し、正しいファイルにします
	      <LI>
<!--		Or various other tools can unwrap it. -->
		またはその他各種のツールでも展開できます。
	    </UL>
	  <LI>
<!--	    Drop it back into your system folder (where it is automagically moved to
	    Fonts) -->
	    それを元のシステムフォルダにドロップする (それにより、自動的に Fonts に転送されます)
	</OL>
	<P>
<!--	<STRONG>Note:</STRONG> make sure you either replace the original font files,
	or that you rename the font within fontforge and (for postscript fonts) that
	you give it a new unique id. See the <A TARGET="_top" HREF="fontinfo.html">Font
	Info</A> dlg. -->
	<STRONG>注意:</STRONG> 元のフォントファイルを別の場所に移すか、(PostScript フォント用の) フォント名を FontForge で書き換えたうえで新しいユニーク ID をつけておくことを忘れないでください (<A TARGET="_top" HREF="fontinfo.html">フォント情報</A>ダイアログを参照してください)。
	<P>
<!--	<STRONG>Caveat:</STRONG> A postscript font is useless on a macintosh unless
	it is accompanied by at least one bitmap font. If you generate a postscript
	font make sure you also generate an NFNT as well (this has the FOND).<BR>-->
	<STRONG>警告:</STRONG> PostScript フォントは、最低 1 個のビットマップフォントが付属していないと Mac では役に立ちません。PostScript フォントを出力するときには、NFNT (これは FOND を含んでいます) も一緒に出力する必要があります。<BR>
<!--	<STRONG>Caveat:</STRONG> The mac is picky about the filename used to contain
	a postscript file. It is based on the postscript font name but suffers a
	transformation. Don't try to rename this file. Basically the rules are (see
	<A TARGET="_top" HREF="http://partners.adobe.com/asn/developer/pdfs/tn/0091.Mac_Fond.pdf">Adobe
	Technical Note 0091</A>): -->
	<STRONG>警告:</STRONG> Mac は、PostScript ファイルを格納しているファイルの名前にはうるさいのです。この名前は PostScript フォント名に基づいていますが、変換をかけたものです。このファイルの名前を変更しようと試みないでください。基本的なルールは以下の通りです (<A TARGET="_top" HREF="http://partners.adobe.com/asn/developer/pdfs/tn/0091.Mac_Fond.pdf">Adobe Technical Note 0091</A> を参照してください):
	<UL>
	  <LI>
<!--	    The fontname is broken into chunks where each chunk starts with a capital
	    letter. -->
	    フォント名は、大文字で始まるいくつかの単位文字列に分解される。
	  <LI>
<!--	    The first chunk may have four lower case letters following the initial capital -->
	    最初の単位文字列には、大文字で書かれた先頭文字の次に 4 個の小文字を続けることができる。
	  <LI>
<!--	    Subsequent chunks may only have two lower case letters following the capital. -->
	    残りの単位文字列には、大文字の後ろには小文字 2 文字しか続けることができない。
	  <LI>
<!--	    Non-letter glyphs (or at least hyphens) vanish.<BR>
	    So TimesBold =&gt; TimesBol, Helvetica-BoldItalic =&gt; HelveBolIta,
	    NCenturySchoolbook =&gt; NCenSch -->
	    英字以外の文字 (少なくともハイフン) は取り除かれる。<BR>
	    これにより、TimesBold ⇒ TimesBol, Helvetica-BoldItalic ⇒ HelveBolIta, NCenturySchoolbook ⇒ NCenSch と変換される。
	</UL>
      <DT>
<!--	Mac OS/X -->
	Mac OS X
      <DD>
<!--	On Mac OS/X you can run <A TARGET="_top" HREF="MacOSX.html#Running">FontForge
	directly</A> (if you've got <A TARGET="_top" HREF="MacOSX.html#binary">XDarwin
	installed</A>). OS/X has several font formats, some fonts are stored in the
	old format (see above), while others are stored as data fork resources. The
	data fork font files generally have the extension ".dfont". On a Mac FontForge
	is able to edit both formats directly. OS/X also supports normal .otf and
	.ttf font files. -->
	Mac OS X では (<A TARGET="_top" HREF="MacOSX.html#binary">XDarwin がインストールしてあれば</A>) <A TARGET="_top" HREF="MacOSX.html#Running">FontForge を直接起動する</A>ことができます。OS X にはいくつかのフォントフォーマットがあり、いくつかのフォントは古いフォーマット (上記参照) で格納されており、一方そのたのものはデータフォークリソースとして格納されています。データフォークフォントファイルの拡張子は、ふつう ".dfont" です。Mac では、FontForge はどちらのフォーマットも直接編集できます。OS X は通常の .otf および .ttf 形式のフォントファイルもサポートしています。
	<P>
<!--	Mac OS/X does not seem to support the old NFNT bitmap format, but it still
	requires that an bitmap font in NFNT format be present before it will use
	a resource-based postscript font. (It is probably not the NFNT resource which
	is required, but the FOND which goes along with it. But I'm not going to
	write something to produce a bare FOND resource). -->
	Mac OS X は NFNT ビットマップフォーマットをサポートしていないようです。それでも未だに、リソースベースの PostScript を使用する際には NFNT フォーマットのビットマップフォントが含まれている必要があります (おそらく、実際に必要なのは NFNT リソースではなくてそれに付随する FOND リソースだと思いますが、裸の FOND リソースを出力する何らかのデータを書き出すようにする予定はありません)。
    </DL>
  <DT>
<!--<B><A NAME="How-family">How do I create a mac font family? (How do I get
    the mac to group my fonts so that the italic and bold styles work)?</A></B> -->
    <B><A NAME="How-family">どうすれば Mac のフォントファミリーを作れるのか? (フォントをグループ化して、イタリックやボールドのスタイル指定が動作するようにするにはどうしたらいいか?</A></B>
  <DD>
<!--For the Style menu in most mac applications to work on your fonts, you must
    create a font family. You do this with the
    <A TARGET="_top" HREF="filemenu.html#GenerateMac">File-&gt;Generate Mac
    Family</A> command. -->
    ほとんどすべての Mac アプリケーションの「書式」メニューであなたのフォントが動作するようにするには、フォントファミリーを作成しなければなりません。これを行うには、<A TARGET="_top" HREF="filemenu.html#GenerateMac">ファイル(F)→Macファミリーを出力(F)</A> コマンドを使用します。
    <P>
<!--All the fonts in a family must have the same Family name (See the
    <A TARGET="_top" HREF="fontinfo.html">font info</A> dialog). Font Families
    are handled rather differently under Carbon (the old font handling mechanism
    used in OS 9) and under ATSUI (on OS/X). -->
    同じファミリーに含まれるフォントには、すべて同じファミリー名をつけなければなりません (<A TARGET="_top" HREF="fontinfo.html">フォント情報</A>ダイアログを参照してください)。フォントファミリーは Carbon (OS 9 で使われていた古いフォント処理メカニズム) と、(OS X の) ATSUI とでは扱いがかなり異なります。
    <P>
<!--Under Carbon, the font family is limited by the design of the Mac 'FOND'
    resource, which reflects the computer font technology of the early 1980s.
    Modern computer fonts often have variants that can't be expressed in it.
    FONDs support any combination (except one containing both Extend and Condense)
    of the following styles: -->
    Carbon では、フォントファミリーが使えるのは、1980 年台前半のコンピュータフォント技術を反映している、Mac の "FOND" リソースに限られています。現代的なコンピュータフォントは、これでは表しきれない変種を含むことがしばしばあります。FONDS は以下のスタイルの任意の組合せをサポートします (ただし Extend と Condense は同時に指定できません):
    <UL>
      <LI>
	Bold
      <LI>
	Italic
      <LI>
	Condense
      <LI>
	Extend
      <LI>
	Underline
      <LI>
	Shadow
      <LI>
	Outline
    </UL>
    <P>
<!--Mac FONDS do not support "Black", "DemiBold", "Light", "Thin" or
    "Extra-Condensed" variants. -->
    Mac の FOND は "Black", "DemiBold", "Light", "Thin" または "Extra-Condensed" のような変種をサポートしていません。
    <P>
<!--Under ATSUI, on the other hand, a family seems to consist of all fonts in
    a given resources file which have the same FamilyName. -->
    一方、ATSUI の下では、ファミリーは同じ FamilyName をもつ一定のリソースファイルに含まれるすべてのフォントから構成されているようです。
    <P>
<!--In order that a family be useful under both systems, Apple appears to several
    FONDs inside such a font file. Each FOND contains a sub-family of related
    fonts. The 'FOND's appear to be distributed as follows: -->
    どちらのシステムでもファミリーが役に立つようにするに、Apple は 1 個のフォントファイルに 2, 3 の FOND を格納しているようです。各 FOND には関連するフォントのサブファミリーが含まれています。それらの 'FOND' は以下のように分散しているようです:
    <P>
<!--Suppose you have a family of fonts with the following styles:<BR> -->
    以下のスタイルをもつフォントのファミリーがあるものとする:<BR>
    Regular, Bold, Italic, Bold-Italic, Condense, Condense-Italic, Oblique, Light,
    Light-Italic, Black<BR>
<!--Then you should create a font family with the styles that the FOND does support,
    which in this case would be<BR> -->
    その場合、FOND がサポートするスタイルを含んだフォントファミリーを作成するべきである。この場合は以下のようになるだろう:<BR>
    Regular, Bold, Italic, Bold-Italic, Condense, Condense-Italic<BR>
<!--For each of these use
    <A HREF="fontinfo.html#FONDName" TARGET="_top">Element-&gt;Font
    Info-&gt;Mac</A> to set the FondName field to the font's family name. -->
    これらのそれぞれに、<A HREF="fontinfo.html#FONDName" TARGET="_top">エレメント(L)→フォント情報(F)→[Mac]</A> を用いて、フォントのファミリー名に使われる FOND 名を設定すること。
    <P>
<!--Change the fondname of the other styles, so that the Oblique style has Oblique
    in the fond name, the two Light styles have Light in the fond name, and so
    on. Set the <A HREF="fontinfo.html#Mac-Style" TARGET="_top">Mac Style</A>
    on the "Light" variant of the font to be Regular (everything unselected)
    and set the style of the "Light-Italic" variant to be "Italic" -- that is,
    forget about the "Light", the FOND can't handle it, that's why we moved it
    into its own family. -->
    他のスタイルの FOND 名を別の名前に設定して、Oblique スタイルには FOND 名に "Oblique" が含まれるようにし、2 種類の Light スタイルには "Light" が含まれるようにする。フォントの "Light" 版の変種を <A HREF="fontinfo.html#Mac-Style" TARGET="_top">Mac スタイル</A> で (何も選択されない状態にすることにより) Regular に設定し、"Light-Italic" の変種を "Italic" に編集する――これは、FOND が扱えない"Light" については忘れるということです。"Light" のついた物をそれ自体別のファミリーとして分類したのはそのためです。
    <P>
<!--Having done this setup, the <A HREF="filemenu.html#GenerateMac">Generate
    Mac Family </A>command should be able to put all the fonts into appropriate
    FONDs, and then place all the FONDs into one file, which the Mac should interpret
    correctly. -->
    この設定が終わったら、<A HREF="filemenu.html#GenerateMac">Macファミリーを出力(F)</A> コマンドを実行すれば、すべてのフォントは適切な FOND に配置し、すべての FOND を Mac が正しく解釈できるはずの 1 個のファイルに出力することができるでしょう。
  <DT>
<!--<B><A NAME="Mac-ATM">Why doesn't ATM work on my fonts?</A></B>-->
    <B><A NAME="Mac-ATM">なぜ自作のフォントが ATM でうまく使えないのか?</A></B>
  <DD>
<!--Insure that the font has an encoding of Macintosh Latin when you generate
    it. -->
    フォントを出力する時には、それが Macintosh Latin エンコーディングを含んでいることを確認してください。
    <P>
<!--This is really a limitation on ATM's part and there's nothing FontForge can
    do about it. -->
    この制限事項は完全に ATM のせいであって、FontForge がこれに対して手出しできる事は何もありません。
    <P>
<!--If you generate a font with an encoding other than Macintosh Latin, then
    the Mac's default behavior is to force the postscript font to have a Macintosh
    Latin encoding. There is a mechanism to turn this behavior off, but if it
    is turned off then ATM won't work at all. -->
    もし、フォントを Macintosh Latin 以外のエンコーディングで出力した場合には、Mac のデフォルトの動作では、その PostScript フォントが Macintosh Latin 符号化方式を含んでいると強制的に解釈します。このふるまいを停止する機能が存在しますが、それを停止してしまうと ATM はまったく動かなくなるでしょう。
  <DT>
<!--<B>How do I edit fonts on MS <A NAME="windows">windows</A>?</B>-->
    <B>MS <A NAME="windows">Windows</A> でフォントを編集するにはどうすればよいか?</B>
  <DD>
<!--To run FontForge under MS windows you must first install the
    <A TARGET="_top" HREF="http://www.cygwin.com/">cygwin environment</A>. -->
    FontForge を MS Windows で実行するには、まず最初に <A TARGET="_top" HREF="http://www.cygwin.com/">cygwin の実行環境</A> をインストールしなければなりません。
    <UL>
      <LI>
<!--	First download the setup.exe program from
	<A TARGET="_top" HREF="http://www.cygwin.com/">http://www.cygwin.com/</A> -->
	まずプログラム setup.exe を <A TARGET="_top" HREF="http://www.cygwin.com/">http://www.cygwin.com/</A> からダウンロードする。
      <LI>
<!--	Run it. It will ask you what components of cygwin you wish to install -->
	setup.exe を実行する。cygwin のコンポーネント群からどれをインストールしたいのかかを質問してくるはずである。
      <LI>
<!--	You will need the base components, the X window system, xorg-x11-base, and
	xterm (NOTE: These are separate packages) -->
	必ず、base コンポーネント、X ウィンドウシステム、xorg-x11-base および xterm はインストールしなければなりません (注意: これらは別々のパッケージです)。
      <LI>
<!--	Once you have cygwin installed, start it. This should give you a terminal
	window running bash (a unix shell) -->
	既に cygwin をインストールしてあるなら、それを起動してください。それにより、bash (Unix シェルの一種) を実行中の端末ウィンドウが 1 つ立ち上がるはずです。
      <LI>
<!--	Download the <A TARGET="_top" HREF="index.html#binary">cygwin version of
	FontForge</A>, and move it to whatever directory you think most appropriate
	(<CODE>/usr/local/bin</CODE> is a reasonable choice) -->
	<A TARGET="_top" HREF="index.html#binary">cygwin 版の FontForge</A> をダウンロードし、どこか一番適切だとあなたが考えたディレクトリ (<CODE>/usr/local/bin</CODE> は妥当な選択の 1 つです) に移動してください。
	<BLOCKQUOTE>
	  <PRE>$ mkdir -p /usr/local/share/fontforge /usr/local/bin /usr/local/man/man1
$ cd /tmp
$ tar xfzv fontforge_cygwin*.tar
$ cd fontforge
$ mv *.ui /usr/local/share/fontforge
$ mv fontforge.1 /usr/local/man/man1
$ mv fontforge.exe /usr/local/bin
</PRE>
	</BLOCKQUOTE>
	<P>
<!--	Then edit the file ~/.bashrc by (or by whatever other tool you prefer): -->
	次に、~/.bashrc を以下の手順で (またはその他の好みのツールを使っても構いません) 編集します:
	<BLOCKQUOTE>
	  <PRE>$ cat &gt;&gt; ~/.bashrc
PATH=${PATH}:/usr/local/bin ; export PATH
MANPATH=${MANPATH:-}:/usr/local/man ; export MANPATH
^D
</PRE>
	</BLOCKQUOTE>
      <LI>
<!--	Then each time you want to run fontforge, type:-->
	それからは、FontForge を起動するたびごとに、
	<BLOCKQUOTE>
	  <PRE>$ xinit
</PRE>
	</BLOCKQUOTE>
      <LI>
<!--	This should bring up X in a large window that covers the screen and within
	that should be a subwindow, an xterm, running bash. -->
	と打ってください。これにより、画面全体を覆う大きなウィンドウに X が起動し、そこには、bash を実行する xterm がサブウィンドウとして出ているはずです。
      <LI>
<!--	From the xterm you should be able start FontForge. -->
	xterm から FontForge を起動できるようになっているはずです。
	<BLOCKQUOTE>
	  <PRE>$ fontforge -new
</PRE>
	</BLOCKQUOTE>
    </UL>
    <P>
<!--If you want to be able to build FontForge under cygwin, you will need to
    grab some other cygwin components, like gcc, the image processing libraries,
    freetype, etc. -->
    あなたが cygwin 環境で FontForge をビルドできるようにしたいならば、gcc や画像処理ライブラリ、freetype などのいくつかの cygwin コンポーネントを取得する必要があるでしょう。
  <DT>
<!--<B><A NAME="Bad-Windows-Fonts">Why don't my fonts work on windows?</A></B>-->
    <B><A NAME="Bad-Windows-Fonts">なぜ自作のフォントが Windowsで使えないのか?</A></B>
  <DD>
<!--Here's one possibility: Windows sometimes (and I don't know when) insists
    on having a name for the font in the appropriate language (ie. a Japanese
    entry for a SJIS font). Try going to
    <A TARGET="_top" HREF="fontinfo.html#TTF-Names">Element-&gt;Font Info-&gt;TTF
    Names </A>and adding a set of strings for your language. -->
    ここに示すのは 1 つの可能性です: Windows は場合により (どんな場合かはよく分かりません)、適切な言語 (例えば、SJIS フォントでは日本語) の名前が name テーブルに含まれていることにこだわります。<A TARGET="_top" HREF="fontinfo.html#TTF-Names">エレメント(L)→フォント情報(F)→[TTF名]</a>を呼び出して、使用している言語の文字列を一式追加してみてください。
    <P>
<!--Another possibility is discussed
    <A HREF="faq.html#Bad-Windows-Install">here</A>.-->
    その他の可能性については <A HREF="faq.html#Bad-Windows-Install">ここ</A>で議論しました。
  <DT>
<!--<A NAME="Missing-Refs"><B>When I load an otf or a type1 font most of my
    references have been replaced by inline copies. How do I get my references
    back?</B></A>-->
    <A NAME="Missing-Refs"><B>OTF または Type1 フォントを読み込んだ時、ほとんどすべての参照がインラインのコピーに置き換えられてしまう。元の参照を復元するにはどうすればいいか?</B></A>
  <DD>
<!--It is very difficult to figure out old references when loading postscript
    fonts. Instead FontForge has a special command,
    <A HREF="editmenu.html#ReplaceRef" TARGET="_top">Edit-&gt;Replace With
    Reference</A>, that will search for potential reference candidates in the
    font and replace them with references. -->
    PostScript フォントを読み込んだときに、それにもとは参照が含まれていたのを認識するのは非常に困難です。その代わりに、FontForge にはフォント内に含まれる潜在的な参照の候補を検索してそれらを参照に置換する専用のコマンド <A HREF="editmenu.html#ReplaceRef" TARGET="_top">編集(E)→参照に置換</A> があります。
  <DT>
<!--<B><A NAME="kern-info">Does FontForge read in the old kerning information
    from fonts?</A></B>-->
    <B><A NAME="kern-info">FontForge は元のカーニング情報をフォントから読み込むのか?</A></B>
  <DD>
<!--This question needs to be broken down into cases:-->
    この質問はいくつかの場合に分けて答える必要があります:
    <DL>
      <DT>
<!--	<B>TrueType and OpenType fonts</B> -->
	<B>TrueType および OpenType フォント</B>
      <DD>
<!--	Yes. The kerning information is stored in either the 'kern' or 'GPOS' tables
	of these fonts and FontForge can read the most common formats (Apple has
	made a number of extensions beyond the original truetype spec, and FontForge
	does not handle all the Apple formats). -->
	はい。カーニング情報は、これらの形式のフォントでは 'kern' または 'GPOS' テーブルに格納されており、FontForge はほとんどの一般的なフォーマットを読み込むことができます (Apple はオリジナルの TrueType の仕様に数々の拡張を加えていて、FontForge は Apple のフォーマットを完全にはサポートしていません)。
      <DT>
<!--	<B>PostScript Type1 fonts anywhere other than the Mac.</B> -->
	<B>Mac 以外のあらゆる環境での PostScript Type1 フォント</B>
      <DD>
<!--	The kerning information is not stored in a Type 1 font file. Instead it is
	stored in a file with the same filename as the font file but with the extension
	".afm". When FontForge reads a PostScript font it will check for an associated
	afm file, and if found will read the kerning information from it. -->
	カーニング情報は Type1 フォントファイルには格納されません。その代わりに、ファイル名の本体が同じで拡張子が ".afm" になっているファイルの中に格納されます。FontForge が PostScript フォントを読み込むとき、それは付随する AFM ファイルをチェックし、もし見つかったならば、そのファイルからカーニング情報を読み込みます。
      <DT>
<!--	<B>PostScript Type1 fonts on the Mac.</B> -->
	<B>Mac 上での PostScript Type1 フォント</B>
      <DD>
<!--	No. Again the kerning information is not stored in the font file (it is stored
	in a bitmap font file), but on the mac it is impossible to guess what name
	to use for the associated bitmap file, and FontForge does not even try. <BR>
	See the info below on how to load kerning from a
	<A HREF="faq.html#FOND-kern">FOND</A>. -->
	いいえ。この場合もカーニング情報はフォントファイルの中には格納されません (それは、ビットマップフォントファイルの中に格納されます) が、Mac 上では付随するビットマップの名前を推測することが不可能なため、FontForge は試そうともしません。<BR>
	<A HREF="faq.html#FOND-kern">FOND</A> からカーニング情報をどのようにして読み込むかについては、下記の情報を参照してください。
      <DT>
<!--	<B>AFM and TFM files.</B> -->
	<B>AFM および TFM ファイル</B>
      <DD>
<!--	FontForge can read kerning information directly from these files and apply
	those data to a font. See the
	<A TARGET="_top" HREF="filemenu.html#Merge-kern">File-&gt;Merge Kern Info</A>
	menu command. -->
	FontForge はカーニング情報をこれらのファイルから直接読み込み、それらのデータをフォントに対して適用することができます。<A TARGET="_top" HREF="filemenu.html#Merge-kern">ファイル(F)→カーニング情報の併合</A> メニューコマンドを参照してください。
      <DT>
<!--	<B>Mac resource files containing FOND resources.</B> -->
	<B>FOND リソースを含む Mac リソースファイル</B>
      <DD>
<!--	The mac stores kerning information in the <A NAME="FOND-kern">FOND</A> resource
	associated with a bitmap font (it is not stored in the file with the postscript
	font). If you wish kerning data for a mac postscript font, you must find
	a font file containing a bitmap font with the same family and style as the
	postscript. FontForge can read kerning information directly from these files
	and apply those data to a font. See the
	<A TARGET="_top" HREF="filemenu.html#Merge-kern">File-&gt;Merge Kern Info</A>
	menu command. -->
	Mac はカーニング情報をビットマップフォントに伴う <A NAME="FOND-kern">FOND</A> リソースに格納します。これは PostScript フォントを含むファイルには格納されていません)。Mac の PostScript フォントにカーニングデータが必要な場合、PostScript フォントと同じファミリーとスタイルをもつビットマップフォントを含んだフォントファイルを見つけなければなりません。FontForge はカーニング情報を直接これらのファイルから読み込み、そのデータをフォントに適用することができます。<A TARGET="_top" HREF="filemenu.html#Merge-kern">ファイル(F)→カーニング情報の併合</A> メニューコマンドを参照してください。
   </DL>
  <DT>
<!--<B><A NAME="outline-conversion">How do I convert from one outline format
    to another?</A></B>
    <B><A NAME="outline-conversion">あるアウトラインフォーマットから他の方式に変換するにはどうすればよいか?</A></B>
  <DD>
<!--This is easy, simply open an existing font, and then use
    <A HREF="generate.html" TARGET="_top">Element-&gt;Generate Fonts </A>to generate
    the desired output. -->
    これは簡単です。既存のフォントを開き、次に <A HREF="generate.html" TARGET="_top">エレメント(L)→フォントを出力(G)</A> コマンドを使って欲しいファイル形式で出力してください。
  <DT>
<!--<B><A NAME="bitmap-conversion">How do I convert from one bitmap format to
    another?</A></B> -->
    <B><A NAME="bitmap-conversion">あるビットマップフォーマットから他の方式に変換するにはどうすればよいか?</A></B>
  <DD>
<!--This is also easy, open a bitmap font, and then use
    <A HREF="generate.html" TARGET="_top">Element-&gt;Generate Fonts</A> to generate
    the desired output. -->
    これも簡単です。ビットマップフォントを開き、次に <A HREF="generate.html" TARGET="_top">エレメント(L)→フォントを出力(G)</A> コマンドを使って欲しいファイル形式で出力してください。
  <DT>
<!--<B><A NAME="outline-bitmap">How do I convert from an outline format to a
    bitmap format?</A></B> -->
    <B><A NAME="outline-bitmap">アウトラインフォーマットからビットマップフォーマットに変換するにはどうすればよいか?</A></B>
  <DD>
<!--Load the outline font. Then use
    <A HREF="elementmenu.html#Bitmaps" TARGET="_top">Element-&gt;Bitmaps
    Available</A> to generate bitmap strike(s) of the appropriate size(s). This
    process is called rasterization, at small pixel sizes it is difficult for
    a computer to do well. You might be advised to examine the results of the
    rasterization in the <A HREF="bitmapview.html" TARGET="_top">bitmap window</A>
    (with <A HREF="windowmenu.html#Bitmap" TARGET="_top">Window-&gt;Open Bitmap
    Window</A>), possibly fixup the bitmap as you go. Then when done select
    <A HREF="generate.html" TARGET="_top">Element-&gt;Generate Fonts</A>, turn
    off outline font generation (unless you also want an outline font, of course),
    and select the desired bitmap format. -->
    アウトラインフォントを開いてください。次に <A HREF="elementmenu.html#Bitmaps" TARGET="_top">エレメント(L)→使用するビットマップ(A)</A> を使って、適切なサイズのビットマップを (必要なだけ) 生成してください。この処理はラスタ変換と呼ばれ、小さなサイズの場合計算機ではうまく行うのが困難です。ラスタ変換の結果を<A HREF="bitmapview.html" TARGET="_top">ビットマップウィンドウ</A>内で (<A HREF="windowmenu.html#Bitmap" TARGET="_top">ウィンドウ(W)→ビットマップウィンドウを開く(B)</A>を使って) 確認すれば、おそらくビットマップを望み通りに修正する必要があるだろうとアドバイスしておきましょう。それが終ってから<A HREF="generate.html" TARGET="_top">ファイル(F)→フォントを出力(G)</A>を選択し、アウトラインフォントの出力をオフにして (もちろん、アウトラインフォントが必要な場合は別です)、必要なビットマップフォーマットを選んでください。
  <DT>
<!--<B><A NAME="bitmap-outline">How do I convert from a bitmap format to an outline
    format?</A></B> -->
    <B><A NAME="bitmap-outline">ビットマップフォーマットからアウトラインフォーマットに変換するにはどうすればよいか?</A></B>
  <DD>
<!--Unless you have a very large bitmap font (such as a TeX font) the following
    procedure will not produce good results. -->
    非常に大きなビットマップフォント (TeX フォントのような) を持っているのでなければ、以下の処理によって良好な出力結果は得られないでしょう。
    <UL>
      <LI>
<!--	Before you do anything else make sure you have either the
	<A HREF="autotrace.html" TARGET="_top">potrace or autotrace programs
	</A>installed on your system -->
	何か処理を行う前に、<A HREF="autotrace.html" TARGET="_top">potrace か autotrace プログラム</A>がシステムにインストールされているか確認してください。
	  <HR>
      <LI>
<!--	Create a new font -->
	新しいフォントを作成します。
      <LI>
<!--	Use the <A HREF="filemenu.html#Import" TARGET="_top">File-&gt;Import
	</A>command to import your bitmap font into this new font -->
	<A HREF="filemenu.html#Import" TARGET="_top">ファイル(F)→取り込み(I)</A>コマンドを使って、ビットマップフォントをこの新しいフォントに取り込みます。
	<UL>
	  <LI>
<!--	    Be sure to check the <CODE>[] Into Background</CODE> checkbox -->
	    <CODE>[] 背景として使用</CODE> チェックボックスにチェックが入っているか確認してください。
	</UL>
      <LI>
<!--	Edit-&gt;Select All -->
	編集(E)→すべて選択(A)
      <LI>
<!--	Element-&gt;Autotrace-->
	エレメント(L)→自動トレース(R)
      <LI>
<!---	Element-&gt;Add Extrema -->
	エレメント(L)→極大点の追加(X)
      <LI>
<!--	Element-&gt;Simplify<BR>
	At this point you will probably want to look at your outline glyphs and clean
	them up. -->
	エレメント(L)→単純化(S)<BR>
	おそらくこの段階で、アウトライングリフを目で見て形を整える必要があるでしょう。
      <LI>
<!--	File-&gt;Generate Fonts -->
	ファイル(F)→フォントを出力(G)
    </UL>
  <DT>
<!--<A NAME="hint-subs"><B>How do I make FontForge use hint substitution?</B></A> -->
    <A NAME="hint-subs"><B>FontForge がヒント置換を行うようにするにはどうすればいいか?</B></A>
  <DD>
<!--It happens automagically.-->
    勝手に処理してくれます。
  <DT>
<!--<A NAME="flex-hints"><B>How do I make FontForge use flex hints?</B></A>-->
    <A NAME="flex-hints"><B>FontForge が flex ヒントを使うようにするにはどうすればいいか?</B></A>
  <DD>
<!--It happens automagically. FontForge will generate flex hints in situations
    where it is appropriate to do so. You don't need to do anything. If flex
    hints are used then the necessary subroutines will be added to the font.
    If they are not needed then the subroutines will not be added. -->
    勝手に処理してくれます。FontForge は flex ヒントを出力するのが適切な状況のときに出力を行います。あなたは何もする必要はありません。flex ヒントを使用するとき、必要なサブルーチンはフォントに追加されます。ヒントが不要な時は、サブルーチンは追加されません。
  <DT>
<!--<B><A NAME="flex2">How can I tell if it is going to use flex hints?</A></B>-->
    <B><A NAME="flex2">flex ヒントが使われるかどうかはどうすれば分かるのか?</A></B>
  <DD>
<!--If you want to see whether FontForge is going to use flex hints, turn on
    the <A HREF="prefs.html#UpdateFlex">UpdateFlex</A> preference item and open
    a view on the glyph. FontForge displays a green halo around the center point
    of a flex hint.-->
    FontForge が flex ヒントを使おうとしているかどうか確認したいときは、環境設定項目 <A HREF="prefs.html#UpdateFlex">UpdateFlex</A> をオンにしてから当該グリフのグリフビューを開いてください。FontForge は、flex ヒントの中心点を緑色の丸で囲って示します。
  <DT>
<!--<A NAME="fuzzy"><B>My glyphs are all perfectly hinted, why do some stems
    have different widths (or appear fuzzy, or fade away completely)?</B></A> -->
    <A NAME="fuzzy"><B>どのグリフも完璧にヒントづけしたのに、幅が揃わない (またはぼやけて見えたり完全に掠れて見えなかったりする) ステムがあるのはなぜか?</B></A>
  <DD>
<!--Both PostScript and TrueType require that glyphs be drawn in a clockwise
    fashion. Some rasterizers don't care. But other rasterizers will have
    difficulties with counter-clockwise paths and produced stems of different
    widths when they should be the same, or fuzzy stems, or even nothing at all.
    The solution to this is to run Element-&gt;Correct Direction on all your
    glyphs before generating a font.<BR>
    But sometimes the poor rasterizer just can't do the right thing... -->
    PostScript と TrueType のどちらも、グリフの輪郭は時計回りに描かなければなりません。あるラスタライザではどちらでも問題になりません。しかし別のラスタライザでは反時計回りのパスを描いたときに、正しい幅と異なる太さのステムや、ぼやけたステムを表示したり、全く何も表示しないことさえあります。これに対する解決策は、フォントを出力する前に、エレメント(L)→アウトラインの向きを修正(C) を全ての文字に対して実行することです。
  <DT>
<!--<A NAME="mensis"><B>How do I set a particular bit in the OS/2 table (or any
    other)?</B></A> -->
    <A NAME="mensis"><B>OS/2 テーブル (または別のどれか) の特定のビットをセットするにはどうすればいいか?</B></A>
  <DD>
<!--FontForge does not do this, but I have written a companion program,
    <A HREF="http://mensis.sf.net/">mensis</A> (Latin for: "to or for, by, with
    or from tables") which gives you bit access to tables. It provides both UI
    and scripting access. -->
    FontForge はその機能はありませんが、私は <A HREF="http://mensis.sf.net/">mensis</A> (ラテン語で「テーブルに(のために,によって,から)」の意味) というテーブルにビット単位のアクセスができる補助プログラムを書きました。これは UI とスクリプトアクセスの両方を提供しています。
  <DT>
<!--<B><A NAME="monospace">How do I mark a font as monospaced?</A></B>-->
    <B><A NAME="monospace">フォントを等幅であると設定するにはどうすればいいのか?</A></B>
  <DD>
<!--You don't. Just insure that all the glyphs in the font have the same width
    and then FontForge will automatically mark it as monospaced for you. (If
    you mark it as monospaced incorrectly some rasterizers will give strange
    results). -->
    それはできません。フォント内の全てのグリフが同じ幅を持つようにすれば、FontForge はそれを等幅であると印づけます。(実際に等幅でないフォントを等幅と印づけると、一部のラスタライザでは結果がおかしくなります)。
    <P>
<!--If you are unsure whether all the glyphs in your font have the same advance
    width use <A HREF="problems.html#Advance">Element-&gt;Find
    Problems-&gt;Random-&gt;Check Advance.</A> -->
    フォントに含まれる全グリフが同じ送り幅を持っているかどうか自信がない場合は、<A HREF="problems.html#Advance">エレメント(L)→問題点を発見(O)→[ランダム]→送り幅をチェック:</A> を使用してください。
  <DT>
<!--<A NAME="new-encoding"><B>How I do tell fontforge about a new
    encoding</B></A>-->
    <A NAME="new-encoding"><B>FontForge に新しいエンコーディングを追加するにはどうすればいいか?</B></A>
  <DD>
<!--First ask yourself if you really need a new encoding? If you are using OpenType
    or TrueType fonts you can usually get by with the standard unicode encoding.
    But if you really need a new one here is a rough idea of what to do: -->
    本当に新しいエンコーディングが必要ですか? 自問してみてください。OpenType または TrueType フォントを使用しているなら、標準の Unicode エンコーディングで用が足りるはずです。しかし、もし本当に新しく追加する必要がある場合、必要な作業は大体こういう感じです:
    <P>
<!--Figure out what your encoding looks like. Often this will involve searching
    around the web to find an example of that encoding. For instance if you want
    a devanagari encoding you might look at
    <A TARGET="_top" HREF="http://www.cwi.nl/~dik/english/codes/indic.html">a
    site which shows the ISCII encodings</A> -->
    似たようなエンコーディングを探す。しばしば、そのエンコーディングの雛形となるものを探して Web を検索して回る必要があります。例えば、デーヴァナーガリー文字のエンコーディングが必要なら、<A TARGET="_top" HREF="http://www.cwi.nl/~dik/english/codes/indic.html">ISCII の各種エンコーディングを載せているサイト</A>を参照するべきでしょう。
    <P>
<!--These encodings only show the top 96 characters, presumably the others are
    the same as US ASCII. Look at the images and figure out how they map to unicode
    (or more precisely what the appropriate postscript names are for those
    characters). -->
    これらのエンコーディングは上半分の 96 文字のみを示しています。おそらく、他は US ASCII と同じでしょう。画像を見てそれらが Unicode にどのように対応づけられるか (または、より正確にやるならば、それらの文字の適切な PostScript 名はなにか) を調べてください。
    <P>
<!--Create a file (call it "Devanagari.ps" in this case). It should start with
    a line: -->
    ファイルを作成します (この例では "Devanagari.ps" と呼ぶことにします)。それはこのような行で始まるでしょう:
    <BLOCKQUOTE>
      <PRE>/Devanagari {
</PRE>
    </BLOCKQUOTE>
    <P>
<!--This tells FontForge that the encoding is called "Devanagari", then follow
    this with a list of all the character names (preceded by a slash). We start
    with ASCII which starts with 32 .notdef characters, then space, etc. -->
    これは FontForge に、このエンコーディングが "Devanagari" という名前であることを指示しており、その後ろにはすべての文字の (スラッシュが頭についた) 名前のリストが続きます。最初は ASCII で、32 個の .notdef 文字から始まり、それから space 等の文字が続きます。
    <BLOCKQUOTE>
      <PRE>/Devanagari {
 /.notdef
 /.notdef
 ...
 /.notdef
 /space
 /exclam
 /quotedbl
 ...
 /braceright
 /asciitilde
 /.notdef
 ...
 /.notdef
 /uni0901
 /uni0902
 ...
 /uni096F
}
</PRE>
    </BLOCKQUOTE>
    <P>
<!--Now load this file into FontForge's list of encodings with Element-&gt;Font
    Info-&gt;Encoding-&gt;Load, and then apply it to whatever fonts you want. -->
    ファイルを作成したら、FontForge のエンコーディングリストに エレメント(L)→フォント情報(F)→エンコーディング→[読み込み(L)] でこれを追加し、それからお好きなフォントにそれを適用してください。
  <DT>
<!--<A NAME="new-name"><B>How do I add a glyph with a new name?</B></A>-->
    <A NAME="new-name"><B>新しい名前のグリフを追加するにはどうすればいいか?</B></A>
  <DD>
<!--Let's say you wanted to add a "dotlessi" glyph to an ISO-8859-1 font (this
    encoding does not include dotlessi). There are two ways to approach the problem: -->
    ここでは仮に、グリフ "dotlessi" を ISO 8859-1 のフォントに (これには dotlessi は含まれていません) を追加したいとしましょう。この問題へアプローチする方法は 2 つあります:
    <OL>
      <LI>
<!--	Bring up <CODE>Element-&gt;Font Info</CODE><BR>
	Select the <CODE>Encoding</CODE> tab<BR>
	Increment the <CODE>Number of Glyphs</CODE> field by one (probably to
	<CODE>257</CODE>)<BR>
	Press <CODE>OK</CODE><BR>
	Scroll down to the end of the font and find the new glyph<BR>
	Select it<BR>
	Bring up <CODE>Element-&gt;Glyph Info</CODE><BR>
	Type your new name into the <CODE>Unicode Name</CODE> field (in this case
	you'd type in <CODE>dotlessi</CODE>)<BR>
	Press the <CODE>Set From Name</CODE> button<BR>
	Press <CODE>OK</CODE><BR>
	Now draw a dotlessi in the glyph. -->
	<CODE>エレメント(L)→フォント情報(F)</CODE> を呼び出す<BR>
	<CODE>エンコーディング</CODE> タブを選択する<BR>
	<CODE>グリフの数(N)</CODE> フィールドを 1 増やす (おそらく <CODE>257</CODE> になるでしょう)<BR>
	<CODE>OK</CODE>を押す<BR>
	フォントの最後までスクロールして新しいグリフを探す<BR>
	そのグリフを選択する<BR>
	<CODE>エレメント(L)→グリフ情報(I)</CODE> を呼び出す<BR>
	新しい文字の名前を <CODE>Unicode名(N)</CODE> フィールドに入力する (この場合は <CODE>dotlessi</code> と打つ)<BR>
	<CODE>名前で指定(A)</CODE> ボタンを押す<BR>
	<CODE>OK</CODE>を押す<BR>
	これで、そのグリフに dotlessi をデザインすることができます。
      <LI>
<!--	Bring up <CODE>Element-&gt;Font Info</CODE><BR>
	Select the <CODE>Encoding</CODE> tab<BR>
	Change the <CODE>Encoding</CODE> to <CODE>ISO-10646-1 (Unicode)</CODE><BR>
	Press <CODE>OK</CODE><BR>
	Bring up <CODE>View-&gt;Goto</CODE><BR>
	Type in <CODE>dotlessi</CODE><BR>
	Press <CODE>OK</CODE><BR>
	Now draw the dotlessi glyph in the selected glyph slot<BR>
	Bring up <CODE>Element-&gt;Font Info </CODE>again<BR>
	Change the <CODE>Encoding</CODE> back to whatever it was -->
	<CODE>エレメント(L)→フォント情報(F)</CODE> を呼び出す<BR>
	<CODE>エンコーディング</CODE> タブを選択する<BR>
	<CODE>エンコーディング(E)</CODE> から <CODE>ISO 10646-1 (Unicode, BMP)</CODE> を選択する<BR>
	<CODE>OK</CODE>を押す<BR>
	<CODE>表示(V)→移動(G)</CODE> を呼び出す<BR>
	<CODE>dotlessi</CODE> と打ち込む<BR>
	<CODE>OK</CODE>を押す<BR>
	ここで、選択されたグリフスロットにグリフ dotlessi を作成する<BR>
	もう一度<CODE>エレメント(L)→フォント情報(F)</CODE> を呼び出す<BR>
	<CODE>エンコーディング(E)</CODE> を変更前の値に戻す
    </OL>
  <DT>
<!--<A NAME="Open-size"><B>Why isn't my Open Type font much smaller than the
    .pfb file?</B></A> -->
    <A NAME="Open-size"><B>自作の OpenType フォントが .pfb ファイルよりもずっと小さくならないのはなぜか?</B></A>
  <DD>
<!--This is probably because you didn't round to int before saving the font.
    FontForge will save the font using fixed point numbers which take up a lot
    more space than normal integers. -->
    それはおそらく、フォントを出力する前に座標値を整数に丸めていないからです。FontForge は、通常の整数よりも遥かに大きな容量を必要とする固定小数点数としてフォントを出力します。
  <DT>
<!--<A NAME="Open-difference"><B>What's the difference between OpenType and
    PostScript (or TrueType) fonts?</B></A> -->
    <A NAME="Open-difference"><B>OpenType と PostScript (や TrueType) フォントはどこが違うのか?</B></A>
  <DD>
<!--Both PostScript and TrueType define a file format and a glyph format. OpenType
    uses the TrueType file format with a PostScript glyph format (actually OpenType
    includes the TrueType glyph format as well, but the OpenType definition says
    such fonts should still be called TrueType fonts so I ignore that aspect). -->
    PostScript フォントと TrueType はそれぞれ独自のファイルフォーマットとグリフフォーマットの定義をもっています。OpenType は TrueType のファイルフォーマットを PostScript のグリフフォーマットと組み合わせて使います (実際には、OpenType には TrueType グリフフォーマットの物も含まれますが、OpenType の定義書ではそのようなフォントは現在でも TrueType フォントと呼ぶ (訳註: 拡張子 .otf ではなく .ttf を使う) べきであるとしていますので、この点については無視することにします)。
    <P>
<!--The PostScript used in OpenType is slightly different from that used in .pfa
    and .pfb files. pfa/b files are Type1 fonts while OpenType uses Type2 fonts.
    Type2 is almost a superset of Type1 with a few minor changes and many extensions.
    Adobe's subroutine based extensions to Type1 (flex hints, hint substitution,
    counter hints) have been added to Type2 as direct instructions. -->
    OpenType で使われている PostScript のグリフフォーマットは、.pfa および .pfb ファイルで使用されている物とはわずかな違いがあります。pfa/b ファイルで使用されているのは Type1 フォントであり、OpenType では Type2 フォントを使用します。Type2 は Type1 のほとんど完全なスーパーセットで、わずかな変更点と多数の拡張を Type1 に加えたものです。Adobe による、Type1 へのサブルーチンをベースとした拡張  (flex ヒント、ヒント置換、カウンタヒント) は、Type2 では直接命令として追加されています。
  <DT>
<!--<A NAME="save-no-change"><B>After I generate a font and quit, why does FontForge
    ask if I want to save the font? I didn't change anything.</B></A> -->
    <A NAME="save-no-change"><B>フォントを生成した後に終了しようとすると、フォントを保存するかどうか FontForge が訊いてくるのはなぜか? 私は何も変更していないのに。</B></A>
  <DD>
<!--There are two reasons why this might be happening.-->
    なぜこういう事が起こることがあるのかには、2 つの理由があります。
    <OL>
      <LI>
<!--	Even though you haven't changed anything in this session, FontForge may need
	to (re)generate hinting information on one or several glyphs (if, for example
	those glyphs have been changed (in an earlier session) but no hints have
	been generated for them since). These new hints will mark the font as changed. -->
	このセッションでは何もいじっていないにしても、FontForge は 1 個または数個のグリフのヒント情報を(再)生成する必要があることがあります (例えば、それらのグリフが (以前のセッションで) 変更されたが、その時以来ヒントが生成されていない場合に)。これらのヒント更新により、フォントに変更ありの印がつけられます。
      <LI>
<!--	If your font has an XUID field in the Font Info, then FontForge will increment
	the final number in the XUID each time a postscript font is generated --
	and this also counts as a change. (Why does FontForge do this? Because Adobe
	says it should. A minor annoyance, but it avoids some problems with font
	caching when you change an old version of the font for a new one). -->
	開いたフォントの フォント情報 の XUID フィールドが定義されているときは、FontForge は PostScript フォントが出力されるごとに XUID を 1 ずつ増やします。そして、これも変更の 1 つであると勘定されます。(FontForge はなぜこれを行うのでしょう? Adobe がそうするべきだと言っているからです。少し煩わしいことではありますが、古いバージョンのフォントを新しい物に置き換えた時に、フォントキャッシュに関する問題が起こるのを避けることができます)。
    </OL>
  <DT>
<!--<B><A NAME="TeX">Why doesn't TeX work with my fonts?</A></B>-->
    <B><A NAME="TeX">自作のフォントが TeX で使えないのはなぜか?</A></B>-->
  <DD>
<!--I'm a total novice with TeX. I am told that TeX (or some part of the TeX
    chain, dvips perhaps) expects fonts to be encoded in TeX base Encoding --
    sometimes called "Adobe Standard" by the TeX docs, but it isn't it's TeX
    base. So if you are having printing problems, missing glyphs, etc. try changing
    the encoding of your font to TeX Base (Go to Element-&gt;Font Info, select
    the Encoding tab, select TeX Base from the pulldown list). -->
    私は TeX に関しては完全に初心者です。私が聞いたところでは、TeX (または TeX 処理の連鎖のどこか、おそらく dvips) は、フォントは TeX Base エンコーディングで符号化されていると仮定しています―― TeX の文書では "Adobe Standard" と呼んでいるものもたまにありますが、それは TeX Base とは異なります。ですから、印刷時に出ない文字があるなどの問題があるのでしたら、フォントのエンコーディングを TeX Base に変更してみてください (エレメント(L)→フォント情報(F) を呼び出し、エンコーディング タブを選択し、TeX Base をプルダウンリストから選択してください)。
  <DT>
<!--<A NAME="mf-files"><B>Why doesn't FontForge let me edit an '.mf'
    file?</B></A> -->
    <A NAME="mf-files"><B>FontForge で '.mf' ファイルを編集できないのはなぜか?</B></A>
  <DD>
<!--As Knuth said "(the problem with WSYWYG is that...) What you see is
    <I>all</I> you get." FontForge suffers from this. -->
    Knuth が言ったように (訳註: Brian Kernighan だとする人もいる)、「(WYSIWYG の問題点は)、見えている物が手に入る<I>すべて</I>だということです。FontForge はこの制約に苦しめられています。
    <P>
<!--Let us take a simple example. Suppose we have a point defined by<BR> -->
    単純な例を示すことにしましょう。ある点が以下の数式で指定されているとします:<BR>
    <CODE>&nbsp; &nbsp; &nbsp;top<SUB>1</SUB>y<SUB>2</SUB> = CapHeight</CODE><BR>
<!--And the user tries to drag point 2 to a new y location. How should FontForge
    interpret this? It could: -->
    それで、ユーザが点 2 を垂直方向に移動して、y 座標を新しい値に変更したとします。FontForge はこれをどう解釈するべきでしょうか? 以下の可能性が考えられます:
    <UL>
      <LI>
<!--	Change <CODE>CapHeight</CODE> -->
	<CODE>CapHeight</CODE> を変更する
      <LI>
<!--	Change the width of pen 1 -->
	ペン 1 の太さを変更する
      <LI>
<!--	Change the equation to something like:<BR> -->
	数式を例えば以下のような式に変更する:<BR>
	<CODE>&nbsp; &nbsp;top<SUB>1</SUB>y<SUB>2</SUB> = CapHeight - 30</CODE>
      <LI>
<!--	Or to something like:<BR> -->
	または以下のような何らかの操作を行う:<BR>
	<CODE>&nbsp; &nbsp;top<SUB>1</SUB>y<SUB>2</SUB> = (CapHeight +
	XHeight)/2</CODE>
      <LI>
<!--	Or to half a dozen other things. -->
	またはこれ以外の考えられる数通りの処理のどれかを行う。
    </UL>
    <P>
<!--So FontForge's method for moving a point around is ambiguous. And I haven't
    been able to come up with any reasonable way for disambiguating it. Suggestions
    are welcome (but there's no guarantee they'll be implemented). -->
    FontForge で点を移動する方法はこれほどまでに意味づけが曖昧なのです。そのうえ、曖昧さを取り除くための納得のいく方法は何も見つかっていません。提案があれば歓迎します (ただし、それらの方法を私が実装する保証はまったくありません)。
  <DT>
<!--<A NAME="minify-iconify"><B>Why does my window get iconified when I want
    to minify the view?</B></A> -->
    <A NAME="minify-iconify"><B>ビューを縮小しようとすると、ウィンドウがアイコン化されてしまうのはなぜか?</B></A>
  <DD>
<!--Some window managers (gnome-sawtooth for one) steal meta (alt) clicks from
    FontForge. So you can't use meta-middle-click to minify a glyph, you have
    to use the View menu-&gt;Zoom Out instead. -->
    いくつかのウィンドウマネージャ (gnome-sawtooth はその 1 つです) は、Meta (Alt) キーつきのクリックを FontForge から奪ってしまいます。そのため、グリフを縮小するのに Meta-中クリック を使うことはできず、メニューコマンド 表示(V)→縮小(O) を使用しなければなりません。
  <DT>
<!--<A NAME="no-mu"><B>Why isn't there a character named "mu" in my greek
    font?</B></A> -->
    <A NAME="no-mu"><B>作成したギリシャ語フォントに "mu" という名前の文字が見当たらないのはなぜか?</B></A>
  <DD>
<!--Adobe was thinking more of backwards compatibility than sense when they assigned
    the names of the greek letters in their unicode encoding. Thus the name "mu"
    refers to the Micro Sign (U+00B5) and not to the letter mu. They also assigned
    Delta to Increment, and Omega to Ohm Sign. -->
    Adobe は、Unicode エンコーディングでギリシャ文字に名前をつけるときに、意味よりも後方互換性の方が重要であると考えました。それが原因で、"mu" はマイクロ記号 (U+00B5) を参照していて、ギリシャ文字ミュー小文字ではないのです。他にも、彼らは "Delta" を増分記号に、"Omega" をオーム記号に割り当てています。
    <P>
    <P>
<!--Adobe has also decided that the character at U+03D6 (said by the Unicode
    consortium to refer to "GREEK PI SYMBOL") should be named "omega1", when
    "pi1" seems more appropriate. -->
    また、Adobe はかつて U+03D6 (Unicode コンソーシアムにより、"GREEK PI SYMBOL" を指すと言明されています) を "omega1" と呼ぶことに決めています (これは "pi1" のほうがずっと適切だと思うのですが)。
  <DT>
<!--<A NAME="no-copy-names"><B>Why doesn't Edit-&gt;Copy copy glyph names as
    well as glyph info?</B></A> -->
    <A NAME="no-copy-names"><B>編集(E)→コピー(C) で、グリフ情報と一緒にグリフ名がコピーされないのはなぜか?</B></A>
  <DD>
<!--Firstly because I believe that any attempt to copy a glyph's name will almost
    certainly be better done by defining a custom
    <A TARGET="_top" HREF="fontinfo.html#Encoding">encoding</A>.<BR> -->
    最初の理由として、グリフ名をコピーしようとする人がやりたい事は、カスタム<A TARGET="_top" HREF="fontinfo.html#Encoding">エンコーディング</A>を定義したほうがうまくできることがほぼ確実だからです。<BR>
<!--Secondly because most of the time you don't want the name copied.<BR>
    Thirdly because it is esthetically better that copy should only work with
    data and not meta-data.<BR> -->
    2 番目の理由は、誰でもほとんどの場合は名前をコピーしたくないだろうからです。<BR>
    3 番目の理由は、コピーはデータのみに作用し、メタデータには作用しない方が美的に優れているからです。<BR>
<!--HOWEVER... enough people have asked this question that I've enabled a mode
    in <A TARGET="_top" HREF="editmenu.html#CharName">Edit-&gt;Copy From-&gt;Char
    Name</A> which allows you to change the default behavior. -->
    し か し な が ら……この質問をする人が多いので、私はそれに負けて<A TARGET="_top" HREF="editmenu.html#CharName">編集(E)→コピー元の指定(C)→グリフのメタデータ(M)</a> でデフォルトの振舞を変更できるようなモードを作成しました。
  <DT>
<!--<A NAME="copy-names"><B>Why does Edit-&gt;Paste complain about name
    duplication?</B></A> -->
    <A NAME="copy-names"><B>編集(E)→貼り付け(P) を行うと、名前が重複していると怒られるのはなぜか?</B></A>
  <DD>
<!--Because you have Edit-&gt;Copy From-&gt;Copy Metadata checked. Uncheck it. -->
    編集(E)→コピー元の指定(C)→グリフのメタデータ(M) にチェックが入っているとそうなります。チェックを外してください。
  <DT>
<!--<A NAME="cidmaps"><B>What on earth are cidmap files and should I care about
    them?</B></A>-->
    <A NAME="cidmaps"><B>cidmap ファイルって一体全体何のこと、知らないと何かまずいことがある?</B></A>
  <DD>
<!--Some background:-->
    いくつかの背景的事情を説明します:
    <P>
<!--When postscript was invented every glyph in a font was given a name, and
    an encoding which was specified by a 256 element array mapping character
    codes to names. -->
    PostScript が考案された時は、フォント内の全てのグリフに名前がついていて、256 要素の配列によって指定されるエンコーディングが、文字コードから名前への対応づけを行っていました。
    <P>
<!--Then they started thinking about CJK fonts (and perhaps Unicode), which have
    huge glyph sets, and coming up with reasonable ASCII names for 10,000 glyphs
    was <SMALL>a)</SMALL> a waste of space, <SMALL>b)</SMALL> fairly meaningless.
    So then adobe created CID-keyed fonts which have no glyph names and no encodings.
    Every glyph has an index (a CID), which is just a number, and this is sort
    of treated as a name. Then external to the font is an additional resource
    (a cmap) which provides the encoding for the font (and can support really
    grungy encoding schemes like SJIS), by mapping a sequence of input bytes
    to a CID. -->
    その後で、巨大なグリフセットをもつ CJK フォント (それとおそらく Unicode) について彼らが考え始め、10,000 個のグリフに納得のいく名前を ASCII でつけるのは <SMALL>a)</SMALL> スペースの無駄使いで、<SMALL>b)</SMALL> まったく意味が無い、という結論に達しました。そういうわけで、その時 Adobe は、グリフ名もエンコーディングも含まれていない CID キー指定フォントを発明しました。
    <P>
<!--Adobe provides certain standard cmap resources (ie. one for SJIS, one for
    JIS, one for Extended Unix whatever). Because these files are fairly painful
    to write Adobe has assigned standard meanings to CIDs so that everyone can
    use the same cmap file. -- Well actually there are 5 or 6 different standards,
    Japanese (JIS208), Japanese (JIS212), Korean, Chinese (Hong Kong, Taiwan),
    Chinese (Mainland, Singapore), Identity (Unicode) -- So CID 1 might be space,
    CID 2 might be "!", CID 935 might be "Katakana ka", etc.-->
    Adobe は、いくつかの標準 CMap リソースを提供しています (例えば、SJIS 用のもの、 JIS 用のもの、各国語の EUC 用のものなど)。これらのファイルを書くのはとても面倒な作業なので、Adobe は各 CID に標準の意味を与え、誰もが同じ CMap ファイルを使えるようにしました。――えー実際には 5, 6 種類の異なる標準がありまして、日本語 (JIS X 0208), 日本語 (JIS X 0212), 韓国語、中国語 (香港・台湾)、中国語 (本土・シンガポール)、Identity (Unicode) などです――それで CID 1 は空白、 CID 2 は "!", CID 985 は「カ」のように決まっています。
    <P>
<!--My cidmap files just give me a mapping between Adobe's CIDs and Unicode.
    This allows FontForge to know what glyph it is working on. If they aren't
    present things should work ok, but FontForge would fill the font view with
    "?" rather than the appropriate glyph. And FontForge wouldn't be able to
    reencode the font into Unicode or anything else. -->
    私の作った cidmap ファイルは、Adobe の CID と Unicode の対応関係を示すだけのものです。これにより、どういうグリフに大して作業を行っているかを FontForge が知ることができます。これが無くても動作に問題はありませんが、FontForge はフォントビューに適切なグリフではなく "?" を表示するでしょう。また、FontForge はフォントを Unicode やその他の方式に符号化しなおすことはできないでしょう。
    <P>
    <P>
<!--So the cidmap files are only useful for people working on CID keyed CJK fonts.
    So many europeans/americans won't need them. -->
    要するに、cidmap ファイルが役に立つのは、CJK の CID フォントの作業を行う人だけです。
  <DT>
<!--<B>Does the <A NAME="simplify">simplify</A> command lose accuracy?</B>-->
    <B><A NAME="simplify">単純化(S)</A> コマンドを使うと文字の正確度が落ちるのか?</B>
  <DD>
<!--Yes it does.<BR>
    But not much.<BR>
    It is designed to replace a set of splines with another spline that nowhere
    differs from the original by more than one unit in the local coordinate
    system.<BR> 
    If this level of accuracy is not good enough then (In the outline view): -->
    はい、落ちます。<BR>
    でもさほど落ちません。<BR>
    このコマンドは、連続した複数スプラインを、オリジナルからローカル座標系で 1 ユニット以内のずれの範囲内で近似する 1 本のスプラインで置き換えます。<BR>
    もしこのレベルの精度では不十分な場合、(アウトラインビューで)
    <UL>
      <LI>
<!--	Edit-&gt;Select All -->
	編集(E)→すべて選択(A)
      <LI>
<!--	Element-&gt;Transform -->
	エレメント(L)→変形(T)
      <LI>
<!--	Scale Uniformly: 1000% -->
	一様に拡大・縮小: 1000%
      <LI>
	OK
      <LI>
<!--	Simplify -->
	単純化
      <LI>
<!--	Element-&gt;Transform -->
	エレメント(L)→変形(T)
      <LI>
<!--	Scale Uniformly: 10% -->
	一様に拡大・縮小: 10%
      <LI>
	OK
    </UL>
    <P>
<!--This will replace a set of splines with a spline that differs from the original
    by no more than .1 unit. -->
    という手順で操作を行うと、連続したスプラインは、オリジナルから 0.1 ユニット以上ずれることのないスプラインで置き換えられます。
  <DT>
<!--<A NAME="cubic-quadratic"><B>How does FontForge convert a cubic spline into
    a quadratic spline for truetype?</B></A> -->
    <A NAME="cubic-quadratic"><B>FontForge では、どうやって 3 次スプラインを TrueType で用いられる 2 次スプラインに変換しているのか?</B></A>
  <DD>
<!--Again this can involve a loss of accuracy.<BR> -->
    この場合も、正確度の低下が伴います。<BR>
<!--First FontForge checks to see if the spline happens to be a quadratic already
    (this would happen if you'd just read in a truetype font, or if a miracle
    occurred when you generated the spline).<BR> -->
    最初に、FontForge はスプラインがちょうど 2 次曲線で表せるかどうかチェックします (これは、スプラインが TrueType から読み込んだそのままである場合か、またはスプラインを出力するときに奇跡的な偶然によって起こります)。<BR>
<!--Otherwise FontForge will divide the original spline into smaller chunks and
    try to find a set of quadratic splines that differ from the cubic by no more
    than one unit anywhere. (Once you have picked two end-points and know the
    slope at those end-points there is only one quadratic spline possible between
    the two). -->
    2 次曲線で表せない場合は、FontForge はオリジナルの曲線を小さな塊に分割し、元の 3 次スプラインからどこも 1 ユニット以内の違いしかない 2 次スプラインの列を見つけようとします。(2 個の端点を選択して、それらの端点における傾きが判明していれば、それらの端点の間に可能な 2 次スプラインは 1 個しかありません)。
  <DT>
<!--<A NAME="quadratic-cubic"><B>How does FontForge convert a quadratic spline
    into a cubic (when reading truetype)?</B></A> -->
    <A NAME="quadratic-cubic"><B>FontForge は (TrueType を読み込む際に) どのようにして 2 次スプラインを 3 次に変換しているのか?</B></A>
  <DD>
<!--This is easy since any quadratic spline can already be represented as a cubic,
    it will just happen that the cubic term is always 0. -->
    任意の 2 次スプラインは、3 次の項が常に 0 になっているだけと考えれば、既に 3 次式で表されているものとして扱うことができるので簡単です。
  <DT>
<!--<A NAME="default-char"><B>How do I set the default glyph of a font?</B></A> -->
    <A NAME="default-char"><B>フォントのデフォルトグリフを設定するにはどうすればいいか?</B></A>
  <DD>
<!--If the glyph at encoding 0 is named ".notdef" and if it contains some splines
    (but no references) then it will be used as the default glyph (that is the
    glyph used when an unencoded glyph is called for). -->
    符号位置 0 にあるグリフが ".notdef" という名前で、そこに何らかのスプラインが含まれていれば (ただし参照がない場合に限り) そのグリフはデフォルトグリフとして扱われます (".notdef" というのは、符号化されていないグリフのために用いられる名前です)。
  <DT>
<!--<A NAME="ttf-degrade"><B>I loaded a ttf font, made a few changes and generated
    a new font. The changed glyphs don't look anywhere near as nice as the originals.
    Why?</B></A> -->
    <A NAME="ttf-degrade"><B>TTF フォントを読み込んで、2,3 箇所修正してから新しいフォントを出力した。変更したグリフはどこから見てもオリジナルと比べて見劣りする。なぜか?</B></A>
  <DD>
<!--Unfortunately FontForge does not hint truetype fonts at all well. And when
    FontForge reads in a truetype font it saves all the hinting (instructions)
    that were present in the original. But if you change a glyph in any significant
    way those instructions are no longer valid (they depend intimately on the
    details of the outlines), so FontForge removes them when you make a change.
    The result is that changing a glyph with FontForge will degrade its appearance
    in most truetype fonts (not all, some have no hints).<BR> -->
    残念ながら FontForge は TrueType フォントにヒントづけを行うのがまったく上手ではありません。ですから、FontForge が TrueType フォントを読み込んだ時には、オリジナルのフォントに含まれていた全てのヒント情報 (命令) を保持します。しかし、あるグリフに変更を行ってしまうとそれらの命令はもはや正しくありません (それらはアウトラインの細部に密接に依存しています) ので、変更を行った時点で FontForge はそれらを削除します。その結果、ほとんどの TrueType フォントでは、グリフを FontForge で変更するとその見栄えが悪化することになります (全てではありません。ヒントの無いものもいくつかあります)。
<!--FontForge can hint vertical and horizontal stems, but not diagonals. In many
    glyphs FontForge's attempt at hinting makes things worse (because the diagonals
    don't match the horizontals/verticals). So if you want this to happen you
    must explicitly call the Hints-&gt;AutoInstr command. -->
    FontForge は垂直・水平方向のステムにはヒントをつけることができますが、斜めのステムにはヒントづけできません。FontForge のヒントづけの試みによって、 (斜めのステムが水平・垂直と整合しなくなって) グリフの品質がかえって悪くなることも珍しくありません。そういうわけで、ヒントづけをしてほしい場合には、ヒント(H)→ヒント命令の自動生成(I) をあからさまに呼び出さなければなりません。
<!--<A NAME="otf-diffs"><B>I generated an opentype font and windows wouldn't
    install it. Why not?</B></A> -->
    <A NAME="otf-diffs"><B>OpenType フォントを生成したが、Windows にはインストールできない。なぜできないのか?</B></A>
  <DD>
<!--Unfortunately Apple and MicroSoft (and Adobe) do not agree on the proper
    format for open and truetype fonts. FontForge has a check box on the Generate
    Font dialog labelled [] Apple. Make sure this is checked when you are generating
    a font for the mac. Make sure this is not checked when generating a font
    for Windows (and probably for unix too, though unix tends to be less picky).-->
    残念なことに、Apple と Microsoft (および Adobe) の間では、OpenType および TrueType の正しいフォントフォーマットについて合意がとれていないのです。FontForge は、フォント出力ダイアログに <CODE>[] Appleの仕様</CODE> と書かれたダイアログを用意しています。Mac 用のフォントを出力するときには、忘れずにこれにチェックを入れてください。Windows 用の (おそらく Unix も同じです。通例 Unix はさほど気難しくありませんが) フォントを出力するときには、チェックを外すことを忘れないでください。
    <P>
<!--The major differences I've stumbled onto so far are:-->
    私が今までにつまづいた大きな違いをすべて以下に挙げます:
    <UL>
      <LI>
<!--	The postscript name entry in the NAME table. -->
	name テーブル内の PostScript 名に関する部分
      <LI>
<!--	The names of the tables containing bitmap fonts -->
	ビットマップフォントを含むテーブルの名前
      <LI>
<!--	The way scaled references are stored -->
	拡大・縮小された参照が格納される方法
      <LI>
<!--	And the tables containing advanced typographical features are completely
	different -->
	そして、高度な組版機能を含むテーブルは完全に異なっています。
    </UL>
  <DT>
<!--<A NAME="mingliu"><B>I looked at kaiu.ttf or mingliu.ttf and the outlines
    looked nothing like the correct glyphs. What's wrong?</B></A> -->
    <A NAME="mingliu"><B>kaiu.ttf や mingliu.ttf を開いてみると、アウトラインは正しいグリフと全然違って見える。何がまずいのか?</B></A>
  <DD>
<!--Some truetype fonts (kaiu and mingliu) do not store the correct outline.
    Instead they rely on using the instructions to move points around to generate
    the outline. The outline does not appear to be grid-fit at all, just positioned.
    FontForge will not process the instructions as it reads the font. In most
    fonts this would be the wrong thing to do, and I don't know how I could tell
    when it needs to be done... -->
    ある種の TrueType フォント (kaiu と mingliu) は、正しいアウトラインを格納していません。その代わり、それらはアウトラインを生成するのに、点の位置を移動する命令に依存しています。アウトラインは全くグリッド合わせは行われず、ただ位置指定がされるだけです。FontForge はフォントを読み込んだときに命令を処理しません。ほとんどのフォントではこれは行うべきではないでしょうし、それを行うべき時を判別するにはどうすればいいか分からないからです……。
  <DT>
<!--<A NAME="greek-accents"><B>When I use Element-&gt;Build Accented Glyph to
    build one of the Extended Greek glyphs (U+1F00-U+1FFF) FontForge picks the
    wrong accents. Why?</B></A> -->
    <A NAME="greek-accents"><B>ギリシャ文字拡張 (U+1F00〜U+1FFF) のグリフを作るために エレメント(L)→アクセントつきグリフを構築(B) を使用すると、FontForge は間違ったグリフを選ぶのはなぜか?</B></A>
  <DD>
<!--For some reason Unicode has unified greek and latin accents even though they
    don't look at all alike. When FontForge follows the simplistic unicode
    definitions it will probably pick a latin accent for greek glyphs. Fortunately
    Unicode also contains code points for the greek accents starting around U+1FBD,
    if you fill these code points with the appropriate accents then FontForge
    will use these rather than the latin accents. -->
    いくつかの理由により、Unicode はギリシャ文字とラテン文字のアクセントを、それらが全然違って見えるときでも統合してしまっています。FontForge が単純な Unicode の定義にしたがった時には、ギリシャ文字のグリフに対してラテン文字用のアクセントを組み合わせてしまうでしょう。好運なことに、Unicode はギリシャ文字のアクセントに適切なコードポイントも、U+1FBD から始まる位置に用意しているので、それらのコードポイントに正しい形のアクセントを作れば、FontForge はラテン文字のアクセントよりそちらを優先して使用します。
  <DT>
<!--<A NAME="u-accents"><B>When I use Element-&gt;Build Accented Glyph to build
    accents over "u" or "y" I get the accent over one of the stems not centered
    on the glyph. Why?</B></A> -->
    <A NAME="u-accents"><B>"u" や "y" の上にアクセントをつけるために エレメント(L)→アクセントつきグリフを構築(B) を使用すると、アクセントがどちらかのステムの真上に来てしまい、グリフの中央に来ないのはなぜか?</B></A>
  <DD>
<!--One of your stems is a little taller than the other. FontForge centers accents
    over the tallest point on the glyph. If there are several points with the
    same height, then an average is used. -->
    それらのステムの片方が、もう片方よりわずかに高いせいです。FontForge はアクセントをグリフの最も高い点の上に配置します。同じ高さの点が複数あるときは、それらの平均が用いられます。
    <P>
<!--If you make all your stems be the same height then the accent should be properly
    centered. -->
    全てのステムの高さを同じに揃えれば、アクセントは正しく中央に配置されるでしょう。
  <DT>
<!--<A NAME="ttf2afm"><B>Why does ttf2afm crash on FontForge ttf files?</B></A> -->
    <A NAME="ttf2afm"><B>FontForge が出力した TTF ファイルを処理すると ttf2afm がクラッシュするのはなぜか?</B></A>
  <DD>
<!--I don't know. The ttf2afm that was distributed with my redhat 7.3 linux certainly
    did crash. When I downloaded the source from
    <A TARGET="_top" HREF="http://www.ctan.org/tex-archive/obsolete/systems/pdftex/">pdftex</A>
    area of ctan and built it (with debug) the resultant program did not crash.
    Therefore I believe this is a bug in ttf2afm and that bug has been fixed.<BR>
    The afm files produced by ttf2afm don't conform to
    <A TARGET="_top" HREF="http://partners.adobe.com/asn/developer/PDFS/TN/5004.AFM_Spec.pdf">Adobe's
    specifications</A>. -->
    私は知りません。RedHat 7.3 Linux に入っている ttf2afm はおそらく確実にクラッシュするでしょう。ソースを CTAN の <A TARGET="_top" HREF="http://www.ctan.org/tex-archive/obsolete/systems/pdftex/">pdftex</A> の置き場所からダウンロードして (デバッグ機能つきで) ビルドしたら、できたプログラムはクラッシュしませんでした。<BR>
    だから、これは ttf2afm のバグで、既に修正されているに違いないと思います。<BR>
    ttf2afm によって出力された AFM ファイルは、<A TARGET="_top" HREF="http://partners.adobe.com/asn/developer/PDFS/TN/5004.AFM_Spec.pdf">Adobe の仕様</A>に適合していません。
  <DT>
<!--<A NAME="Unstable"><B>Why is FontForge so unstable?</B></A>-->
    <A NAME="Unstable"><B>なぜ FontForge はとても不安定なのか?</B></A>
  <DD>
<!--I don't bother much with doing QA. This is a problem. I don't enjoy doing
    it, and no one is paying me to do it, so little gets done.<BR>
    If you would like to volunteer to do
    <A HREF="mailto:fontforge-devel@lists.sourceforge.net">QA let me know</A>.
    It's a thankless job, but important! -->
    私は品質保証にあまり手間をかけていないのです。これは問題ありです。私はそれが楽しくないし、それをするように私に給料を払う人は誰もいないので、ほとんど行われていないわけです。<BR>
    あなたが品質保証の作業を志願するならば、<A HREF="mailto:fontforge-devel@lists.sourceforge.net">私にお知らせください</A>。感謝されない仕事ですが、とても大事です!
</DL>
<P>
<P ALIGN=Center>
-- <A HREF="http://fontforge.sourceforge.net/sfds/index.html">前</A> --
<A HREF="overview.html" TARGET="_top">目次</A> --
<A HREF="GlossaryFS.html" TARGET="_top">次</A> --
</BODY></HTML>
