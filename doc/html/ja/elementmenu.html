<HTML>
<HEAD>
  <!-- Created with AOLpress/2.0 -->
  <!-- AP: Created on: 11-Dec-2000 -->
  <!-- AP: Last modified: 26-Jul-2006 -->
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<!--<TITLE>The Element Menu</TITLE>-->
    <TITLE>エレメントメニュー</TITLE>
  <LINK REL="icon" href="../fftype16.png">
  <LINK REL="stylesheet" TYPE="text/css" HREF="FontForge.css">
</HEAD>
<BODY>
<DIV id="in">
  <H1 ALIGN=Center>
<!--The Element Menu-->
    エレメントメニュー
  </H1>
  <P>
  <UL>
    <LI>
<!--  <A HREF="#Font">Font Info</A>-->...
      <A HREF="#Font">フォント情報(<U>F</U>)</A>...
    <LI>
<!--  <A HREF="#CharInfo">Glyph Info</A>-->...
      <A HREF="#CharInfo">グリフ情報(<U>I</U>)</A>...
    <LI>
<!--  <A HREF="elementmenu.html#BDF-Info">BDF Info...</A>-->
      <A HREF="elementmenu.html#BDF-Info">BDF 情報...</A>
    <LI>
<!--  <A HREF="#Info">Get Info</A>...-->
      <A HREF="#Info">情報を得る(<U>I</U>)...</A>
    <LI>
<!--  Typographic Features-->
      組版機能(Y)
      <UL>
	<LI>
<!--	  <A HREF="#Copy-Feat">Copy Feature(s) to Font</A>... -->
	  <A HREF="#Copy-Feat">機能をフォントにコピー(<U>C</U>)</A>...
	<LI>
<!--	  <A HREF="#DefaultATT">Default ATT</A> (Advanced Typographic Tables) -->
	  <A HREF="#DefaultATT">デフォルトのATT(<U>D</U>)</A> (Advanced Typographic Tables)
	<LI>
<!--	  <A HREF="#Rm-All-Feat">Remove All Features</A> -->
	  <A HREF="#Rm-All-Feat">すべての機能を削除(<U>R</U>)</A>
	<LI>
<!--	  <A HREF="#Rm-Feat">Remove Feature(<U>s</U>)...</A> -->
	  <A HREF="#Rm-Feat">機能を削除(<U>E</U>)...</A>
	<LI>
<!--	  <A HREF="#Rm-Unused-Feat">Remove Unused Nested Features</A> -->
	  <A HREF="#Rm-Unused-Feat">未使用の入れ子になった機能を削除(<U>N</U>)</A>
	<LI>
<!--	  <A HREF="#Retag-Feat">Retag Feature(<U>s</U>)...</A> -->
	  <A HREF="#Retag-Feat">機能タグをつけ直す(<U>T</U>)...</A>
      </UL>
    <LI>
<!--  Show Dependencies-->
      依存するグリフを表示
      <UL>
	<LI>
<!--	  <A HREF="elementmenu.html#Dependencies">References</A> -->
	  <A HREF="elementmenu.html#Dependencies">参照一覧(<U>R</U>)...</A>
	<LI>
<!--	  <A HREF="#DepSubs">Substitutions</A> -->
	  <A HREF="#DepSubs">置換一覧(<U>S</U>)...</A>
      </UL>
    <LI>
<!--  <A HREF="#Problems">Find Problems...</A> -->
      <A HREF="#Problems">問題点を発見(<U>O</U>)...</A>
    <LI>
<!--  <A HREF="#Bitmaps">Bitmaps Available...</A> -->
      <A HREF="#Bitmaps">使用するビットマップ(<U>A</U>)...</A>
    <LI>
<!--  <A HREF="#Regenerate">Regenerate Bitmaps...</A> -->
      <A HREF="#Regenerate">ビットマップの再生成(<U>B</U>)...</A>
    <LI>
<!--  Transformations-->
      変形(<U>T</U>)
      <UL>
	<LI>
<!--	  <A HREF="#Transform">Transform</A>... -->
	  <A HREF="#Transform">変形(<U>T</U>)</A>...
	<LI>
<!--	  <A HREF="#PoV">Point of View Projection</A>... -->
	  <A HREF="#PoV">透視変換(<U>P</U>)</A>...
	<LI>
<!--	  <A HREF="elementmenu.html#Non-Linear">Non-Linear Transform</A>...<BR> -->
	  <A HREF="elementmenu.html#Non-Linear">非線形の変形(<U>N</U>)</A>...<BR>
	<LI>
<!--	  <A HREF="#Flip">Flip Horizontally</A> -->
	  <A HREF="#Flip">水平方向に反転(<U>H</U>)</A>
	<LI>
<!--	  <A HREF="#FlipV">Flip Vertically</A> -->
	  <A HREF="#FlipV">垂直方向に反転(<U>V</U>)</A>
	<LI>
<!--	  <A HREF="#Rotate">Rotate 90&#176; CW</A> -->
	  <A HREF="#Rotate">時計回りに90°回転(<U>R</U>)</A>
	<LI>
<!--	  <A HREF="#Rotate90CCW">Rotate 90&#176; CCW</A> -->
	  <A HREF="#Rotate90CCW">反時計回りに90°回転</A>
	<LI>
<!--	  <A HREF="#Rotate180">Rotate 180&#176;</A> -->
	  <A HREF="#Rotate180">180°回転</A>
	<LI>
<!--	  <A HREF="#Skew">Skew</A> -->
	  <A HREF="#Skew">傾き(<U>S</U>)...</A>
      </UL>
    <LI>
<!--  <A HREF="#Expand">Expand Stroke...</A> -->
      <A HREF="#Expand">輪郭を太らせる(<U>E</U>)...</A>
    <LI>
<!--  Overlap-->
      重複処理(<U>V</U>)
      <UL>
	<LI>
<!--	  <A HREF="#Remove">Remove Overlap</A> -->
	  <A HREF="#Remove">重なり合う図形を結合(<U>R</U>)</A>
	<LI>
<!--	  <A HREF="#Intersect">Intersect</A> -->
	  <A HREF="#Intersect">重複部分を抽出(<U>I</U>)</A>
	<LI>
<!--	  <A HREF="#Exclude">Exclude</A> -->
	  <A HREF="#Exclude">重複部分を除去(<U>E</U>)</A>
	<LI>
<!--	  <A HREF="#FindInter">Find Intersections</A> -->
	  <A HREF="#FindInter">交点を見つける(<U>F</U>)</A>
      </UL>
    <LI>
<!--  Simplify-->
      単純化(<U>S</U>)
      <UL>
	<LI>
<!--	  <A HREF="#Simplify">Simplify</A> -->
	  <A HREF="#Simplify">単純化(<U>S</U>)</A>
	<LI>
<!--	  <A HREF="elementmenu.html#SimplifyMore">Simplify More</A> -->
	  <A HREF="elementmenu.html#SimplifyMore">さらに単純化</A>
	<LI>
<!--	  <A HREF="#Cleanup">Cleanup Glyphs</A> -->
	  <A HREF="#Cleanup">不要な曲線を除去(<U>N</U>)</A>
	<LI>
<!--	  <A HREF="#CanonicalSP">Canonical Start Points</A> -->
	  <A HREF="#CanonicalSP">開始点を正規化(<U>P</U>)</A>
	<LI>
<!--	  <A HREF="#CanonicalContours">Canonical Contour Order</A> -->
	  <A HREF="#CanonicalContours">輪郭の順序を正規化(<U>C</U>)</A>
      </UL>
    <LI>
<!--  <A HREF="elementmenu.html#Add-Extrema">Add Extrema</A>-->
      <A HREF="elementmenu.html#Add-Extrema">極大点の追加(<U>X</U>)</A>
    <LI>
<!--  Effects -->
      効果
      <UL>
	<LI>
<!--	  <A HREF="#Outline">Outline</A> -->
	  <A HREF="#Outline">アウトライン(<U>O</U>)</A>
	<LI>
<!--	  <A HREF="#Inline">Inline</A> -->
	  <A HREF="#Inline">インライン(<U>I</U>)</A>
	<LI>
<!--	  <A HREF="#Shadow">Shadow</A> -->
	  <A HREF="#Shadow">影つき(<U>S</U>)</A>
	<LI>
<!--	  <A HREF="#Wireframe">Wireframe</A> -->
	  <A HREF="#Wireframe">縁どり立体化(<U>W</U>)</A>
      </UL>
    <LI>
<!--  <A HREF="#MetaFont">MetaFont...</A>-->
      <A HREF="#MetaFont"><U>M</U>eta Font...</A>
    <LI>
      <A HREF="#AutoTrace">自動トレース(<U>R</U>)</A>
    <LI>
<!--  <A HREF="#Align">Align</A>-->
      <A HREF="#Align">点を揃える(<U>L</U>)</A>
      <UL>
	<LI>
<!--	  <A HREF="elementmenu.html#Average">Average Points</A> -->
	  <A HREF="elementmenu.html#Average">座標の平均値(<U>A</U>)</A>
	<LI>
<!--	  <A HREF="elementmenu.html#Space-Pts">Space Points</A> -->
	  <A HREF="elementmenu.html#Space-Pts">点の間隔を均等に(<U>S</U>)</A>
	<LI>
<!--	  <A HREF="elementmenu.html#Space-Regions">Space Regions</A> -->
	  <A HREF="elementmenu.html#Space-Regions">グループ間を均等に(<U>R</U>)...</A>
	<LI>
<!--	  <A HREF="#Parallel">Make Parallel</A> -->
	  <A HREF="#Parallel">平行に(<U>P</U>)...</A>
      </UL>
    <LI>
<!--      Round -->
	  座標を丸める(<U>D</U>)
      <UL>
	<LI>
<!--	  <A HREF="#Round">To Int</A> -->
	  <A HREF="#Round">整数値に(<U>I</U>)</A>
	<LI>
<!--	  <A HREF="#Hundredths">To Hundredths</A> -->
	  <A HREF="#Hundredths">1/100単位(<U>H</U>)</A>
	<LI>
<!--	  <A HREF="#Cluster">Cluster</A> -->
	  <A HREF="#Cluster">近い値をまとめる(<U>C</U>)</A>
      </UL>
    <LI>
<!--  <A HREF="#Order">Order</A>-->
      <A HREF="#Order">順序</A>
      <UL>
	<LI>
<!--	  First -->
	  最初(<U>F</U>)
	<LI>
<!--	  Earlier -->
	  前に(<U>E</U>)
	<LI>
<!--	  Later -->
	  後に(<U>A</U>)
	<LI>
<!--	  Last -->
	  最後(<U>L</U>)
      </UL>
    <LI>
<!--  <A HREF="#Clockwise">Clockwise</A>-->
      <A HREF="#Clockwise">時計回り(<U>O</U>)</A>
    <LI>
<!--  <A HREF="#Counter">Counter-Clockwise</A>-->
      <A HREF="#Counter">反時計回り(<U>N</U>)</A>
    <LI>
<!--  <A HREF="#Correct">Correct Direction</A>-->
      <A HREF="#Correct">アウトラインの向きを修正(<U>C</U>)</A>
    <LI>
<!--  Build-->
      組み立て(<U>U</U>)
      <UL>
	<LI>
<!--	  <A HREF="#Accented">Build Accented Glyph</A> -->
	  <A HREF="#Accented">アクセントつきグリフを構築(<U>B</U>)</A>
	<LI>
<!--	  <A HREF="#Accented">Build Composite Glyph</A> -->
	  <A HREF="#Accented">複合グリフを構築(<U>C</U>)</A>
	<LI>
<!--	  <A HREF="#BuildDuplicate">Build Duplicate</A> -->
	  <A HREF="#BuildDuplicate">複製グリフを作成(<U>D</U>)</A>
      </UL>
<!--  <A HREF="#Merge">Merge Fonts...</A>-->
      <A HREF="#Merge">フォントの統合(<U>M</U>)...</A>
    <LI>
<!--  <A HREF="#Interpolate">Interpolate Fonts...</A>-->
      <A HREF="#Interpolate">フォントの補間(<U>L</U>)...</A>
    <LI>
<!--  <A HREF="#CompareFonts">Compare Fonts...</A> -->
      <A HREF="#CompareFonts">フォントを比較...</A>
  </UL>
  <P>
<!--
  There are also two menu entries which are not part of the default build but
  which may be configured by modifying <CODE>configure-fontforge.h</CODE> before
  compiling FontForge. -->
  その他、FontForge のデフォルトのままのビルドではメニューには現れませんが、<CODE>configure-fontforge.h</CODE> を変更してからコンパイルすることによって利用可能になるメニュー項目が 2 個あります。
  <UL>
    <LI>
<!--  <A HREF="#TilePath">Tile Path</A>-->
      <A HREF="#TilePath">パスのタイル敷き(<U>P</U>)</A>
    <LI>
<!--  <A HREF="#NonLinear">Non Linear Transform...</A>-->
      <A HREF="#NonLinear">非線形の変形(<U>N</U>)...</A>
  </UL>
  <P>
  <DL>
    <DT>
<!--  <A NAME="Font">Font</A> Info-->
      <A NAME="Font">フォント</A>情報(<U>F</U>)...
    <DD>
<!--  In all views this brings up the <A HREF="fontinfo.html">Font Info
      dialog</A>.<BR>
      CID keyed fonts can set information on the CID font as a whole (rather than
      just the current sub-font, which is what this command does) from
      <A HREF="cidmenu.html#FontInfo">CID-&gt;CID Font Info</A>.-->
      どのビューから実行した場合でも、<A HREF="fontinfo.html">フォント情報ダイアログ</A>を起動します。<BR>
      CID フォントでは、CID フォント全体の情報 (<A HREF="cidmenu.html#FontInfo">CID→CIDフォント情報(<U>I</U>)</A>で設定できます)ではなく、現在のサブフォントに関する情報の設定ができます。<BR>
    <DT>
<!--  Glyph <A NAME="CharInfo">Info</A>-->
      グリフ<A NAME="CharInfo">情報(<U>I</U>)</A>...
    <DD>
<!--  In the all views this brings up the <A HREF="charinfo.html#Character">Glyph
      Info dialog</A>.-->
      どのビューから実行しても、<A HREF="charinfo.html#Character">グリフ情報</A>ダイアログを起動します。
    <DT>
<!--  <A NAME="BDF-Info">BDF</A> Info -->
      <A NAME="BDF-Info">BDF</A> 情報
    <DD>
<!--  If you have bitmaps in your font, then in the font view or bitmap view this
      command will bring up the <A HREF="bdfinfo.html">BDF Info dialog.</A> -->
      ビットマップを含むフォントを編集している場合、フォントビューまたはビットマップビューでこのコマンドを呼び出すと <A HREF="bdfinfo.html">BDF 情報ダイアログ</A> が起動します。
    <DT>
<!--  Get <A NAME="Info">Info</A>-->
      <A NAME="Info">情報を</A>得る(<U>I</U>)
    <DD>
<!--  In the outline view this brings up <A HREF="getinfo.html">one of four different
      dialogs</A> (Point Info, Image Info, Reference Info, Anchor Point Info) depending
      on what is selected.-->
      アウトラインビューでは選択した物によって異なる <A HREF="getinfo.html">4 種類の異なるダイアログ</A> (点の情報、画像情報、参照情報、アンカーポイント情報) のどれかを起動します。
    <DT>
<!--  Typographic Features-->
      組版機能(<U>Y</U>)
    <DD>
<!--  This sub-menu is only present in the font view and allows you to manipulate
      GSUB/GPOS/morx features. If you wish to create them you should use
      <A HREF="fontinfo.html">Font Info</A> or
      <A HREF="charinfo.html#Character">Glyph Info</A>.
      このサブメニューはフォントビューのみに存在し、GSUB/GPOS/morx 機能を操作することができます。それらの機能を作成したい時は、<A HREF="fontinfo.html">フォント情報(<U>F</U>)</A>または<A HREF="charinfo.html#Character">グリフ情報(<U>I</U>)</A>を使用する必要があります。
      <DL>
	<DT>
<!--	  Copy <A NAME="Copy-Feat">Feature</A> to Font... -->
	  <A NAME="Copy-Feat">機能を</A>フォントにコピー(<U>C</U>)...
	<DD>
<!--	  <A HREF="typofeat.html#Copy-Feat">This dialog</A> allows you to copy a set
	  of features from one font to another. -->
	  <A HREF="typofeat.html#Copy-Feat">このダイアログ</A>を使うと、あるフォントに含まれる機能のセットを他のフォントにコピーすることができます。
	<DT>
<!--	  Default <A NAME="DefaultATT">ATT</A>-->
	  <A NAME="DefaultATT">デフォルトの</A>ATT(<U>D</U>)
	<DD>
<!--	  In the font view this is a sub-menu which allows you to generate default
	  values for various features of the
	  <A HREF="http://partners.adobe.com/public/developer/opentype/index_table_formats2.html">GPOS</A>
	   and
	  <A HREF="http://partners.adobe.com/public/developer/opentype/index_table_formats1.html">GSUB</A>
	  tables. -->
	  フォントビューでは、<A HREF="http://partners.adobe.com/public/developer/opentype/index_table_formats2.html">GPOS</A> と	<A HREF="http://partners.adobe.com/public/developer/opentype/index_table_formats1.html">GSUB</A> テーブルの様々な機能の値を生成することができるサブメニューを起動します。
	  <P>
<!--	  The sub-menu consists of a list of feature names (and a few more generic
	  names like "All" which will provide defaults for everything it can figure
	  out, and "Ligatures" which will provide defaults for all ligatures). FontForge
	  will look for defaults for all selected glyph. There is also one special
	  entry: -->
	  このサブメニューは機能名のリスト (それに加えて、算出可能なすべての値に対するデフォルトを指定する“All”と、すべての合字に関するデフォルトを与える“Ligatures”) からなります。FontForge は選択中のすべてのグリフに対するデフォルトを探します。それに加え、特別な項目が 1 個あります:
	  <DL>
	    <DT>
<!--	      Suffix to Tag... -->
	      タグへの接尾子...
	    <DD>
<!--	      In adobe's glyph naming conventions, alternate forms of glyphs may be named
	      by appending a suffix to the normal glyph's name. Thus a swash variant of
	      "A" might be named "A.swash". -->
	      Adobe のグリフ命名の慣例では、別字形のグリフは標準グリフの名前に接尾子を追加した名前をつけることになっています。これにより、“A”のスワッシュ字形は“A.swash”という名前をつけることになります。
	      <P>
<!--	      Using this command you can tell FontForge to associate a given suffix with
	      a feature tag. (in the above example you could associate ".swash" with 'swsh'
	      - - except you don't need to, because FontForge already knows about that one).
	      Select the letter "A", then enter the command, then "A" will be linked to
	      "A.swash" as a 'swsh'. -->
	      このコマンドを使用すると、機能タグに対応する接尾子を FontForge に対して指定することができます。(上の例で言えば、&lsquo;swsh&rsquo;機能に“.swash”という接尾子を対応づけたことになります——特別にそうしないよう指定しないかぎり、デフォルトでこうなります。FontForge はあらかじめこの対応を知っています)。
	  </DL>
	<DT>
<!--	  <A NAME="Rm-All-Feat">Remove All Features</A> -->
	  <A NAME="Rm-All-Feat">すべての機能を削除(<U>R</U>)</A>
	<DD>
<!--	  Removes all typographic features. -->
	  すべての組版機能を削除します。
	<DT>
<!--	  <A NAME="Rm-Feat">Remove Feature(<U>s</U>)...</A> -->
	  <A NAME="Rm-Feat">機能を削除(<U>E</U>)...</A>
	<DD>
<!--	  <A HREF="typofeat.html#Rm-Feat">This dialog</A> allows you to select which
	  features to remove. -->
	  このダイアログを使用すると、どの機能を削除するか選択することができます。
	<DT>
<!--	  <A NAME="Rm-Nested-Feat">Remove Unused Nested Features</A> -->
	  <A NAME="Rm-Unused-Feat">未使用の入れ子になった機能を削除(<U>N</U>)</A>
	<DD>
  <!!--	If there are any nested features which are not referred to within any
	  contextual/chaining feature nor apple state machine then this command will
	  remove them. -->
	  入れ子になった機能で、コンテキスト依存機能や連鎖機能からも Apple の状態機械からも参照されていないものがある場合、このコマンドはそれらをすべて削除します。
	<DT>
<!--	  <A NAME="Retag-Feat">Retag Feature(<U>s</U>)...</A> -->
	  <A NAME="Retag-Feat">機能タグをつけ直す(<U>T</U>)...</A>
	<DD>
<!--	  <A HREF="typofeat.html#Retag-Feat">This dialog</A> allows you to change the
	  opentype tag (or apple feature/setting) on a given feature.(This does not
	  retag kerning information). -->
	  <A HREF="typofeat.html#Retag-Feat">この機能</A> を使用すると、指定した機能に関する OpenType のタグ (または機能/設定) を変更することが可能です。(これはカーニング情報のタグはつけ直しません)。
      </DL>
    <DT>
<!--  Show Dependencies -->
      依存するグリフを表示
      <DL>
	<DT>
<!--	  <A NAME="Dependencies">References</A>... -->
	  <A NAME="Dependencies">参照一覧(<U>R</U>)</A>...
	<DD>
<!--	  This dialog is not available in the bitmap view. It shows you what glyphs
	  contain a reference to the current glyph. You can open a window looking at
	  any of the dependent glyphs by selecting that glyph and pressing the [Show]
	  button. -->
	  このダイアログはビットマップビューでは使用できません。どのグリフが現在のグリフへの参照を含んでいるかを表示します。これを実行すると、現在のグリフに依存するすべてのグリフを一覧表示するウィンドウが現れます。そこでグリフを選択して <CODE>[表示]</CODE> ボタンを押せば、そのグリフを開くことができます。
	<DT>
<!--	  <A NAME="DepSubs">Substitutions</A>... -->
	  <A NAME="DepSubs">置換一覧(<U>S</U>)</A>...
	<DD>
<!--	  Show any glyphs that have substitutions (ligatures, multiple subs, etc.)
	  which depend on the current glyph. So if you select "i", you might see that
	  "fi" depended on it as a ligature, and if you select "A.swash" you might
	  see that "A" depended on it as a 'swsh' alternate subs. -->
	  現在のグリフに依存する置換 (合字、複数文字への置換など) をすべて表示します。例えば“i”を選択した場合、“fi”が合字として依存しているのが表示されるでしょうし、“A.swash”を選択している時は“A”が&lsquo;swsh&rsquo;選択型置換として表示されているのが表示されるでしょう。
      </DL>
    <DT>
<!--  Find <A NAME="Problems">Problems</A>...-->
      <A NAME="Problems">問題点を</A>発見(<U>O</U>)...
    <DD>
<!--  This command is not present in the bitmap view. It will search for several
      common problems. In the glyph view it will select anything that needs to
      be fixed, in the font view it will check all selected glyphs and if any have
      problems will open them and select the problems. It will post a message telling
      you of each problem found. It brings up the <A HREF="problems.html">Find
      Problem</A> dialog to let you choose what problems to look for. -->
      このコマンドはビットマップビューには存在しません。このコマンドはいくつかのよくある問題点を探します。グリフビューでは修正の必要のあるすべての問題点を表示します。フォントビューでは選択中の文字をすべてチェックし、どれかの文字に問題があればそれを開き、問題点を表示します。それとともに、発見された各問題点を通知するメッセージを送ります。<A HREF="problems.html">問題点を発見</A> ダイアログが開かれます。
    <DT>
<!--  <A NAME="Bitmaps">Bitmaps</A> Available...-->
      <A NAME="Bitmaps">使用するビットマップ(<U>A</U>)...</A>
    <DD>
<!--  This brings up a list of pixel sizes for bitmap fonts.<BR> -->
      このコマンドはビットマップフォントのピクセルサイズ一覧を表示します。
      <IMG SRC="bitmapsavail.png" WIDTH="232" HEIGHT="286" ALIGN="Right"> <!-- If you
      have bitmap fonts this will show their pixel sizes. If you remove a size
      that is in the list then that font will be deleted from the sfd file. If
      you add a size then that size font will be created and stored in the sfd
      file. -->
      編集中のフォントにビットマップが含まれているときは、それらのピクセルサイズを一覧表示します。リストからサイズ表示を取り除くと、SFD ファイルからそのサイズのビットマップフォントが削除されます。サイズを追加すると、そのサイズのフォントが追加され、SFD ファイルに格納されます。
      <P>
<!--  FontForge deals in pixel sizes, not point sizes. The conversion between pixels
      and points differs on different systems and indeed on different screens.
      A point is (approximately) 1/72 of an inch, a pixel is however big a pixel
      happens to be on your screen. Usually pixels range from about 1/72 of an
      inch to about 1/144 of an inch. Different systems support different screen
      resolutions as "standard", and FontForge tries to know about these standards.-->
      FontForge が取り扱うのはピクセルサイズであってポイントサイズではありません。ピクセルとポイントの間の変換はシステムごとに異なり、実際には表示画面ごとに異なります。1 ポイントは (約) 1/72 インチですが、1 ポイントが何ピクセルに相当するかは画面の設定によって異なります。通常 1 ピクセルは 1/72 インチ〜1/144 インチです。システムが異なると "標準" としてサポートされるデフォルトの画面解像度は異なります。FontForge は、以下の標準について知ろうと努めています。
      <TABLE BORDER CELLPADDING="2" ALIGN=Center>
	<CAPTION>
<!--	  Some conversions between points and pixels -->
	  ポイント数とピクセル数のいくつかの変換方法
	</CAPTION>
	<TR>
	  <TH><P ALIGN=Left>
<!--	    <U>Screen Resolution</U><BR>
	    Point Size</TH>-->
	    <U>画面解像度　　</U><BR>
	    ポイントサイズ</TH>
	  <TH>72dpi<BR>
	    Mac</TH>
	  <TH>75dpi<BR>
	    X</TH>
	  <TH>96dpi<BR>
	    Win</TH>
	  <TH>100dpi<BR>
	    X</TH>
	  <TH>120dpi<BR>
	    Win</TH>
	</TR>
	<TR>
	  <TH>10pt</TH>
	  <TD>10</TD>
	  <TD>10</TD>
	  <TD>13</TD>
	  <TD>14</TD>
	  <TD>17</TD>
	</TR>
	<TR>
	  <TH>12pt</TH>
	  <TD>12</TD>
<!--	  <TD>12~13</TD>-->
	  <TD>12〜13</TD>
	  <TD>16</TD>
	  <TD>17</TD>
	  <TD>20</TD>
	</TR>
	<TR>
	  <TH>18pt</TH>
	  <TD>18</TD>
	  <TD>19</TD>
	  <TD>24</TD>
	  <TD>25</TD>
	  <TD>30</TD>
	</TR>
	<TR>
	  <TH>24pt</TH>
	  <TD>24</TD>
	  <TD>25</TD>
	  <TD>32</TD>
	  <TD>33</TD>
	  <TD>40</TD>
	</TR>
      </TABLE>
      <P>
<!--  Sadly your screen will probably not match one of the standard screens precisely.
      On X the standard resolutions are 75 and 100dpi, on MS Windows 96 and 120dpi,
      and on the Mac 72dpi. This dialog provides the conversion between pixel size
      and point sizes at these resolutions. -->
      残念ながら、あなたの画面解像度はおそらく標準解像度とは一致しないでしょう。X では標準解像度は 75dpi と 100dpi で、MS Windows では 96 dpi と 120dpi、Mac では 72dpi です。このダイアログは、ピクセルサイズと、これらの解像度におけるポイントサイズとの間で変換を行います。
      <P>
<!--  Normally the new glyphs are created by rasterizing the outline font. If your
      system has the freetype2 library installed (and you checked the "Use FreeType"
      box) then FontForge will use the FreeType rasterizer to generate bitmaps,
      otherwise it will use FontForge's built-in rasterizer (which isn't as good,
      but involves a little less overhead). -->
      通常は、新しいグリフはアウトラインフォントをラスタライズすることによって作成されます。システムに freetype2 ライブラリがインストールされている場合 (そして「FreeType を使う」チェックボックスにチェックが入っている場合) FontForge はビットマップの生成に FreeType ラスタライザを使用します。それ以外の場合、FontForge は内蔵ラスタライザ (能力では劣りますが、オーバヘッドは少し削減されます) を使用します。
      <P>
<!--  Finally, if you have no outline font then the new glyph will be created
      by scaling the (bitmap) font displayed in the font view. -->
      最後に、もしアウトラインフォントが存在しない場合、新しいグリフはフォントビュー内に表示されている (ビットマップ) フォントを拡大・縮小して作成されます。
      <P>
<!--  In CID keyed fonts there will not be a set of bitmaps for each sub font,
      instead the entire complex of sub-fonts share bitmaps.<BR Clear=Right> -->
      CID フォントでは、各サブセットにはビットマップは存在しません。その代りに、サブフォントの複合体全体がビットマップを共有します。<BR Clear=Right>
      <P>
      <IMG SRC="greymapsavail.png" WIDTH="232" HEIGHT="286" ALIGN="Right"><!--FontForge
      also supports anti-aliased bitmap fonts, and you can use this dialog to generate
      them. If you want to generate a 12 point anti-aliased font with 8 bits per
      pixel you would type 12@8 into the dialog above. FontForge supports 1, 2,
      4 and 8 bit per pixel fonts (a 1 bit per pixel font is a standard bitmap,
      the others are greymaps).<BR>
      (New greymaps can not be created by scaling old greymaps, if you wish to
      generate a greymap font, you must have an outline font). -->
      FontForge はアンチエイリアス表示のビットマップフォントもサポートしており、このダイアログを使ってそれらを生成するように設定することもできます。12 ポイントのアンチエイリアスフォントを各ピクセル 8 ビットの階調で作成したいなら、上のダイアログに 12@8 と入力します。FontForge は各ピクセル 1, 2, 4, 8 ビットのフォントをサポートしています (各ピクセル 1 ビットのフォントは標準ビットマップで、その他はグレイマップです)。<BR>
      (新しいグレイマップは古いグレイマップを拡大・縮小して作成することはできません。グレイマップフォントを作成したい場合、アウトラインフォントを持っている必要があります)。
    <DT>
<!--  <A NAME="Regenerate">Regenerate</A> Bitmaps...-->
      <A NAME="Regenerate">ビットマップの再生成(<U>B</U>)...</A>
    <DD>
<!--  If you have changed the outline that a bitmap is based one then you should
      (at some point) look into changing the bitmap too. This command allows you
      to regenerate a subset of the glyphs in a given bitmap font. In the font
      view you can regenerate all selected glyphs, while in the bitmap and outline
      views you can regenerate the current glyph. You can pick what pixel sizes
      should be regenerated too (unlike the above command, removing a bitmap size
      from the regenerate list will not delete it).<BR>
      As before, if you wish to change a greymap you should refer to it by
      &lt;pixel-size&gt;@&lt;bits-per-pixel&gt;. -->
      アウトラインフォントに基づいたビットマップが作られている場合、そのアウトラインを変更したら (ある時点で) ビットマップもちょっと直したくなるでしょう。このコマンドを使用すると、既存のビットマップフォントに含まれるあるグリフのサブセットを再生成することができます。どのピクセルサイズを再生成するかを選択することもできます (上のコマンドと異なり、あるビットマップサイズを再生成のリストから削除しても、フォントからそのサイズが削除されることはありません)。<BR>
      上と同じように、グレイマップを変更したい場合は &lt;ピクセルサイズ&gt;@&lt;ピクセル階調のビット数&gt; で指定することができます。
    <DT>
<!--  Transformations-->
      変形
    <DD>
<!--  This sub-menu has rather different choices in the bitmap view from the other
      views. (Because bitmaps are discrete and the continuous transformations of
      splines are not meaningful). -->
      このサブメニューは、ビットマップビューでは他のビューとかなり異なる選択肢が表示されます。(なぜならビットマップは離散的で、スプラインのような連続変形は無意味だからです)。
      <DL>
	<DT>
<!--	  <A NAME="Transform">Transform</A>... -->
	  <A NAME="Transform">変形(<U>T</U>)</A>...
	<DD>
<!--	  <A HREF="transform.html">In the Font and Outline Views this brings up the
	  transform dialog</A>. This provides the standard linear transformations you
	  expect to have available (rotation, scaling, translation, skewing). -->
	  <A HREF="transform.html">フォントビューとアウトラインビューではこのコマンドは変形ダイアログを表示します</A>。このコマンドは普通に考えて利用できそうな標準的な線形変換 (回転、拡大・縮小、平行移動、傾き) を提供します。
	<DT>
<!--	  <A NAME="PoV">Point of View </A>Projection -->
	  <A NAME="PoV">透視</A>変換(<U>P</U>)...
	<DD>
<!--	  <A HREF="transform.html#PoV">This dialog </A>allows you to perform a perspective
	  transformation on your glyphs. (This is a non-linear transformation) -->
	  <A HREF="transform.html#PoV">このダイアログ</A>を使うと、グリフに対して透視変換を施すことができます (これは非線形変換の一種です)。
	<DT>
<!--	  <A NAME="Non-Linear">Non-Linear</A> Transform...-->
	  <A NAME="Non-Linear">非線形の</A>変形(<U>N</U>)...
	<DD>
<!--	  <A HREF="transform.html#Non-Linear">This dialog</A> allows you to perform
	  a general transformation (which could be linear or which can be non-linear).
	  Essentially you provide two equations for how x and y should be mapped.<BR> -->
	  <A HREF="transform.html#Non-Linear">このダイアログ</A> を使うと、一般的な変換を施すことができます (線形変換も非線形変換も可能です)。本質的には、x と y がどのように写像されるかを 2 個の等式で指定します。<BR>
	<DT>
<!--	  <A NAME="Flip">Flip</A> Horizontally -->
	  水平方向に<A NAME="Flip">反転(<U>H</U>)</A>
	<DD>
<!--	  Flips the bitmap horizontally. (Only in bitmap view) -->
	  ビットマップを水平方向に反転します (ビットマップビューのみ)。
	<DT>
<!--	  <A NAME="FlipV">Flip</A> Vertically -->
	  垂直方向に<A NAME="FlipV">反転(<U>V</U>)</A>
	<DD>
<!--	  Flips the bitmap vertically. (Only in bitmap view) -->
	  ビットマップを垂直方向に反転します。(ビットマップビューのみ)
	<DT>
<!--	  <A NAME="Rotate">Rotate</A> 90&#176; CW -->
	  時計回りに90°<A NAME="Rotate">回転(<U>R</U>)</A>
	<DD>
<!--	  Rotates the bitmap 90&#176; clockwise. (Only in bitmap view) -->
	  ビットマップを時計回りに90°回転します。(ビットマップビューのみ)
	<DT>
<!--	  <A NAME="Rotate90CCW">Rotate</A> 90&#176; CCW -->
	  反時計回りに90°<A NAME="Rotate90CCW">回転</A>
	<DD>
<!--	  Rotates the bitmap 90&#176; counter-clockwise. (Only in bitmap view) -->
	  ビットマップを反時計回りに90°回転します。(ビットマップビューのみ)
	<DT>
<!--	  <A NAME="Rotate180">Rotate</A> 180&#176; -->
	  180°<A NAME="Rotate180">回転</A>
	<DD>
<!--	  Rotates the bitmap 180&#176; (Only in bitmap view) -->
	  ビットマップを 180°回転します。(ビットマップビューのみ)
	<DT>
<!--	  <A NAME="Skew">Skew</A>-->
	  <A NAME="Skew">傾き(<U>S</U>)...</A>
	<DD>
<!--	  Allows you to specify a ratio by which to skew the bitmap 1:3 means for every
	  3 pixel rise in y, skew the bitmap one pixel horizontally. (Only in bitmap
	  view) -->
	  ビットマップを傾ける割合を指定します。1:3 の時は、y 方向に 3 ピクセル上にいくごとに 1 ピクセル横に傾くことを意味します。(ビットマップビューのみ)
      </DL>
    <DT>
<!--  <A NAME="NonLinear">Non Linear </A>Transform...-->
      <A NAME="NonLinear">非線形の</A>変形(<U>N</U>)...
    <DD>
<!--  This command is not available in the default build, you must modify the file
      <CODE>configure-fontforge.h</CODE> and then rebuild FontForge. This command
      allows the user to specify a non-linear transformation as a pair of expressions
      (the first specifies the transformation for the x coordinate, the second
      for the y coordinate). These expressions may be fairly general functions
      of x and y. See the <A HREF="scripting-alpha.html#NonLinearTransform">scripting
      page</A> for a description of the syntax. -->
      このコマンドはデフォルトのビルドでは利用できません。<CODE>configure-fontforge.h</CODE> を修正して FontForge をビルドしなおす必要があります。このコマンドを使うと、非線形の座標変換を 2 個の数式として指定することができます (最初が x 座標の変換式を、2 番目が y 座標の変換式を表します)。これらの数式には x と y の非常に一般的な式を書くことができます。構文の説明については、<A HREF="scripting-alpha.html#NonLinearTransform">スクリプト処理のページ</A>を参照してください。
    <DT>
<!--  <A NAME="Expand">Expand</A> Stroke...-->
      輪郭を<A NAME="Expand">太らせる(<U>E</U>)...</A>
    <DD>
<!--  Not in the bitmap view. In the font view it applies to all foreground splines
      in all selected glyphs. In the outline view it applies to all paths that
      have at least one point selected (or if no points are selected then it applies
      to all paths).<BR> -->
      ビットマップビューからは呼び出せません。フォントビューでは選択されたすべてのグリフの前面にあるすべてのスプラインに対して太め処理を適用します。アウトラインビューでは、最低 1 個の点が選択されているすべてのパスに適用します (点が選択されていないときには、すべてのパスに適用します)。<BR>
      <IMG SRC="../twolines.png" WIDTH="247" HEIGHT="247">
      <IMG SRC="../expandedlines.png" WIDTH="247" HEIGHT="247"><BR>
<!--  Above is a simple example of what expand stroke can do. It takes the two
      open paths above left and turns them into the two closed paths right.<BR> -->
      上図は、ストロークの太め処理が何を行うかの簡単な例です。左上にある 2 本の開いたパスを元に、それらを右の 2 本の閉じたパスに変換します。
      <IMG SRC="expandstroke.png" WIDTH="279" HEIGHT="371" ALIGN="Left"><BR>
<!--  The Expand Stroke dialog gives you control over various aspects of the expansion
      process. You can chose a stroke width, how the ends of an open path should
      be drawn, and how the path should look when two splines (or lines) join which
      do not have the same slope (ie. at a corner point). Or you may choose to
      have the path be that which would be traced by a calligraphic pen, or an
      elliptical pen. For closed contours you may also choose to remove either
      the generated contour which is inside the original, or that which is outside
      (Note: Make sure your glyph is oriented correctly with
      <A HREF="elementmenu.html#Correct">Edit-&gt;Correct Direction </A>before
      removing a contour (if misoriented the wrong contour is removed)). -->
      「<CODE>輪郭を太らせる(<U>E</U>)</CODE>」ダイアログは、パスを太くする処理のさまざまな様相を制御することができるダイアログを起動します。ストロークの幅、開いたパスの端をどう描くかおよび 2 本のスプライン (または直線) がつながる点で傾きが等しくない場合 (すなわち、角になっている点で) どのような形になるかを選ぶことができます。または、パスをカリグラフィ用のペンや楕円のペンでなぞった時のような形を選ぶこともできます。また、閉じたパスに対しては、生成された輪郭のうち内側にある物を除去するか、または外側にある物を除去するかも選択することができます。(注意: パスの削除を行う前には、<A HREF="elementmenu.html#Correct"><CODE>エレメント(<U>L</U>)</CODE>→<CODE>アウトラインの向きを修正(<U>C</U>)</CODE></A>を使って、グリフに含まれるパスの方向が正しいことを確めてください (向きが間違っていると、反対の輪郭が削除されてしまいます))。
      <P>
<!--  <A HREF="pfaeditmath.html#Stroke">How is this done?</A><BR CLEAR=ALL>-->
      <A HREF="pfaeditmath.html#Stroke">どうやって処理しているのか?</A><BR CLEAR=ALL>
    <DT>
<!--  <A NAME="TilePath">Tile Path</A>-->
      <A NAME="TilePath">パスのタイル敷き(<U>P</U>)</A>
    <DD>
<!--  This command is not available in the default build, you must modify the file
      <CODE>configure-fontforge.h</CODE> and then rebuild FontForge. Not available
      in quadratic (truetype) fonts. This command takes the contents of the clipboard
      and treats it as a tile which is applied to any selected contours. -->
      このコマンドはデフォルトのビルドでは利用できません。2 次曲線 (TrueType) フォントでは使用できません。ファイル <CODE>configure-fontforge.h</CODE> を修正してから FontForge を再ビルドする必要があります。このコマンドはクリップボードの内容をとり、それを選択中のパスに当てはめるためのタイルであるかのように扱います。
    <DT>
<!--  None of these is available in the bitmap view. -->
      これらはいずれもビットマップビューには存在しません。
      <DL>
	<DT>
<!--	  <A NAME="Remove">Remove</A> Overlap -->
	  重なり合う図形を<A NAME="Remove">結合(<U>R</U>)</A>
	<DD>
<!--	  Not in the bitmap view, <EM>not available when the font has quadratic
	  splines</EM><SUP><A HREF="#overlap-footnote">1</A></SUP>. If two closed paths
	  intersect then there will be overlap. This will get rid of it, leaving one
	  closed path behind. -->
	  ビットマップビューには存在しません。<EM>フォントが 2 次スプラインのときは使用できません</EM><A HREF="#overlap-footnote">1</A></SUP>。2 本の閉じたパスが交差するとき、それらを重なり合っていると言います。このコマンドは、重なり合いを取り除いて 1 本のパスに変換します。
	  <P>
<!--	  Make sure paths have the correct orientation. Consider the letter "O" with
	  two contours. If both contours run in the same direction then the inner path
	  will be removed (because the outer path overlaps it everywhere), but if the
	  contours run in opposite orientations then the inner path will be retained.
	  Things get very strange if you have intersecting paths with different
	  orientations. -->
	  パスの向きが正しいことを確かめておいてください。2 本の輪郭をもつ文字“O”を考えましょう。2 本の輪郭が同じ方向を向いている場合、内側のものが削除されます (外側のパスが全体に重なり合っているからです) が、輪郭同士が逆向きになっている場合、内側のパスは保持されます。交差するパスが逆向きになっているときは非常に奇妙なことが起こります。
	  <P>
	  <IMG SRC="../expandedlines.png" WIDTH="247" HEIGHT="247">
	  <IMG SRC="../overlappedlines.png" WIDTH="247" HEIGHT="247"><BR>
<!--	  This command is probably the buggiest in FontForge. So before FontForge invokes
	  the command it will save the state to the error recovery file.<BR>
	  Warning: Splines which are tangent (or nearly so) cause problems. Points
	  which are close together can cause problems. -->
	  このコマンドは FontForge の中でおそらく最もバグが多いはずです。ですから、FontForge はコマンドを起動する前にエラー回復ファイルに現状を保存します。<BR>
      警告: 平行な (またはほとんどそれに近い) スプラインは問題を起こします。あまりに近い点も問題を起こす可能性があります。
	<DT>
<!--	  <A NAME="Intersect">Intersect</A> -->
	  <A NAME="Intersect">重複部分を抽出(<U>I</U>)</A>
	<DD>
	  <TABLE CELLPADDING="2">
	    <TR>
	      <TD><IMG SRC="../exclude-pre.png" WIDTH="174" HEIGHT="174"></TD>
	      <TD><IMG SRC="../intersect-post.png" WIDTH="174" HEIGHT="174"></TD>
	    </TR>
	  </TABLE>
	  <P>
<!--	  This will remove everything not in the intersection of two regions. -->
	  これは 2 つの領域の交差部分以外のすべてを削除します。
	<DT>
<!--	  <A NAME="Exclude">Exclude</A> -->
	  <A NAME="Exclude">重複部分を除去(<U>E</U>)</A>
	<DD>
	  <TABLE CELLPADDING="2">
	    <TR>
	      <TD><IMG SRC="../exclude-pre.png" WIDTH="174" HEIGHT="174"></TD>
	      <TD><IMG SRC="../exclude-post.png" WIDTH="174" HEIGHT="174"></TD>
	    </TR>
	  </TABLE>
	  <P>
<!--	  This will remove the selected contours from the unselected ones. Only available
	  in the outline glyph view. -->
	  これは選択された輪郭内の領域を選択されていない輪郭から除去します。アウトライングリフビューでのみ使用可能です。
	<DT>
<!--	  Find Intersections -->
	  <A NAME="FindInter">交点を見つける(<U>F</U>)</A>
	<DD>
<!--	  This finds the places where overlapping contours intersect and inserts points
	  at those locations. -->
	  これは重なり合う輪郭同士の交点を見つけ、そこを通るパスそれぞれに点を追加します。
      </DL>
    <DT>
<!--  Simplify -->
      単純化(<U>S</U>)
      <DL>
	<DT>
<!--	  <A NAME="Simplify">Simplify</A> -->
	  <A NAME="Simplify">単純化(<U>S</U>)</A><BR>
	<DD>
<!--	  Not in the bitmap view. If you have lots of points on a path, some of which
	  do not materially add to the path's shape, then this command will remove
	  the extraneous points. (It will not remove points where the slope at the
	  point is horizontal or vertical as postscript likes to have these points
	  present). -->
	  ビットマップビューでは使用できません。パス上にたくさんの点があって、そのうちのいくつかは実質的にはパスの形を指定する役割を果たしていない場合、このコマンドは無駄な点を取り除きます (このコマンドは線の傾きが水平または垂直になっている箇所にある点は取り除きません。PostScript インタプリタではそれがあると都合がいいからです)。
	  <P>
<!--	  <A HREF="pfaeditmath.html#Approximating">How is this done?</A> -->
	  <A HREF="pfaeditmath.html#Approximating">どうやって処理しているのか?</A>
	<DT>
<!--	  <A NAME="SimplifyMore">Simplify More</A> -->
	  <A NAME="SimplifyMore">さらに単純化</A>
	<DD>
<!--	  This is a variant of the simplify command. It brings up a dialog which gives
	  you control over what sorts of errors this simplification is allowed to induce.
	  You can control: -->
	  これは <CODE>単純化(<U>S</U>)</CODE> コマンドの変種で、Shift キーを押しながらメニューを呼び出すと使用できます。単純化処理によってどういう種類の誤差が生じてもよいかを指定することができるメニューが起動します。以下の項目が設定可能です:
	  <UL>
	    <LI>
<!--	      How far the simplified contour is allowed to stray from the original -->
	      単純化の結果の輪郭が、オリジナルからどれだけ離れてもいいか
	    <LI>
<!--	      Whether to allow removal of extreme points -->
	      極値にある点を取り除いてもいいか
	    <LI>
<!--	      Whether to allow the slope to change at points. -->
	      端点の所で傾きが変化してもいいか
	    <LI>
<!--	      Whether to make corner points into curve points (by adjusting the control
	      points) -->
	      (制御点を調節することにより、) 角の点を曲線上の点に転換してもいいか 
	    <LI>
<!--	      Whether to flatten small bumps off of lines -->
	      線から飛び出た小さなコブを平滑化するか
	    <LI>
<!--	      Whether to try to simplify straight lines at all -->
	      直線を完全に単純化することを試みるか
	  </UL>
	  <P>
<!--	  Finally, you may specify whether this set of values should become the default
	  value for future Simplify commands -->
	  最後に、今回使用する値の組を、それ以降に実行する <CODE>単純化(<U>S</U>)</CODE> コマンド群のデフォルト値とするかどうかを指定することができます。
	<DT>
<!--	  <A NAME="Cleanup">Cleanup Glyph</A> -->
	  <A NAME="Cleanup">不要な曲線を除去(<U>N</U>)</A>
	<DD>
<!--	  This is a special case of the simplify command. In this case if there is
	  a spline which actually traces out a line but none the less has control points,
	  then this command will remove the control points. It will also cleanup zero
	  length splines. -->
	  これは <CODE>単純化(<U>S</U>)</CODE> コマンドの特殊な場合です。この場合、実際には直線を描いているのに不要な制御点がある場合、このコマンドがそれらの制御点を取り除きます。また、長さ 0 のスプラインを取り除きます。
	<DT>
<!--	  <A NAME="CanonicalSP">Canonical Start Points</A> -->
	  <A NAME="CanonicalSP">開始点を正規化(<U>P</U>)</A>
	<DD>
<!--	  This will change the start point of the contour (or of all selected contours)
	  to be the leftmost point on the contour. If there are several points with
	  the same horizontal coordinate it will pick the one closest to the baseline.
	  There are two reasons for doing this: -->
	  このコマンドは、輪郭の開始点 (または選択された輪郭) を輪郭上の左端の点をに置き換えます。水平座標が同じ点がいくつかある場合、ベースラインに最も近い点を選択します。これを行うのには 2 つの理由があります:
	  <UL>
	    <LI>
<!--	      In a PostScript Type1 or Type2 font it will (usually) reduce the size of
	      the code expressing the glyph slightly. (I don't think it can increase the
	      code, but there are certainly cases where the optimization will have no effect). -->
	      PostScript Type1 および Type2 フォントでは (通常) グリフを表現するコードのサイズを僅かに縮減します。(この処理がコードサイズを増やすような場合は無いと思いますが、最適化が意味をもたない場合があるのは確かです。
	    <LI>
<!--	      It will enable FontForge to find more reusable bits of code which it can
	      put in subroutines -->
	      FontForge が、再利用可能でサブルーチンに移動できるコード片をより多く発見することができます。
	  </UL>
	<DT>
<!--	  <A NAME="CanonicalContours">Canonical Contour Order</A> -->
	  <A NAME="CanonicalContours">輪郭の順序を正規化(<U>C</U>)</A>
	<DD>
<!--	  Order the contours so that the contour with the leftmost point comes first,
	  then the contour whose leftmost point is a little further right and so forth.
	  Again, this should decrease the code size slightly in a Type1 font. -->
	  輪郭の順序を並べ替え、最初に左端の点が最初にある輪郭が、次に左端の点がその次に左側にある輪郭がという具合に並ぶようにします。これも Type1 フォントのサイズを僅かに縮小するはずです。
      </DL>
    <DT>
<!--  <A NAME="Add-Extrema">Add Extrema</A>-->
      <A NAME="Add-Extrema">極大点の追加(<U>X</U>)</A>
    <DD>
<!--  Not in the bitmap view. Both TrueType and Type1 say that there should be
      points on the contour where it reaches its extreme horizontal and vertical
      values. In the outline view, if any points are selected, this will add points
      at all extrema on splines between selected points. In the font view, metrics
      view (or if nothing is selected in the outline view) it will add extrema
      to a spline if: 1) The spline is longer than the em-size/32, or 2) the entire
      contour (rather than just the current spline) attains its maximum/minimum
      value at this point. If the added extrema is extremely close to an already
      existing point, fontforge may remove that point to avoid creating tiny splines. -->
      ビットマップビューでは使用できません。TrueType と Type1 のどちらでも、水平および垂直方向の極値にあたる位置に点が存在することを推奨しています。アウトラインビューでは、何らかの点が選択されていれば、選択された点の間に存在するすべての極値に点を追加します。フォントビューおよびメトリックビュー (または、アウトラインビューで何も選択されていなければ) 以下の 2 条件のいずれかが満たされている極値に点を追加します。1) スプラインの長さが em / 32 よりも大きい、2) その点が文字の輪郭全体 (現在のスプラインだけでなく) の極大/極小値に該当する。もし、追加した点のごく近くに既存の点が位置する場合、FontForge は微小なスプラインが発生するのを避けるためにその点を削除します。
    <DT>
<!--  Effects-->
      効果
     <DD>
<!--  Not in quadratic (truetype) fonts.-->
      2 次曲線 (TrueType) フォントでは実行できません。
      <DL>
	<DT>
<!--	  <A NAME="Outline">Outline</A> -->
	  <A NAME="Outline">アウトライン(<U>O</U>)</A>
	<DD>
	  <IMG SRC="../OutlineInline.png" WIDTH="146" HEIGHT="70" ALIGN="Right"><!--Changes
	  the selected glyphs so that instead of being a solid block, only the outline
	  of the glyph is visible. The glyphs' bounding boxes will not change. -->
	  選択されたグリフを中身の詰まった塊ではなく、グリフの輪郭だけが見えるように変形します。グリフのバウンディングボックスは変更しません。
	<DT>
<!--	  <A NAME="Inline">Inline</A> -->
	  <A NAME="Inline">インライン(<U>I</U>)</A>
	<DD>
<!--	  Changes the selected glyphs so that the character is surrounded by an outline.
	  The glyphs' bounding boxes will not change.-->
	  選択中のグリフを加工し、グリフがアウトラインで囲まれたようにします。グリフのバウンディングボックスは変更しません。
	<DT>
<!--	  <A NAME="Shadow">Shadow</A> -->
	  <A NAME="Shadow">影つき(<U>S</U>)</A>
    <DD>
<!--	  Changes the selected glyphs to give them each a
	  shadow.<IMG SRC="../ShadowWireframe.png" WIDTH="171" HEIGHT="69" ALIGN="Right">
	  The user has control over the shadow size and angle. -->
      選択中の各文字に影をつけます。<IMG SRC="../ShadowWireframe.png" WIDTH="171" HEIGHT="69" ALIGN="Right">
      ユーザは影の長さと角度を調節することができます。
    <DT>
<!--	  <A NAME="Wireframe">Wireframe</A>-->
	  <A NAME="Wireframe">縁どり立体化(<U>W</U>)</A>
    <DD>
<!--	  Changes the selected glyphs to give them a 3D wireframe look.-->
	  選択されたグリフを縁取られた立体に見えるように加工します。
      </DL>
    <DT>
<!--  <A NAME="MetaFont">MetaFont</A>...-->
      <A NAME="MetaFont"><U>M</U>eta Font</A>...
    <DD>
<!--  This <A HREF="MetaFont.html">dialog</A> is only present in the font and outline
      glyph views, not in quadratic (truetype) fonts. It allows you to make fonts
      bolder or condensed. It doesn't work very well.<FONT COLOR="Red"><BR>
      <STRONG>NOTE</STRONG></FONT>: It does <EM>not</EM> read TeX .mf files. The
      name is chosen because it has some similarity in terms of features. -->
      この<A HREF="MetaFont.html">ダイアログ</a>はフォントビューとアウトライングリフビューにのみ存在します。2 次曲線 (TrueType) フォントでは使用できません。このコマンドによって、フォントをより太くしたり文字幅を狭めたりすることが可能です。これはあまりよく動きません。<FONT COLOR="Red"><BR>
      <STRONG>注意</STRONG></FONT>: これは TeX の .mf ファイルを読み込み<EM>ません</EM>。この名前は、機能面で似たところがあるためにつけました。
    <DT>
      <A NAME="AutoTrace">自動トレース(<U>R</U>)</A>
    <DD>
<!--  This command is only available if you have downloaded Martin Weber's
      <A HREF="http://sourceforge.net/projects/autotrace/">autotrace program</A>
      or Peter Selinger's <A HREF="http://potrace.sf.net/">potrace</A>. If you
      have a background image in a glyph then autotrace will automagically trace
      the outlines of that image. See <A HREF="autotrace.html">the section on
      autotracing</A> for more information. -->
      このコマンドは、Martin Weber の <A HREF="http://sourceforge.net/projects/autotrace/">autotrace</A> か Peter Selinger の <A HREF="http://potrace.sf.net/">potrace</A> のどちらかのプログラムをダウンロードしていないと使用できません。グリフに背景画像が含まれていると、自動トレースプログラムが勝手にその画像のアウトラインをトレースしてくれます。より詳しい情報は、<A HREF="autotrace.html">自動トレースのセクション</A>を参照してください。
    <DT>
<!--  <A NAME="Align">Align</A> menu-->
      <A NAME="Align">点を揃える(<U>L</U>)</A> メニュー
    <DD>
<!--  This submenu is only present in the outline view, it allows you to align
      points or to space them out along an axis. -->
      このサブメニューはアウトラインビューだけに存在し、これx使うと点を座標軸にぴったり沿うように揃えることができます。
      <DL>
	<DT>
<!--	  <A NAME="Average">Average</A> Points-->
	  座標の<A NAME="Average">平均値(<U>A</U>)</A>
	<DD>
<!--	  This will look at all the selected points and find the coordinate with the
	  least change. Then it will average find the median point on that axis and
	  set all the selected points to have that value for the appropriate
	  coordinate.<BR>-->
	  このコマンドは選択中のすべての点を調べ、値のばらつきが少ない方の座標軸を選択します。次に、その軸上での平均値を取って中間点を求め、選択中のすべての点をその平均値に揃えます。<BR>
<!--	  So if you have a line which is almost horizontal, and select its endpoints
	  and apply this command it will be horizontal.<BR>-->
	  ですから、ほとんど水平に並んでいる線がある場合、その端点を選択してこのコマンドを適用するとその線は水平になります。<BR>
	  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
	  <IMG SRC="../Constrain2_1.png" WIDTH="122" HEIGHT="90">&nbsp; &nbsp; &nbsp;
	  &nbsp; <IMG SRC="../Constrain2_2.png" WIDTH="122" HEIGHT="90"><BR>
<!--	  (if you select exactly two points, and they lie close to a 45 diagonal, then
	  they will be forced to the diagonal rather than to horizontal/vertical) -->
	  (選択した点がちょうど 2 個で、それらが 45°に近い斜めの関係にある場合は、水平・垂直ではなく斜め方向に揃えられます。)
	<DT>
<!--	  <A NAME="Space-Pts">Space Points</A>-->
	  <A NAME="Space-Pts">点の間隔を均等に(<U>S</U>)</A>
	<DD>
<!--	  If you have three or more points selected then FontForge will figure out
	  the coordinate that has the greatest change and will space the points out
	  regularly along that axis.<BR> -->
	  3 個以上の点を選択している場合、FontForge は差が大きいほうの座標軸を選び、その軸に沿って等間隔に点を分散させます。<BR>
<!--	  If you select one point (and that point is in the middle of a path) then
	  (internally) the point's location will be expressed in a coordinate system
	  which is rotated so that one axis is parallel to the line between the two
	  points that surround the selected point. The selected point will be moved
	  mid-way between the two on this axis, while it's other coordinate remains
	  fixed.<BR> -->
	  点を 1 個だけ選択している場合 (しかもその点がパスの中間にある場合)、点の位置は (内部的に) 選択した点の両隣の点を結ぶ直線が座標軸に平行になるように回転した座標軸で表現されます。選択中の点はその軸に沿って 2 点の中間となる位置に移動します。この時、それに直行する軸方向の位置は固定しています。<BR>
<!--	  That's an extremely complicated way of saying: If the selected point is connected
	  to two points which are on a horizontal line, then the selected point's x
	  coordinate will be midway between the two, while its y coordinate remains
	  unchanged.<BR> -->
	  これは非常に複雑な説明方法です: 水平な線上に置かれた 2 個の点の両方に接続した 1 個の点を選択した場合、選択した点の x 座標は 2 個の点の中間になり、それに対して y 座標は変更されません。<BR>
	  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
	  <IMG SRC="../Constrain1_1.png" WIDTH="122" HEIGHT="90">&nbsp; &nbsp; &nbsp;
	  &nbsp; <IMG SRC="../Constrain1_2.png" WIDTH="122" HEIGHT="90">
	<DT>
<!--	  <A NAME="Space-Regions">Space Regions</A>-->
	  <A NAME="Space-Regions">グループ間を均等に(<U>R</U>)...</A>
	<DD>
<!--	  This is similar to the above command except that it allows you to make a
	  rather simple definition of a collection of points which should be moved
	  together. Each of these regions will be regularly spaced along the chosen
	  axis. A region is defined as a collection of points, each one of which is
	  within some maximum distance of at least one other point in the region. The
	  purpose of this is to allow you to space out the stems of the letter "m"
	  so that they regularly spaced horizontally. Sadly it won't work in many cases
	  because in a serifed font the serifs will often be closer to each other than
	  to their respective stems.<BR> -->
	  これは上のコマンドと似ていますが、相対位置を保ちつつ移動したい点のグループをとても簡単に定義することができる点が異なります。このコマンドは、それらのグループごとの間隔を、選択した座標軸に沿って均等に配置します。1 個のグループは、その中の点同士がすべてグループ内の他の 1 個以上の点と、所定の最大距離以内にある点の集まりとして定義されます。このコマンドの目的は、文字“m”のステム同士を横方向に均等に配置するような操作を可能にすることです。残念ながら、これが役に立たない場合は非常に多くあります (セリフつき書体では、しばしばあるセリフと他のセリフとの間隔のほうがセリフの属するステムとの間よりも狭くなります)。<BR>
	  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
	  <IMG SRC="../Spacem_1.png" WIDTH="140" HEIGHT="108"> &nbsp; &nbsp; &nbsp; &nbsp;
	  <IMG SRC="../Spacem_2.png" WIDTH="145" HEIGHT="108">
	<DT>
<!--	  Make <A NAME="Parallel">Parallel</A> -->
	  <A NAME="Parallel">平行に(<U>P</U>)...</A>
	<DD>
<!--	  If four points are selected, and there are two lines between them, then FontForge
	  will make those lines parallel. If there are four lines between them (ie.
	  they form a quadrilateral, then FontForge will turn it into a parallelogram.
	  (note, this only works on lines, not on curved splines)<BR>
	  The last point selected will be the one moved (sometimes FontForge doesn't
	  remember which point was selected last, then it will just pick one randomly.
	  If you don't want that to happen, select your points and then single click
	  on the one you want moved). -->
	  4 個の点を選択中で、それらの間に 2 本の直線が通っている場合、FontForge はそれらの線が平行になるように点を移動します。4 本の直線が通っている場合 (つまり、四角形を構成している場合)、FontForge はそれらを平行四辺形に変形します (これは直線だけに作用し、曲線のスプラインには作用しないことにご注意ください)。<BR>
	  移動するのは最後に選択した線です (FontForge は、どの点が最後に選択されたか覚えていないことがしばしばあります。その時は 1 個をランダムに選びます。これを避けたい場合は、点を選択した後で移動したい点をシングルクリックしてください)。
      </DL>
    <DT>
<!--  Round -->
      座標を丸める(<U>D</U>)
      <DL>
	<DT>
<!--	  <A NAME="Round">Round</A> to Int -->
	  整数値に(<U>I</U>)<A NAME="Round">丸める</A>
	<DD>
<!--	  Not in the bitmap view. FontForge stores point locations as real numbers
	  (ie. it retains fractional values). TrueType only supports integral values
	  (And much of the time you want integral values in Type1 and Type2 fonts also
	  - - using real numbers makes font files bigger), so when generating the font
	  points are rounded to integral values. This command will round all selected
	  locations to the closest integer.-->
	  ビットマップビューでは使用できません。FontForge は点の位置を実数として格納しています (つまり、それらの値には端数が含まれます)。TrueType は整数値のみをサポートしています (また、Type1, Type2 の両形式のフォントでもほとんどの場合は整数値が望ましいでしょう——実数値を使用するとフォントファイルが大きくなります) ので、フォントを出力する時には座標は整数値に丸められます。このコマンドは、選択した対象の座標値をすべて一番近い整数に丸めます。
	<DT>
<!--	  Round to <A NAME="Hundredths">Hundredths</A> -->
	  <A NAME="Hundredths">1/100単位(<U>H</U>)</A>に丸める
	<DD>
<!--	  Not in bitmap or metrics views. FontForge's Type1 output is limited to hundredths
	  of an em-unit, even when rounding is turned off in the Generate [Options]
	  dialog. -->
	      ビットマップビューとメトリックビューでは使用できません。FontForge の Type1 出力の精度は、出力ダイアログの <CODE>[オプション]</CODE> で、整数への丸めを off にした場合でも、em 単位の 1/100 に限られています。
	<DT>
<!--	  Round to <A NAME="Cluster">Cluster</A> -->
	  近い値を<A NAME="Cluster">まとめる(<U>C</U>)</A>
	<DD>
<!--	  Occasionally you want to make sure that coordinates which are close together
	  have the same value. This command will do that. -->
	  ときどき、非常に近い座標値を確実に同じ値にしたいことがあります。このコマンドはそれを行います。
      </DL>
    <DT>
<!--  <A NAME="Order">Order</A>-->
      <A NAME="Order">順序</A>
    <DD>
<!--  This changes the order in which contours, references and images are drawn.
      It is almost useless because this order of contours and references does not
      affect the final appearance of the glyph. The only relevance it has is when
      interpolating fonts and in multiple master fonts. Here similar contours must
      appear in the same order. -->
      このコマンドはどの順番で輪郭・参照と画像を描画するかを変更します。この輪郭と参照の順序はグリフの形に影響しないので、ほとんどの場合は意味がありません。関係がある唯一の場合は、フォントを補間する場合とマルチプルマスターフォントの場合です。そのときは、同等の輪郭が出現する順番は同じでなければなりません。
      <P>
<!--  If you have a glyph which contains both contours and references, FontForge
      does not specify whether references or contours are drawn first (or whether
      the two are intermixed). If this matters to you, unlink your references. -->
      輪郭と参照の両方を含むグリフがある場合、FontForge が参照と輪郭のどちらを先に描くか (それとも 2 つを混ぜこぜに描画するか) を指定することはできません。これが問題になる場合は、参照のリンクを解除してください。
    <DT>
<!--  <A NAME="Clockwise">Clockwise</A>-->
      <A NAME="Clockwise">時計回り(<U>O</U>)</A>
    <DD>
<!--  Only in the outline view. If all selected paths have a clockwise direction
      then this will be checked. Selecting it will make all paths be clockwise. -->
      アウトラインビューでのみ使用可能です。選択中のパスが時計回りの方向をもつ場合、ここにチェックがつきます。このメニューを選ぶと、それらすべてのパスが時計回りに変更されます。
      <P>
<!--  If not paths are selected, or if all selected paths are open this will be
      greyed out. I a selected path intersects itself results are indeterminate.-->
      選択中のパスがない場合、または選択中のパスがすべて開いたパスである場合、このメニューは灰色表示で選択できません。選択中のパスに自己交差しているものがある場合、結果がどうなるかは不定です。
    <DT>
<!--  <A NAME="Counter">Counter</A>-Clockwise-->
      <A NAME="Counter">反時計回り(<U>N</U>)</A>
    <DD>
<!--  Only in the outline view. If all selected paths have a counter-clockwise
      direction then this will be checked. Selecting it will make all paths be
      counter-clockwise.-->
      アウトラインビューでのみ使用可能です。選択中のパスが反時計回りの方向をもつ場合、ここにチェックがつきます。このメニューを選ぶと、それらすべてのパスが反時計回りに変更されます。
      <P>
<!--  If not paths are selected, or if all selected paths are open this will be
      greyed out. I a selected path intersects itself results are indeterminate.-->
      選択中のパスがない場合、または選択中のパスがすべて開いたパスである場合、このメニューは灰色表示で選択できません。選択中のパスに自己交差しているものがある場合、結果がどうなるかは不定です。
    <DT>
<!--  <A NAME="Correct">Correct</A> Direction-->
      アウトラインの向きを<A NAME="Correct">修正(<U>C</U>)</A>
    <DD>
<!--  Not in the bitmap view. Sets the direction of outermost paths to be clockwise.
      The next path crossed will be made counter-clockwise, the next clockwise,
      etc.<BR>
      This command may produce unexpected results if two splines cross.<BR>
      If a glyph contains a flipped reference, this command will be unable to correct
      the contours inside of the reference directly, instead it will offer to unlink
      the reference after which it can treat its (former) contours like any others. -->
      ビットマップビューでは使用できません。一番外側のパスの向きを時計回りに設定します。次に交差するパスを反時計回りに、次を時計回りに、のように設定します。<BR>
      このコマンドは、2 本のスプラインが交差している場合、予想外の結果を生じることがあります。<BR>
      グリフに反転した参照が含まれている場合は、このコマンドでは参照に含まれる輪郭を直接修正することはできません。その代りに、参照のリンクを解除するかどうかを尋ねるので、解除した後はその (以前の) 輪郭を他の輪郭と同様に扱うことができるようになります。
    <DT>
<!--  Build <A NAME="Accented">Accented/Composite</A> Glyph-->
      <A NAME="Accented">アクセントつきグリフ(<U>B</U>)/複合グリフを構築(<U>C</U>)</A><BR>
    <DD>
<!--  Not in the bitmap view.-->
      ビットマップビューでは使用できません。
      <P>
<!--  The first menu item will only build accented letters, the second will build
      general composite glyphs (fractions, ligatures, digits inside parens, roman
      numerals, etc.) as well. -->
      前者のメニュー項目はアクセントつき文字を組み立てるだけです。後者では、一般的な複合グリフ (分数、合字、括弧つき数字、ローマ数字など) を組み立てることもできます。
      <P>
<!--  If the current glyph is an accented glyph (and all the base glyphs and accents
      have already been created) then this command will delete anything that is
      currently in the foreground and put a reference to the base glyph and another
      reference to the accent glyph into the foreground. So if the current glyph
      were "&Agrave;" then a reference to "A" would be added to it, and a reference
      to "`" would be centered above the "A". <BR>
      If <A HREF="editmenu.html#From">Copy From</A> is set to All Fonts then any
      bitmaps will have a similar process done (even in the outline glyph view view).<BR>    
      A more complete description is given in the section on
      <A HREF="accented.html">accented glyph</A>. -->
      現在のグリフがアクセントつきグリフであれば (なおかつ基底グリフとアクセントが既に作成してあれば)、このコマンドはグリフの前面に含まれている内容をすべて削除し、基底グリフに対する参照と、アクセントのグリフに対するもう一つの参照を前面に配置します。例えば、現在のグリフが“&Agrave;”であれば、“A”への参照がそのグリフに追加され、“`”への参照が“A”と中心を合わせて配置されるでしょう。<BR>
      もし <A HREF="editmenu.html#From"><CODE>コピー元の指定(<U>F</U>)</CODE></A> が「すべてのフォント」に設定されていると、すべてのサイズのビットマップに対して同じ処理を行います (アウトラインビューで実行した場合も行います)<BR>
      より完全な説明は、<A HREF="accented.html">アクセントつきグリフ</A>に関するセクションにあります。
    <DT>
<!--  Build <A NAME="BuildDuplicate">Duplicate</A> -->
      <A NAME="BuildDuplicate">複製グリフ</A>を作成(<U>D</U>)
    <DD>
<!--  Only in the font view.<BR>
      Consider the letters "Alpha" and "A". Often these may be represented by the
      same glyph. This command which change the encoding slightly so that the encoding
      for U+0391 will refer to the glyph named "A". Note that this is subtly different
      from refering to a glyph named "Alpha" which refers to another glyph named
      "A". -->
      フォントビューでのみ使用可能です。<BR>
      文字“Alpha”と“A”を考えてみましょう。これらはしばしば同一のグリフで表現されます。このコマンドはエンコーディングを微調整して、U+0391 の文字コードが“A”という名前のグリフを指し示すようにします。これは、“Alpha”というグリフが“A”という別のグリフを参照するのとは微妙に異なることに注意してください。
      <P>
<!--  Adobe suggests that you use a reference rather than giving to unicode code
      points to one glyph, but it is part of the font format. -->
      Adobe は、1 個のグリフに複数の符号位置を割り当てるのではなく、参照を使用するべきであると示唆していますが、この方法はフォントフォーマットに違反しているわけではありません。
    <DT>
<!--  <A NAME="Merge">Merge</A> Fonts...-->
      フォントの<A NAME="Merge">統合(<U>M</U>)...</A>
    <DD>
<!--  Only in the font view. If you are building a unicode font you will often

      want to merge in other fonts. You can, of course, cut and paste from one
      to the other, but that can be tedious, while this command will do it all
      in one fell swoop. -->
      フォントビューでのみ使用可能です。Unicode フォントを作成している時には、他のエフォントに併合したくなることがよくあるでしょう。もちろん、他のフォントからカット&amp;ペーストをすれば可能ですが、たいへん手間がかかるでしょう。それにひきかえ、このコマンドはすべてを一撃で片付けてしまいます。
      <P>
<!--  FontForge does the following when merging CID-keyed fonts: -->
      FontForge は、CID フォントを統合する時には以下の処理を行います。
      <UL>
	<LI>
<!--	  If the font in the window (the mergee) is a normal font and the other font
	  (the merger) is a CID keyed font, then the merger font is effectively flattened
	  and the result merged into the mergee. -->
	  ウィンドウ内のフォント (統合する先) が通常フォントでもう片方のフォント (統合対象) が CID フォントの場合、統合対象のフォントは事実上単一化され、その結果が統合先に送られて統合されます。
	<LI>
<!--	  If the mergee is a CID keyed font and the merger font is a normal font then
	  the merger font will be merged into whichever of the mergee's subfonts is
	  currently active. -->
	  統合先が CID フォントで統合対象が通常フォントの場合、統合先フォントのサブフォントのうち、現在アクティブになっているものに統合対象フォントが送られます。
	<LI>
<!--	  If both are CID keyed fonts, then they should:-->
	  両方が CID フォントの場合、以下の条件を満たしていなければなりません:
	  <UL>
	    <LI>
<!--	      Have the same registry and ordering -->
	      CID レジストリとグリフ集合が同じである
	    <LI>
<!--	      The supplement number of the mergee should be at least as big as that of
	      the merger -->
	      統合先の補遺番号が最低でも統合対象の番号と等しい
	    <LI>
<!--	      The mergee should have at least as many subfonts as the merger. -->
	      統合先のサブフォントの個数が最低でも統合対象のサブフォントの個数と等しい
	  </UL>
	  <P>
<!--	  If these conditions be met then any CIDs from the merger which are not present
	  in the mergee will be merged into the same subfont of the mergee as they
	  came from in the merger. -->
	  これらの条件が満たされる場合、統合先のフォントに存在しない CID をもつグリフが、統合対象のフォントから元と同じ名前のサブフォントに送られます。
	  <P>
<!--	  This strikes me as somewhat problematic, but I can't think of a better solution. -->
	  これはいくぶん問題だと感じますが、より良い解決方法を思い付くことができません。
      </UL>
      <P>
<!--  FontForge will also copy advanced typographic features, kerning, ligatures,
      etc. -->
      FontForge は高度タイポグラフィ機能、カーニング、合字などもコピーします。
    <DT>
<!--  <A NAME="Interpolate">Interpolate</A> Fonts...-->
      フォントの<A NAME="Interpolate">補間(<U>L</U>)...</A>
    <DD>
<!--  Only in the font view. If you have a bold font and a light font and would
      like to create a medium font, then you can interpolate a font between the
      two (or you can extrapolate a font that's even bolder or lighter). Your two
      fonts must have the same sets of glyphs, and each glyph must have the same
      number of paths (ordered similarly) and each path must have the same number
      of points on it, and must have the same references. -->
      フォントビューでのみ使用可能です。ボールドとライトの 2 つのウェイトのフォントがあってそれらを元にミディアムフォントを作成したい場合、2 個の間の中間フォントを補間によって作成することができます (または、さらに太いフォントや細いフォントを補外して作ることもできます)。その 2 つのフォントは同じグリフのセットを含み、各フォントに同じ個数のパスを含み (同じ順序で並んでいて) 各パスには同じ個数の点を含んでいなければならず、含んでいる参照も同じでなければなりません。
      <P>
<!--  Examples: If you are interpolating from a light font to a bold one, then
      a medium font might be 50% between the two, an extra-bold font might be 200%
      and a thin one -100%. -->
      例: ウェイトが light のフォントから bold のフォントへの補間を行った場合、medium のフォントは2 つの中間の 50% にあたり、extra-bold のフォントは 200% に、thin は -100% になるでしょう。
    <DT>
<!--  <A NAME="CompareFonts">Compare Fonts...</A> -->
      <A NAME="CompareFonts">フォントを比較...</A>
    <DD>
<!--  <IMG SRC="fontcompdlg.png" WIDTH="254" HEIGHT="448" ALIGN="Right">Sometimes
      it is useful to compare two versions of a font and see what has changed.
      This command will allow you to check: -->
      <IMG SRC="fontcompdlg.png" WIDTH="220" HEIGHT="335" ALIGN="Right">
      時には、あるフォントの 2 つのバージョンを比較して、どこが変更されたかを確認できると便利なことがあります。このコマンドでは以下の変更をチェックすることができます:
      <UL>
	<LI>
<!--	  The addition or removal of glyphs -->
	  グリフの追加または削除
	<LI>
<!--	  Changes to outline glyphs -->
	  アウトライングリフの変更
	<LI>
<!--	  Changes to bitmap glyphs -->
	  ビットマップグリフの変更
	<LI>
<!--	  Changes to the font's names (truetype 'name' table and some postscript names) -->
	  フォント名の変更 (TrueType の&lsquo;name&rsquo;テーブルといくつかの PostScript 名)
	<LI>
<!--	  Changes to the font's glyph substitutions (ligatures and whatnot) -->
	  フォントの含むグリフ置換 (合字だの何だの) の変更
	<LI>
<!--	  Changes to the font's glyph positioning (kerning and whatnot) -->
	  フォントの含むグリフ位置指定 (カーニングだの何だの) の変更
      </UL>
      <P>
<!--  You can also use it to compare truetype and postscript versions of the same
      font. Normally fontforge checks to make sure all the splines match exactly,
      but you can also have it test whether a contour in one font is always close
      to the similar contour in another font, or whether a contour in one font
      is inside a reference in another (these are common when comparing PostScript
      fonts where the format loses references). -->
      同じフォントの TrueType 版と PostScript 版の比較をすることもできます。通常は FontForge はすべてのスプラインが完全に一致するかどうかを確かめるための検査を行いますが、これを使って、片方のフォントが常にもう片方のフォントの同等な輪郭とどこでもほぼ一致するかどうか、または片方のフォントに含まれる輪郭がもう片方のフォント内の参照に含まれているか (これは、フォーマットが参照を含まない PostScript フォントを比較する時によく起こります) を検査することもできます。
      <P>
<!--
      Comparing PostScript hintmasks is another somewhat iffy topic. There are
      often many equivalent (I think) hint mask possibilities, but I don't have
      a good algorithm for saying that they are equivalent - - especially since
      Adobe uses hints in ways which I find unexpected. -->
      PostScript のヒントマスクの比較もまた、どこと無くあやふやな所のある問題です。(私の考えでは) 等価なヒントマスクを表現する多くの方法が可能であることがしばしばありますが、それらが等価であると示すいいアルゴリズムがありません——思いもよらないようなヒントの使い方を Adobe がしていることに気づいてからはなおのことです。
      <P>
<!--  Finally you can have it place the outlines of each differing glyph from the
      second font into the background of the corresponding glyph in the first font.
      This can be helpful in correcting discrepancies. -->
      そして最後に、比較先のフォントと比較元のフォントで異なるグリフのそれぞれに対し、比較先のフォントの欠落したグリフを比較元のフォントの対応するグリフの背景に配置することができます。これは、矛盾点を修正するのに役立つでしょう。
      <P>
<!--  <IMG SRC="fontcompresults.png" WIDTH="497" HEIGHT="349"> -->
      <IMG SRC="fontcompresults.png" WIDTH="412" HEIGHT="273">
  </DL>
  <P>
  <H2>
<!--Other menus -->
    その他のメニュー
  </H2>
  <UL>
    <LI>
<!--  <A HREF="filemenu.html">File</A>-->
      <A HREF="filemenu.html">ファイル(<U>F</U>)</A>
    <LI>
<!--  <A HREF="editmenu.html">Edit</A>-->
      <A HREF="editmenu.html">編集(<U>E</U>)</A>
    <LI>
<!--  <A HREF="pointmenu.html">Point</A>-->
      <A HREF="pointmenu.html">点(<U>P</U>)</A>
    <LI>
<!--  <A HREF="elementmenu.html">Element</A>-->
      <A HREF="elementmenu.html">エレメント(<U>L</U>)</A>
    <LI>
<!--  <A HREF="hintsmenu.html">Hints</A>-->
      <A HREF="hintsmenu.html">ヒント(<U>I</U>)</A>
      <LI> <A HREF="encodingmenu.html">エンコーディング(<U>N</U>)</A>
    <LI>
<!--  <A HREF="viewmenu.html">View</A>-->
      <A HREF="viewmenu.html">表示(<U>V</U>)</A>
    <LI>
<!--  <A HREF="metricsmenu.html">Metrics</A>-->
      <A HREF="metricsmenu.html">メトリック(<U>M</U>)</A>
    <LI>
      <A HREF="cidmenu.html"><U>C</U>ID</A>
    <LI>
      <A HREF="mmmenu.html">MM</A>
    <LI>
<!--  <A HREF="windowmenu.html">Window</A>-->
      <A HREF="windowmenu.html">ウィンドウ(<U>W</U>)</A>
    <LI>
<!--  <A HREF="helpmenu.html">Help</A>-->
      <A HREF="helpmenu.html">ヘルプ(<U>H</U>)</A>
    <LI>
<!--  <A HREF="HotKeys.html">Hot Keys</A>-->
      <A HREF="HotKeys.html">ホットキー一覧</A>
  </UL>
  <P ALIGN=Center>
  — <A HREF="pointmenu.html">前</A> — <A HREF="overview.html">目次</A> —
  <A HREF="hintsmenu.html">次</A> —
  <P>
</DIV>
</BODY></HTML>
