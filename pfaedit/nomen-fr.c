#include "nomen.h"

static enum encoding enc = e_iso8859_1;

static char str_Language[] = "Français";
static char str_OK[] = "OK";
static unichar_t mnemonic_OK[] = 'O';
static char str_Cancel[] = "Annuler";
static unichar_t mnemonic_Cancel[] = 'A';
static char str_Open[] = "Ouvrir";
static unichar_t mnemonic_Open[] = 'O';
static char str_Save[] = "Enregistrer";
static unichar_t mnemonic_Save[] = 'E';
static char str_Filter[] = "Filtre";
static unichar_t mnemonic_Filter[] = 'F';
static char str_New[] = "Nouveau";
static unichar_t mnemonic_New[] = 'N';
static char str_Replace[] = "Remplacer";
static char str_Fileexists[] = "Le fichier existe";
static char *str_None ="None";
static char mnemonic_None ='N';
/* "File, %s, exists. Replace it?" */
static char str_Fileexistspre[] = "Le fichier, ";
static char str_Fileexistspost[] = ", existe. Le remplacer?";
static char str_Createdir[] = "Créer Répertoire...";
static char str_Dirname[] = "Nom du répertoire?";
static char str_Couldntcreatedir[] = "Ne peux pas créer répertoire";
static char str_File[] = "Fichier";
static unichar_t mnemonic_File[] = 'F';
static char str_Edit[] = "Edition";
static unichar_t mnemonic_Edit[] = 'E';
static char str_Point[] = "Point";
static unichar_t mnemonic_Point[] = 'P';
static char str_Element[] = "Elément";
static unichar_t mnemonic_Element[] = 'l';
static char str_Hints[] = "Hints";
static unichar_t mnemonic_Hints[] = 'H';
static char str_View[] = "Vue";
static unichar_t mnemonic_View[] = 'V';
static char str_Metric[] = "Métriques";
static unichar_t mnemonic_Metric[] = 'M';
static char str_Window[] = "Fenêtre";
static unichar_t mnemonic_Window[] = 'F';
static char str_Help[] = "Aide";
static unichar_t mnemonic_Help[] = 'A';
static char str_Recent[] = "Récent";
static unichar_t mnemonic_Recent[] = 't';
static char str_Openoutline[] = "Ouvrir Contour";
static unichar_t mnemonic_Openoutline[] = 'u';
static char str_About[] = "À propos...";
static unichar_t mnemonic_About[] = 'A';
static char str_Openbitmap[] = "Ouvrir Bitmap";
static unichar_t mnemonic_Openbitmap[] = 'B';
static char str_Openmetrics[] = "Ouvrir Métriques";
static unichar_t mnemonic_Openmetrics[] = 'M';
static char str_Print[] = "Imprimer...";
static unichar_t mnemonic_Print[] = 'P';
static char str_Display[] = "Afficher...";
static unichar_t mnemonic_Display[] = 'D';
static char str_Revertfile[] = "Annuler";
static unichar_t mnemonic_Revertfile[] = 'R';
static char str_Saveas[] = "Enregistrer sous...";
static unichar_t mnemonic_Saveas[] = 'a';
static char str_ExecuteScript[] = "Exécuter un Script...";
static unichar_t mnemonic_ExecuteScript[] = 'x';
static char str_Generate[] = "Créer Polices...";
static unichar_t mnemonic_Generate[] = 'C';
static char str_Import[] = "Importer...";
static unichar_t mnemonic_Import[] = 'I';
static char str_SaveAll[] = "Save All";
static unichar_t mnemonic_SaveAll = 'l';
static char str_Close[] = "Fermer";
static unichar_t mnemonic_Close[] = 'F';
static char str_Prefs[] = "Préférences...";
static unichar_t mnemonic_Prefs[] = 'e';
static char str_Quit[] = "Quitter";
static unichar_t mnemonic_Quit[] = 'Q';
static char str_Fit[] = "Adapter";
static unichar_t mnemonic_Fit[] = 'A';
static char str_Zoomin[] = "Magnifier";
static unichar_t mnemonic_Zoomin[] = 'i';
static char str_Zoomout[] = "Minifier";
static unichar_t mnemonic_Zoomout[] = 'o';
static char str_NextChar[] = "Caractère Suivant";
static unichar_t mnemonic_NextChar[] = 'P';
static char str_PrevChar[] = "Caractère Précédent";
static unichar_t mnemonic_PrevChar[] = 'n';
static char str_Goto[] = "Aller à";
static unichar_t mnemonic_Goto[] = 'A';
static char str_Hidepoints[] = "Cacher les Points";
static unichar_t mnemonic_Hidepoints[] = 'o';
static char str_NextDefChar[] = "Caractère défini suivant";
static unichar_t mnemonic_NextDefChar[] = 'D';
static char str_PrevDefChar[] = "Caractère défini précédent";
static unichar_t mnemonic_PrevDefChar[] = 'a';
static char str_Showpoints[] = "Montrer les Points";
static unichar_t mnemonic_Showpoints[] = 'o';
static char str_Hiderulers[] = "Cacher Règles";
static unichar_t mnemonic_Hiderulers[] = 'R';
static char str_Showrulers[] = "Montrer les Règles";
static unichar_t mnemonic_Showrulers[] = 'R';
static char str_MarkExtrema[] = "Marquer les Extrema";
static unichar_t mnemonic_MarkExtrema[] = 'M';
static char str_Nextpoint[] = "Point Suivant";
static unichar_t mnemonic_Nextpoint[] = 'e';
static char str_Prevpoint[] = "Point Précédent";
static unichar_t mnemonic_Prevpoint[] = 'v';
static char *str_ShowHMetrics="Montrer H. Metrics";
static char mnemonic_ShowHMetrics = 'H';
static char *str_ShowVMetrics="Montrer V. Metrics";
static char mnemonic_ShowVMetrics = 'V';
static char *str_EncodedView="Vue Encodée";
static char mnemonic_EncodedView = 'E';
static char *str_CompactedView="Vue Compactée";
static char mnemonic_CompactedView = 'C';
static char *str_Combinations="Combinaisons";
static char mnemonic_Combinations = 'b';
static char *str_KernPairs="Paires de Crénage";
static char mnemonic_KernPairs = 'K';
static char *str_Ligatures="Ligatures";
static char mnemonic_Ligatures = 'L';
static char *str_FindInFontView="Trouver dans la fenêtre 'police'";
static char mnemonic_FindInFontView = 'V';
static char str_Fill[] = "Remplir";
static unichar_t mnemonic_Fill[] = 'l';
static char str_Select[] = "Sélectionner";
static unichar_t mnemonic_Select[] = 'S';
static char str_DeselectAll[] = "Désélectionner Tout";
static unichar_t mnemonic_DeselectAll[] = 'D';
static char str_FirstPoint[] = "Premier Point";
static unichar_t mnemonic_FirstPoint[] = 'F';
static char str_Undo[] = "Défaire";
static unichar_t mnemonic_Undo[] = 'D';
static char str_Redo[] = "Refaire";
static unichar_t mnemonic_Redo[] = 'R';
static char str_NextControlPoint[] = "Prochain Point de Contrôle";
static unichar_t mnemonic_NextControlPoint[] = 'x';
static char str_PrevControlPoint[] = "Précédent Point de Contrôle";
static unichar_t mnemonic_PrevControlPoint[] = 'r';
static char str_SelectWidth[] = "Largeur";
static unichar_t mnemonic_SelectWidth[] = 'W';
static char str_SelectVWidth[] = "Avance Verticale";
static unichar_t mnemonic_SelectVWidth[] = 'V';
static char str_DeselectWidth[] = "Désélectionner Largeur";
static unichar_t mnemonic_DeselectWidth[] = 'W';
static char str_DeselectVWidth[] = "Désélectionner Avance Verticale";
static unichar_t mnemonic_DeselectVWidth[] = 'V';
static char str_Cut[] = "Couper";
static unichar_t mnemonic_Cut[] = 'p';
static char str_Copy[] = "Copier";
static unichar_t mnemonic_Copy[] = 'C';
static char str_Copywidth[] = "Copier la Largeur";
static unichar_t mnemonic_Copywidth[] = 'g';
static char str_Copyref[] = "Copier Référence";
static unichar_t mnemonic_Copyref[] = 'o';
static char str_CopyVWidth[] = "Copier Avance Verticale";
static unichar_t mnemonic_CopyVWidth[] = 'V';
static char str_CopyLBearing[] = "Copier Espace Gauche";
static unichar_t mnemonic_CopyLBearing[] = 'p';
static char str_CopyRBearing[] = "Copier Espace Droit";
static unichar_t mnemonic_CopyRBearing[] = 'g';
static char str_Paste[] = "Coller";
static unichar_t mnemonic_Paste[] = 'l';
static char str_Clear[] = "Évacuer";
static unichar_t mnemonic_Clear[] = 'E';
static char str_Merge[] = "Amalgamer";
static unichar_t mnemonic_Merge[] = 'M';
static char str_ClearBackground[] = "Effacer l'arrière-plan";
static unichar_t mnemonic_ClearBackground[] = 'B';
static char str_SelectAll[] = "Sélectionner Tout";
static unichar_t mnemonic_SelectAll[] = 'A';
static char str_CopyFgToBg[] = "Premier-plan -> Arrière plan";
static unichar_t mnemonic_CopyFgToBg[] = 'F';
static char str_Unlinkref[] = "Remplacer Référence";
static unichar_t mnemonic_Unlinkref[] = 'R';
static char str_Elide = "Elide";
static char str_Fontinfo[] = "Info de la Police...";
static unichar_t mnemonic_Fontinfo[] = 'P';
static char str_SelectColor[] = "Select Color";
static unichar_t mnemonic_SelectColor[] = 'S';
static char str_RemoveUndoes[] = "Effacer les Undoes";
static unichar_t mnemonic_RemoveUndoes[] = 'e';
static char str_Findprobs[] = "Rechercher Problèmes...";
static unichar_t mnemonic_Findprobs[] = 'o';
static char str_Getinfo[] = "Montrer Info...";
static unichar_t mnemonic_Getinfo[] = 'I';
static char str_Bitmapsavail[] = "Bitmaps Disponibles...";
static unichar_t mnemonic_Bitmapsavail[] = 'A';
static char str_ShowDependents[] = "Montrer les dépendances...";
static unichar_t mnemonic_ShowDependents[] = 'h';
static char str_Regenbitmaps[] = "Régénérer Bitmaps...";
static unichar_t mnemonic_Regenbitmaps[] = 'B';
static char str_Autotrace[] = "Autotrace";
static unichar_t mnemonic_Autotrace[] = 'r';
static char str_Transform[] = "Transformer...";
static unichar_t mnemonic_Transform[] = 'T';
static char str_Stroke[] = "Étendre Ligne...";
static unichar_t mnemonic_Stroke[] = 'E';
static char str_TilePath[] = "Tile Path...";
static unichar_t mnemonic_TilePath[] = 'P';
static char str_Rmoverlap[] = "Effacer Recouvrements";
static unichar_t mnemonic_Rmoverlap[] = 'v';
static char str_Simplify[] = "Simplifier";
static unichar_t mnemonic_Simplify[] = 'S';
static char str_Round2int[] = "Arrondi entier";
static unichar_t mnemonic_Round2int[] = 'I';
static char str_SimplifyMore[] = "Simplifer Plus...";
static char str_CleanupChar[] = "Nettoyer le caractère";
static unichar_t mnemonic_CleanupChar[] = 'n';
static char str_AddExtrema[] = "Ajouter des Extrema";
static unichar_t mnemonic_AddExtrema[] = 'x';
static char str_Align[] = "Aligner";
static unichar_t mnemonic_Align[] = 'l';
static char str_AveragePts[] = "Moyenner les Points";
static unichar_t mnemonic_AveragePts[] = 'A';
static char str_SpacePts[] = "Espacer les Points";
static unichar_t mnemonic_SpacePts[] = 'S';
static char str_SpaceRegions[] = "Espacer Regions...";
static unichar_t mnemonic_SpaceRegions[] = 'R';
static char str_MakeParallel[] = "Rendre Parallèle...";
static unichar_t mnemonic_MakeParallel[] = 'P';
static char str_Buildaccent[] = "Créer Caractères Accentués";
static unichar_t mnemonic_Buildaccent[] = 'u';
static char str_Clockwise[] = "Dans le sens d'une montre";
static unichar_t mnemonic_Clockwise[] = 'o';
static char str_Buildcomposit[] = "Construire un caractère composite";
static unichar_t mnemonic_Buildcomposit[] = 'u';
static char str_Cclockwise[] = "Contre le sens d'une montre";
static unichar_t mnemonic_Cclockwise[] = 'n';
static char str_Correct[] = "Corriger Direction";
static unichar_t mnemonic_Correct[] = 'C';
static char str_Corner[] = "Coin";
static unichar_t mnemonic_Corner[] = 'o';
static char str_Curve[] = "Courbe";
static unichar_t mnemonic_Curve[] = 'C';
static char str_Tangent[] = "Tangent";
static unichar_t mnemonic_Tangent[] = 'T';
static char str_Autohint[] = "AutoHint";
static unichar_t mnemonic_Autohint[] = 'H';
static char str_Clearhstem[] = "Effacer HStem";
static unichar_t mnemonic_Clearhstem[] = 'E';
static char str_FullAutohint[] = "Full AutoHint";
static unichar_t mnemonic_FullAutohint[] = 'H';
static char str_ClearHints[] = "ClearHints";
static unichar_t mnemonic_ClearHints[] = 'C';
static char str_Clearvstem[] = "Effacer VStem";
static unichar_t mnemonic_Clearvstem[] = 'V';
static char str_Cleardstem[] = "Effacer DStem";
static unichar_t mnemonic_Cleardstem[] = 'D';
static char str_Addhhint[] = "Ajouter HHint";
static unichar_t mnemonic_Addhhint[] = 'A';
static char str_Addvhint[] = "Ajouter VHint";
static unichar_t mnemonic_Addvhint[] = 's';
static char str_Adddhint[] = "Ajouter DHint";
static unichar_t mnemonic_Adddhint[] = 't';
static char str_Createhhint[] = "Créer HHint";
static unichar_t mnemonic_Createhhint[] = 'r';
static char str_Createvhint[] = "Créer VHint";
static unichar_t mnemonic_Createvhint[] = 'e';
static char str_Reviewhints[] = "Revoir Hints";
static unichar_t mnemonic_Reviewhints[] = 'R';
static char str_Export[] = "Exporter...";
static unichar_t mnemonic_Export[] = 't';
static char str_MinimumDistance[] = "DistanceMinimum";
static unichar_t mnemonic_MinimumDistance[] = 'M';
static char str_ClearAllMD[] = "Effacer toutes les DM";
static unichar_t mnemonic_ClearAllMD[] = 'C';
static char str_ClearSelXMD[] = "Effacer la DM x sélectionnée";
static unichar_t mnemonic_ClearSelXMD[] = 's';
static char str_ClearSelYMD[] = "Effacer la DM y sélectionnée";
static unichar_t mnemonic_ClearSelYMD[] = 'e';
static char str_ClearWidthMD[] = "Effacer les DM sur la chasse";
static unichar_t mnemonic_ClearWidthMD[] = 'W';
static char str_AddxMD[] = "Ajouter DM x";
static unichar_t mnemonic_AddxMD[] = 'x';
static char str_AddMD2Width[] = "Ajouter DM d'ici à la chasse";
static unichar_t mnemonic_AddxMD[] = 'x';
static char str_AddyMD[] = "Ajouter DM y";
static unichar_t mnemonic_AddyMD[] = 'y';
static char str_RoundX[] = "Arrondir X";
static unichar_t mnemonic_RoundX[] = 'R';
static char str_NoRoundX[] = "Ne Pas Arrondir X";
static unichar_t mnemonic_NoRoundX[] = 'N';
static char str_RoundY[] = "Arrondir Y";
static unichar_t mnemonic_RoundY[] = 'u';
static char str_NoRoundY[] = "Ne Pas Arrondir Y";
static unichar_t mnemonic_NoRoundY[] = 'o';
static char str_Palettes[] = "Palettes";
static unichar_t mnemonic_Palettes[] = 'P';
static char str_Tools[] = "Outils";
static unichar_t mnemonic_Tools[] = 'O';
static char str_Layers[] = "Couches";
static unichar_t mnemonic_Layers[] = 'C';
static char str_Center[] = "Centrer en Largeur";
static unichar_t mnemonic_Center[] = 'C';
static char str_DockedPalettes[] = "Docked Palettes";
static unichar_t mnemonic_DockedPalettes[] = 'D';
static char str_Shades[] = "Shades";
static unichar_t mnemonic_Shades[] = 'S';
static char str_Thirds[] = "Centrer 1/3 avant, 2/3 après";
static unichar_t mnemonic_Thirds[] = 'T';
static char str_Setwidth[] = "Fixer Largeur...";
static unichar_t mnemonic_Setwidth[] = 'L';
static char str_Setlbearing[] = "Fixer Espace Gauche...";
static unichar_t mnemonic_Setlbearing[] = 'B';
static char str_SetVWidth[] = "Fixer l'Avance Verticale...";
static unichar_t mnemonic_SetVWidth[] = 'V';
static char str_Setrbearing[] = "Fixer Espace Droit...";
static unichar_t mnemonic_Setrbearing[] = 'R';
static char str_Removekern[] = "Effacer Kern Pairs";
static unichar_t mnemonic_Removekern[] = 'v';
static char str_Mergekern[] = "Amalgamer Infos Crénage...";
static unichar_t mnemonic_Mergekern[] = 'M';
static char str_24[] = "24 pixel outline";
static unichar_t mnemonic_24[] = '2';
static char str_36[] = "36 pixel outline";
static unichar_t mnemonic_36[] = '3';
static char str_48[] = "48 pixel outline";
static unichar_t mnemonic_48[] = '4';
static char str_Antialias[] = "Anti Alias";
static unichar_t mnemonic_Antialias[] = 'A';
static char str_72[] = "72 pixel outline";
static unichar_t mnemonic_72[] = '7';
static char str_96[] = "96 pixel outline";
static unichar_t mnemonic_96[] = '9';
static char str_Charinfo[] = "Infos Caractère...";
static unichar_t mnemonic_Charinfo[] = 'I';
static char str_CharInfoFor[] = "Infos Caractère de %.40hs";
static char str_Mergefonts[] = "Amalgamer Polices...";
static unichar_t mnemonic_Mergefonts[] = 'M';
static char str_Interp[] = "Interpoler Polices...";
static unichar_t mnemonic_Interp[] = 'I';
static char str_Copyfrom[] = "Copier de";
static unichar_t mnemonic_Copyfrom[] = 'F';
static char str_Allfonts[] = "Toutes les Polices";
static unichar_t mnemonic_Allfonts[] = 'A';
static char str_Displayedfont[] = "Police en vue";
static unichar_t mnemonic_Displayedfont[] = 'V';
static char str_Autokern[] = "Crénage Auto...";
static unichar_t mnemonic_Autokern[] = 'K';
static char str_CharName[] = "Char Name";
static unichar_t mnemonic_CharName[] = 'N';
static char str_Autowidth[] = "Auto Largeur...";
static unichar_t mnemonic_Autowidth[] = 'A';
static char str_Removeallkern[] = "Effacer tous le Crénage";
static unichar_t mnemonic_Removeallkern[] = 'P';
static char str_Outline[] = "Contour";
static unichar_t mnemonic_Outline[] = 'O';
static char str_Showgrid[] = "Exposer Grille";
static unichar_t mnemonic_Showgrid[] = 'G';
static char str_Hidegrid[] = "Cacher Grille";
static unichar_t mnemonic_Hidegrid[] = 'G';
static char str_Bigger[] = "Plus Grand";
static unichar_t mnemonic_Bigger[] = 'G';
static char str_Smaller[] = "Plus Petit";
static unichar_t mnemonic_Smaller[] = 'P';
static char str_Dontsave[] = "Ne Pas Enregistrer";

static char str_Fliph[] = "Symétrie Horizontale";
static unichar_t mnemonic_Fliph[] = 'H';
static char str_Flipv[] = "Symetrie Verticale";
static unichar_t mnemonic_Flipv[] = 'V';
static char str_Rotate90cw[] = "Rotation 90° horaire";
static unichar_t mnemonic_Rotate90cw[] = 'R';
static char str_Rotate90ccw[] = "Rotation 90° anti-horaire";
static unichar_t mnemonic_Rotate90ccw[] = '9';
static char str_Rotate180[] = "Rotation 180°";
static unichar_t mnemonic_Rotate180[] = '1';
static char str_Skew[] = "Incliner...";
static unichar_t mnemonic_Skew[] = 'S';
static char str_MakeFirst = "Make First";
static char mnemonic_MakeFirst = 'k';
static char *str_CID = "CID";
static char mnemonic_CID = 'C';
static char *str_Convert2CID = "Conversion vers CID";
static char mnemonic_Convert2CID = 'C';
static char *str_ConvertByCMap = "Conversion avec CMap";
static char mnemonic_ConvertByCMap = 'M';
static char *str_Flatten = "Mise à plat";
static char mnemonic_Flatten = 'F';
static char *str_FlattenByCMap = "Mise à plat avec CMap";
static char mnemonic_FlattenByCMap = 'a';
static char *str_InsertFont = "Insérer police...";
static char mnemonic_InsertFont = 'o';
static char *str_InsertBlank = "Inséren un Blanc";
static char mnemonic_InsertBlank = 'B';
static char *str_RemoveFont = "Supprimer police";
static char mnemonic_RemoveFont = 'R';
static char *str_CIDFontInfo = "infos police CID...";
static char mnemonic_CIDFontInfo = 'I';

static char *str_Loading = "Chargement...";
static char *str_LoadingFontFrom = "Chargement de la police depuis ";

    /* Font Info dlg */
static char str_Custom[] = "Custom";
static char str_Compacted[] = "Compactée";
static char str_Isolatin1[] = "ISO 8859-1  (Latin1)";
static char str_Isolatin0[] = "ISO 8859-15  (Latin0)";
static char str_Isolatin2[] = "ISO 8859-2  (Latin2)";
static char str_Isolatin3[] = "ISO 8859-3  (Latin3)";
static char str_Isolatin4[] = "ISO 8859-4  (Latin4)";
static char str_Isolatin5[] = "ISO 8859-9  (Latin5)";
static char str_Isolatin6[] = "ISO 8859-10  (Latin6)";
static char str_Isolatin7[] = "ISO 8859-13  (Latin7)";
static char str_Isolatin8[] = "ISO 8859-14  (Latin8)";
static char str_Isocyrillic[] = "ISO 8859-5 (Cyrillique)";
static char str_Koi8cyrillic[] = "KOI8-R (Cyrillique)";
static char str_Isoarabic[] = "ISO 8859-6 (Arabe)";
static char str_Isogreek[] = "ISO 8859-7 (Grec)";
static char str_Isohebrew[] = "ISO 8859-8 (Hebreu)";
static char str_Isothai[] = "ISO 8859-11 (Thai)";
static char str_Mac[] = "Macintosh Latin";
static char str_Win[] = "Windows Latin (\042ANSI\042)";
static char str_Adobestd[] = "Adobe Standard";
static char str_Symbol[] = "Symbol";
static unichar_t str_Texbase[] = { 0x3a4, 0x3b5, 0x3a7, ' Base',  '\0' };
static char str_Unicode[] = "ISO 10646-1 (Unicode, BMP)";
static char str_Unicode4[] = "ISO 10646-1 (Unicode, Full)";
static char str_UnicodePlanes[] = "ISO 10646-? (par plan) ...";
static char str_Jis208[] = "JIS 208 (Kanji)";
static char str_Jis212[] = "JIS 212 (Kanji)";
static char str_SJIS[] = "SJIS (Kanji)";
static char str_Korean[] = "KSC 5601-1987 (Coréen)";
static char str_KoreanJohab[] = "Johab (Coréen)";
static char str_KoreanWansung[] = "Wansung (Coréen)";
static char str_Chinese[] = "GB 2312 (Simp. Chinois)";
static char str_ChineseTrad[] = "Big5 (Trad. Chinois)";
static char str_Reducing[] = "Vous réduisez le nombre de caractères sous le nombre actuel\012. Cela fera disparaître des caractères.\012Est ce vraiment ce que vous souhaitez?";
static char str_Toofew[] = "Trop peu de caractères";
static char str_Badfamilyn[] = "Nom de Famille incorrect, le nom doit commencer par un caractères alphabétique.";
static char str_Badfamily[] = "Nom de Famille incorrect";
static char str_Badascentdescentn[] = "Ascent et Descent doivent être positifs et leur somme ne doit pas dépasser 16384";
static char str_Badascentdescent[] = "Ascent/Descent incorrect";
static char str_Fontinformation[] = "Font Information for %.90hs";
static char str_WhichPlane[] = "Quel plan Unicode:";
static char str_Familyname[] = "Nom de Famille:";
static unichar_t mnemonic_Familyname[] = 'F';
static char str_Fontname[] = "Fontname:";
static unichar_t mnemonic_Fontname[] = 'N';
static char str_Humanname[] = "Nom Humain:";
static unichar_t mnemonic_Humanname[] = 's';
static char str_Encoding[] = "Encodage:";
static unichar_t mnemonic_Encoding[] = 'E';
static char str_Load[] = "Load";
static unichar_t mnemonic_Load[] = 'L';
static char str_Makefromfont[] = "Make From Font";
static unichar_t mnemonic_Makefromfont[] = 'k';
static char str_Remove[] = "Oter";
static unichar_t mnemonic_Remove[] = 'M';
static char str_ForceEncoding[] = "Forcer l'Encodage";
static unichar_t mnemonic_ForceEncoding[] = 'F';
static char str_ForceEncodingPopup[] = "Normallement, changer l'encodage déplace les caractères de leur place courante\nvers la place adéquate dans le nouvel encodage.\nEn cochant cette case, Pfaedit considèrera que les caractères sont déjà à la bonne place,\nmais ont de mauvais noms. Pfaedit renommera tout conformément au nouvel encodage.";
static char str_Italicangle[] = "Italic Angle:";
static unichar_t mnemonic_Italicangle[] = 'I';
static char str_Upos[] = "Position du souligné:";
static unichar_t mnemonic_Upos[] = 'P';
static char str_Uheight[] = "Hauteur:";
static unichar_t mnemonic_Uheight[] = 'H';
static char str_Ascent[] = "Ascent:";
static unichar_t mnemonic_Ascent[] = 'A';
static char str_Descent[] = "Descent:";
static char str_EmSize[] = "Taille Em:";
static unichar_t mnemonic_EmSize[] = 'E';
static char str_ScaleOutlines[] = "Mise à l'échelle Contours";
static unichar_t mnemonic_ScaleOutlines[] = 'S';
static unichar_t mnemonic_Descent[] = 'D';
static char str_Copyright[] = "Copyright:";
static unichar_t mnemonic_Copyright[] = 'r';
static char str_Xuid[] = "XUID:";
static unichar_t mnemonic_Xuid[] = 'X';
static char str_Numchars[] = "Nombre de Caractères:";
static unichar_t mnemonic_Numchars[] = 'N';
static char str_CIDRegistry[] = "CID Registry:";
static char str_Guess[] = "Deviner";
static unichar_t mnemonic_Guess[] = 'G';
static char *str_FamilyNameRequired = "Un nom de Famille est nécessaire";
static char *str_PSNameNotNumber = "Le nom Postscript ne peut pas être un nombre";
static char *str_BadFamilyName = "Nom de Famille de Police incorrect";
static char *str_BadFontName = "Nom de Police incorrect";
static char *str_NameTooLong = "Nom trop long, pas plus de 63 caractères";
static char *str_BadModifierName = "Bad Font Modifier Name";
static char *str_BadPSName = "Un nom Postscript doit être ASCII\net ne doit contenir ni (){}[]<>%%/ ni espace";
static char *str_Names = "Noms";
static char *str_Encoding2 = "Encodage";
static char *str_PSGeneral = "PS General";
static char *str_PSPrivate = "PS Privé";
static char *str_TTFNames = "Noms TTF";
static char *str_TTFValues = "Constantes TTF";
static char *str_Panose = "Panose";
static char *str_Comment = "Commentaire";
static char *str_InvalidEncoding = "Encodage Invalide";
static char *str_UniqueIDC = "UniqueID:";
static char mnemonic_UniqueIDC = 'U';
static char *str_VersionC = "Version:";
static char mnemonic_VersionC = 'V';
static char *str_HasVerticalMetrics = "Has Vertical Metrics";
static char mnemonic_HasVerticalMetrics = 'V';
static char *str_VOrigin = "Origine Verticale:";
static char mnemonic_VOrigin = 'O';
static char str_UniqueIDTitle = "Changer l'UniqueID?"
static char str_UniqueIDChange = "Vous avez changé le nom de cette police, sans changer son UniqueID (où XUID).\nCe n'est probablement pas un bonne idée. Souhaitez vous que je génère\nune nouvelle valeur aléatoire?";
static char str_Change = "Changer";
static char mnemonic_Change = 'h';
static char str_ChangeAll = "Changer Tout ";
static char mnemonic_ChangeAll = 'A';
static char str_RetainAll = "Conserver Tout";
static char mnemonic_RetainAll = 'l';
static char str_Retain = "Conserver";
static char mnemonic_Retain = 'R';
static char *str_Mismatch = "Mélange";
static char *str_MismatchLong = "Vous avez changé une version de %s mais pas celle dans les noms TTF. Voulez reflèter le changement dans le nom TTF?";

    /* Private info */
static char *str_PrivateKey = "Clé Privée";
static char *str_KeyInPrivate = "Clé (du dictionnaire privé)";
static char *str_Add = "Ajouter";
static char mnemonic_Add = 'A';
    /* TTF Values */
static char *str_UltraCondensed = "Ultra-Condensée (50%)"
static char *str_ExtraCondensed = "Extra-Condensée (62.5%)"
static char *str_Condensed75 = "Condensée (75%)"
static char *str_SemiCondensed = "Semi-Condensée (87.5%)"
static char *str_Medium100 = "Medium (100%)"
static char *str_SemiExpanded = "Semi-Élargie (112.5%)"
static char *str_Expanded125 = "Élargie (125%)"
static char *str_ExtraExpanded = "Extra-Élargie (150%)"
static char *str_UltraExpanded = "Ultra-Élargie (200%)"
static char *str_Thin100 = "100 Fine";
static char *str_ExtraLight200 = "200 Extra-Légère";
static char *str_Light300 = "300 Légère";
static char *str_Book400 = "400 Livre";
static char *str_Medium500 = "500 Medium";
static char *str_DemiBold600 = "600 Demi-Gras";
static char *str_Bold700 = "700 Gras";
static char *str_Heavy800 = "800 Heavy";
static char *str_Black900 = "900 Black";
static char *str_EmbeddablePopup = "Cette police peut elle être incluse dans un document (pdf).\nSi oui, qu'est ce qui est permis quant au document et à la police.";
static char *str_Embeddable = "Peut être incluse";
static char mnemonic_Embeddable = 'E';
static char *str_LineGapPopup = "Défini l'interligne à la fois dans les tables OS/2 et hhea";
static char *str_LineGap = "Interligne:";
static char mnemonic_LineGap = 'L';
static char *str_VLineGapPopup = "Défini l'interligne dans la table vhea.\nCela défini l'espace entre 2 colonnes de texte tracé verticalement.";
static char *str_VLineGap = "Column Spacing:";
static char mnemonic_LineGap = 'R';
static char *str_NeverEmbeddable = "Ni inclusion/Ni Edition";
static char *str_OnlyPrint = "Document Imprimable";
static char *str_EditableDoc = "Document Editable";
static char *str_Installable = "Police Installable";
static char *str_NoSubsetting = "Pas de police partielle";
static char *str_NoSubsettingPopup = "Si coché, la totalité de la police doit être incluse\ndans un document si un des caractères est utilisé.\nSi non, l'inclusion peut se limiter au sous-ensemble utilisé.";
static char *str_OnlyBitmaps = "Only Bitmaps";
static char *str_OnlyBitmapsPopup = "Seule les bitmaps peuvent être incluses.\nLes contours vectoriels ne peuvent pas l'être.\n(Si la police ne contiend pas de bitmap, rien ne peut être inclus)";
static char *str_Serif = "Serif";
static char *str_SansSerif = "Sans-Serif";
static char *str_Monospace = "Monospace";
static char *str_Script = "Script";
static char *str_Decorative = "Decorative";
static char *str_Any = "Any";
static char *str_NoFit = "No Fit";
static char *str_TextDisplay = "Text & Display";
static char *str_Pictoral = "Pictoral";
static char *str_Cove = "Cove";
static char *str_ObtuseCove = "Obtuse Cove";
static char *str_SquareCove = "Square Cove";
static char *str_ObtuseSquareCove = "Obtuse Square Cove";
static char *str_Square = "Square";
static char *str_Thin = "Thin";
static char *str_Bone = "Bone";
static char *str_Exaggerated = "Exaggerated";
static char *str_Triangle = "Triangle";
static char *str_NormalSans = "Normal Sans";
static char *str_ObtuseSans = "Obtuse Sans";
static char *str_PerpSans = "Perp Sans";
static char *str_Flared = "Flared";
static char *str_Rounded = "Rounded";
static char *str_VeryLight = "Very Light";
static char *str_Light = "Light";
static char *str_Book = "Book";
static char *str_Medium = "Medium";
static char *str_Demi = "Demi";
static char *str_Bold = "Bold";
static char *str_Heavy = "Heavy";
static char *str_Black = "Black";
static char *str_Nord = "Nord";
static char *str_OldStyle = "Old Style";
static char *str_Modern = "Modern";
static char *str_EvenWidth = "Even Width";
static char *str_Expanded = "Expanded";
static char *str_Condensed = "Condensed";
static char *str_VeryExpanded = "Very Expanded";
static char *str_VeryCondensed = "Very Condensed";
static char *str_Monospaced ="Monospaced";
static char *str_VeryLow ="Very Low";
static char *str_Low ="Low";
static char *str_MediumLow ="Medium Low";
static char *str_MediumHigh ="Medium High";
static char *str_High ="High";
static char *str_VeryHigh ="Very High";
static char *str_GradDiag ="Gradual/Diagonal";
static char *str_GradTrans ="Gradual/Transitional";
static char *str_GradVert ="Gradual/Vertical";
static char *str_GradHor ="Gradual/Horizontal";
static char *str_RapidVert ="Rapid/Vertical";
static char *str_RapidHor ="Rapid/Horizontal";
static char *str_InstantVert ="Instant/Vertical";
static char *str_NormalContact ="Normal/Contact";
static char *str_NormalWeighted ="Normal/Weighted";
static char *str_NormalBoxed ="Normal/Boxed";
static char *str_NormalFlattened ="Normal/Flattened";
static char *str_NormalRounded ="Normal/Rounded";
static char *str_NormalOffCenter ="Normal/Off-Center";
static char *str_NormalSquare ="Normal/Square";
static char *str_ObliqueContact ="Oblique/Contact";
static char *str_ObliqueWeighted ="Oblique/Weighted";
static char *str_ObliqueBoxed ="Oblique/Boxed";
static char *str_ObliqueFlattened ="Oblique/Flattened";
static char *str_ObliqueRounded ="Oblique/Rounded";
static char *str_ObliqueOffCenter ="Oblique/Off-Center";
static char *str_ObliqueSquare ="Oblique/Square";
static char *str_StraightArmsH = "Straight Arms/Horizontal";
static char *str_StraightArmsW = "Straight Arms/Wedge";
static char *str_StraightArmsV = "Straight Arms/Vertical";
static char *str_StraightArmsSS = "Straight Arms/Single Serif";
static char *str_StraightArmsDS = "Straight Arms/Double Serif";
static char *str_NStraightArmsH = "Non-Straight Arms/Horizontal";
static char *str_NStraightArmsW = "Non-Straight Arms/Wedge";
static char *str_NStraightArmsV = "Non-Straight Arms/Vertical";
static char *str_NStraightArmsSS = "Non-Straight Arms/Single Serif";
static char *str_NStraightArmsDS = "Non-Straight Arms/Double Serif";
static char *str_StandardTrimmed = "Standard/Trimmed";
static char *str_StandardPointed = "Standard/Pointed";
static char *str_StandardSerifed = "Standard/Serifed";
static char *str_HighTrimmed = "High/Trimmed";
static char *str_HighPointed = "High/Pointed";
static char *str_HighSerifed = "High/Serifed";
static char *str_ConstantTrimmed = "Constant/Trimmed";
static char *str_ConstantPointed = "Constant/Pointed";
static char *str_ConstantSerifed = "Constant/Serifed";
static char *str_LowTrimmed = "Low/Trimmed";
static char *str_LowPointed = "Low/Pointed";
static char *str_LowSerifed = "Low/Serifed";
static char *str_ConstantSmall = "Constant/Small";
static char *str_ConstantStandard = "Constant/Standard";
static char *str_ConstantLarge = "Constant/Large";
static char *str_DuckingSmall = "Ducking/Small";
static char *str_DuckingStandard = "Ducking/Standard";
static char *str_DuckingLarge = "Ducking/Large";
static char *str_WidthClass ="Width Class";
static char mnemonic_WidthClass ='C';
static char *str_WeightClass ="Weight Class";
static char mnemonic_WeightClass ='W';
static char *str_PFMFamily ="PFM Family";
static char mnemonic_PFMFamily ='F';
static char *str_Family ="Family";
static char mnemonic_Family ='F';
static char *str_Serifs ="Serifs";
static char mnemonic_Serifs ='S';
static char *str_Weight ="Weight";
static char mnemonic_Weight ='W';
static char *str_Proportion ="Proportion";
static char mnemonic_Proportion ='P';
static char *str_Contrast ="Contraste";
static char mnemonic_Contrast ='C';
static char *str_StrokeVar ="Stroke Variation";
static char mnemonic_StrokeVar ='V';
static char *str_ArmStyle ="Arm Style";
static char mnemonic_ArmStyle ='A';
static char *str_Letterform ="Letterform";
static char mnemonic_Letterform ='L';
static char *str_MidLine ="Midline";
static char mnemonic_MidLine ='M';
static char *str_XHeight ="X-Height";
static char mnemonic_XHeight ='X';
    /* TTF Names */
static char *str_Styles = "Styles (SubFamily)";
static char *str_UniqueID = "UniqueID";
static char *str_Version = "Version";
static char mnemonic_Version = 'V';
static char *str_Fullname = "Nom complet";
static char *str_Trademark = "Marque commerciale";
static char *str_Manufacturer = "Fabriquant";
static char *str_Designer = "Dessinateur";
static char *str_Descriptor = "Descripteur";
static char *str_VenderURL = "URL du vendeur";
static char *str_DesignerURL = "URL du dessinateur";
static char *str_License = "License";
static char *str_LicenseURL = "URL de la License";
static char *str_OTFFamily = "Famille Préférée";
static char *str_OTFStyles = "Styles Préférés";
static char *str_CompatableFull = "Compatable Full";
static char *str_SampleText = "Texte de démo";
static char *str_TranslateStyle = "Translate Style";
    /* MS Language list */
/* Language & Country (where applicable) in the native language if I can find */
/*  it, in english if I can't. Followed by the 2char language _ 2char country */
/* (again country isn't always applicable. Should basque be ES, FR? */
static char *str_Albanian = "Albanais sq_AL";
static char *str_Arabic = "Arabe ar";
static char *str_Basque = "Basque eu";
static char *str_Byelorussian = "Biélorusse be_BY";
static char *str_Bulgarian = "Bulgare bg_BG";
static char *str_Catalan = "Catalan ca";
static char *str_MSChinese = "Chinois zh_CN";
static char *str_Croatian = "Croate hr";
static char *str_Czech = "Tchèque cs_CZ";
static char *str_Danish = "Danois da_DK";
static char *str_Dutch = "Pays-Bas nl_NL";
static char *str_Flemish = "Pays-Bas nl_BE";
static char *str_BrEnglish = "Anglais Britannique en_UK";
static char *str_AmEnglish = "Anglais Américain en_US";
static char *str_CaEnglish = "Anglais Canadien en_CA";
static char *str_AuEnglish = "Anglais Australien en_AU";
static char *str_NZEnglish = "Anglais de Nouvelle Zélande en_NZ";
static char *str_IEEnglish = "Anglais d'Irlande en_IE";
static char *str_Estonia = "Estonien et_EE";
static char *str_Finnish = "Finlandais fi_FI";
static char *str_FRFrench = "Français Français fr_FR";
static char *str_BEFrench = "Français Belge fr_BE";
static char *str_CAFrench = "Français Canadien fr_CA";
static char *str_CHFrench = "Français Suisse fr_CH";
static char *str_LUFrench = "Français Luxembourgeois fr_LU";
static char *str_DEGerman = "Allemand Allemand de_DE";
static char *str_CHGerman = "Allemand Suisse de_CH";
static char *str_ATGerman = "Allemand Autrichien de_AT";
static char *str_LUGerman = "Allemand Luxembourgeois de_LU";
static char *str_LIGerman = "Allemand du Liechtenstein de_LI";
static char *str_Greek = "Grec el_GR";
static char *str_Hebrew = "Hébreu he_IL";
static char *str_Hungarian = "Hongrois hu_HU";
static char *str_Icelandic = "Islandais is_IS";
static char *str_Italian = "Italien it_IT";
static char *str_CHItalian = "Italien Suisse it_CH";
static char *str_Japanese = "Japonais jp_JP";
static char *str_Latvian = "Letton lv_LV";
static char *str_Lithuanian = "Lithuanien lt_LT";
static char *str_Norwegian  = "Norvégien Bokmal no_NO";
static char *str_NorwegianN = "Norvégien Nynorsk no_NO";
static char *str_Polish = "Polonais pl_PL";
static char *str_PTPortuguese = "Portugais Portugais pt_PT";
static char *str_BRPortuguese = "Portugais Brésilien pt_BR";
static char *str_Romanian = "Roumain ro_RO";
static unichar_t str_Russian = { 0x420, 0x443, 0x441, 0x441, 0x43a, 0x438, 0x439, ' ', 'r','u','_','R','U',  '\0' };
static char *str_Slovak = "Slovaque sk_SK";
static char *str_Slovenian = "Slovène sl_SI";
static char *str_TradSpanish = "Espagnol Español es_ES";
static char *str_MXSpanish = "Espagnol Méjico es_MX";
static char *str_ModSpanish = "Espagnol Español es_ES";
static char *str_Swedish = "Suédois sv_SE";
static char *str_Turkish = "Turc tr_TR";
static char *str_Ukrainian = "Ukrainien uk_UA";
    /* Generate fonts */ /* savefontdlg */
static char str_Format[] = "Format:";
static char str_Savefailedtitle[] = "Échec de l'enregistrement";
static char str_Outputafm[] = "Créer AFM";
static char str_Outputpfm[] = "Créer PFM";
static char *str_OutputAfmPopup = "Le fichier AFM contient les métriques que de nobreux traitements\nde texte utiliseront s'ils utilisent des polices PostScript\256.";
static char *str_OutputPfmPopup = "Le fichier PFM contient les informations dont Windows\na besoin pour installer une police PostScript\256.";
static char str_AppleMode[] = "Apple";
static char *str_AppleModePopup = "Apple et MS/Adobe divergent quand au format des fichiers truetype et opentype\nCet item vous permet de choisir entre les 2 standards pour votre police."
static char str_Nooutlinefont[] = "Sans Police Vectorielle";
static char str_Nobitmapfonts[] = "Sans Police Bitmap";
static char str_Afmfailedtitle[] = "Échec écriture de l'Afm";
static char str_Pfmfailedtitle[] = "Échec écriture du Pfm";
static char *str_SavingFont = "Enregistrement de la police";
static char *str_SavingPSFont = "Enregistrement police Postscript";
static char *str_SavingMultiplePSFonts = "Enregistrement police Multiple Postscript";
static char *str_SavingTTFont = "Enregistrement police TrueType";
static char *str_SavingCIDFont = "Enregistrement police CID";
static char *str_SavingAFM = "Enregistrement du fichier AFM";
static char *str_SavingPFM = "Enregistrement du fichier PFM";
static char *str_SavingBitmapFonts = "Enregistrement police(s) Bitmap";
static char *str_NotCID = "Ce n'est pas un format CID";
static char *str_NotCIDOk = "Vous essayez d'enregistrer une police CID dans un format\nnon-CID. C'est possible, mais seule la sous-police courante\nsera enregistrée. Est ce vraiment ce que vous souhaitez?";
static char *str_PixelList = "Liste Pixel";
static char *str_EncodingTooLarge="Encodage trop grand";
static char *str_TwoBEncIn1BFont = "Votre police a un encodage sur 2 octets, mais vous essayez de l'enregistrer\ndans un format dont l'encodage est sur 1 octet. Cela fait que vous ne pourrez\npas accèder aux caractères supérieurs à 256 sans ré-encoder la police.\n\nVoulez vous le faire malgré tout?";
static char *str_GreymapDepth = "Bits par Pixel dans la carte des gris"
static char *str_BDFResolution = "BDF Resolution"
static char *str_Other_ = "Autres";
static char *mnemonic_Other_ = "O";
static char *str_GuessResPopup = "Deviner la résolution de chaque police selon la taille des pixels";
static char *str_FindMultipleMap = "Recherche du fichier de définition des sous-polices";
static char *str_NoSubFontDefinitionFile = "Pas de fichier de définition des sous-polices";
static char *str_PSNames = "PS Names";
static char *str_PSNamesPopup = "Voulez vous que le fichier contienne le nom de tous les caractères de la police?";
static char *str_TTFHintsPopup = "Voulez vous que le fichier contienne les hints TrueType? Pour l'instant les hints\ncréés par Pfaedit ne sont pas très bons et vous n'en avez probablement pas besoin."
static char *str_WrongSFDFile = "Type de fichier SFD incorrect";
static char *str_BadSFDFile = "Cela ressemble à un fichier Pfaedit.\nPas à un fichier Tex de sous-police.\nUne confusion d'extension regrettable.";
    /* Goto character ... */
static char str_Badnumberin[] = "Numéro incorrect dans ";
static char str_Enternameofchar[] = "Nom d'un caractère dans la police";
static char str_Couldntfindchar[] = "Caractère introuvable: ";
    /* Font has changed dlg */
static char str_Dontsave[] = "Ne pas Enregistrer";
static unichar_t mnemonic_Dontsave[] = 'D';
static char str_Fontchange[] = "Police modifiée";
/* Font %.70s in file %.70s has been changed.\nDo you want to save it? */
static char str_Fontchangepre[] = "La police ";
static char str_Fontchangemid[] = " dans le fichier ";
static char str_Fontchangepost[] = " a été modifiée.\012Voulez vous l'enregistrer?";
static char str_Fontchangerevertpost[] = " a été modifiée.\012Revenir vous fera perdre toutes les modifications.\012Voulez vous vraiment revenir?";
    /* General messages from fontview.c */
static char str_Revert[] = "Revenir";
static unichar_t mnemonic_Revert[] = 'R';
static char str_Manywin[] = "Beaucoup de fenêtres!";
static char str_Toomany[] = "Cela va ouvrir plus de 10 fenêtres.\012Est ce vraiment ce que vous desirez?";
static char *str_MergeKernInfo = "Fusionner les infos de crénage";
static char *str_OpenPostscript = "Ouvrir une police Postscript";
static char *str_Loading = "Chargement...";
static char *str_LoadingFontFrom = "Chargement d'une police depuis ";
static char *str_ReadingGlyphs = "Lecture des Glyphes";
static char *str_ReadingAFM = "Lecture du fichier AFM";
static char *str_InterpretingGlyphs = "Interprétation des Glyphes";
static char *str_CouldntOpenFontTitle = "Lecture de la police impossible";
static char *str_CouldntOpenFont = "Lecture impossible (ou format incorrect): %.100hs";
static char *str_SaveFailed = "Échec de l'enregistrement";
static char *str_Transforming = "Transformation...";
static char *str_Simplifying = "Simplification...";
static char *str_AddingExtrema = "Ajout de points aux Extrémités...";
static char *str_RemovingOverlap = "Suppression des recouvrements...";
static char *str_CorrectingDirection = "Correction de la Direction...";
static char *str_Rounding = "Arrondi entier...";
static char *str_Autotracing = "Autotraçage...";
static char *str_ClearDependent = "Vous voulez effacer %.30hs qui est référencé par un\nautre caractère. Êtes vous sur de vouloir poursuivre?";
static char *str_UnlinkAll = "Délier Tout";
static char *str_Unlink = "Délier";
static char *str_dPixelBitmap = "%d pixel bitmap";
static char *str_ddPixelBitmap = "%d@%d pixel bitmap";
static char *str_RestrictedRightsFont = "Cette police indique un FSType de 2 (Licence\nrestreinte). Cela signifie qu'elle n'est pas éditable sans\nla permission du propriétaire des droits.\n\nAvez vous cette permission?";
static char *str_RestrictedFont = "Licence restreinte";
static char *str_CloseFont = "SVP fermez cette police";
static char *str_CloseFontForCID = "SVP, fermez %hs avant de l'insérer dans une police CID";
static char *str_CIDRemoveFontCheck = "Êtes vous sur de vouloir supprimer la sous-police %1$.40hs de la police CID %2$.40hs";
static char *str_FlippedRef = "Référence Inversée";
static char *str_FlippedRefUnlink = "%.50hs contient une référence inversée (dont le sens de rotation n'est pas\ncompatible). Cela ne peut pas être corrigé en l'état.\nVoulez vous que Pfaedit la délie et la corrige ensuite?";
static char *str_Baseline = "Ligne de Base";
static char *str_Origin = "Origine";
static char *str_AdvanceWidthAsBar = "Avance montrée par une Barre";
static char *str_AdvanceWidthAsLine = "Avance montrée par une Ligne";
static char *str_AdvanceBarPopup = "Montrer l'avance par une barre sous le caractère\nreprésentant la valeur de l'avance";
static char *str_AdvanceLinePopup = "Montrer l'avance par une ligne\nperpendiculaire à la direction de l'avance";
    /* Messages from accented characters */
static char str_Buildingaccented[] = "Créer les caractères Accentués";
static char str_Replacearing[] = "Replace Å";
static char str_Areyousurearing[] = "Are you sure you want to replace Å?\012The ring will not join to the A.";
static char str_Yes[] = "Oui";
static unichar_t mnemonic_Yes[] = 'O';
static char str_No[] = "Non";
static unichar_t mnemonic_No[] = 'N';
    /* Choices from bitmap editing */
static char str_Rectangle[] = "Rectangle";
static char str_FilledRectangle[] = "Rectangle plein";
static char str_Elipse[] = "Ellipse";
static char str_FilledElipse[] = "Ellipse pleine";
    /* Get Info ... */
static char str_Multiple[] = "Plusieurs";
static char str_AlreadyCharUnicode[] = "Il y a déjà un caractère avec cet encodage Unicode,\012(nommé %$1.40hs, dans l'encodage actuel %$2d)\012Est ce vraiment ce que vous souhaitez?";
static char str_Alreadycharnamed[] = "Il y a déjà un caractère portant ce nom,\012Voulez vous permuter les noms?";
/* There is already a ligature made from these components,\n(named %.10s at local encoding %d)\nIs that what you want? */
static char str_AlreadyLigature[] = "Il y a déjà une ligature  faite avec ces composants,\012(appelée %1$.40hs dans l'encodage courant %2$d")\012Est ce vraiment ce que vous souhaitez?";
static char str_Badligature[] = "Une ligature ne peut pas se composer d'elle même";
/* "The component %.20s is not in this font,\nIs that what you want?" */
static char str_MissingComponent[] = "Le composant \"%.40s\" n'est pas dans cette police,\012Est ce vraiment ce que vous souhaitez?";
static char str_Done[] = "Done";
static unichar_t mnemonic_Done[] = 'D';
static char str_Ligpop[] = "Si ce caractère doit être une ligature,\012indiquez le nom des caractères dont il se compose";
static char *str_Show[] = "Montrer";
static unichar_t mnemonic_Show[] = 'S';
static char *str_PointInfo = "Point Info";
static char *str_ImageInfo = "Image Info";
static char *str_ReferenceInfo = "Référence Info";
static char *str_Dependents = "Dépendances";
static char *str_Offset = "Offset";
static char *str_BaseX = "Base X";
static char *str_BaseY = "Base Y";
static char *str_NextCP = "Suiv. CP:";
static char *str_NextCPX = "Suiv. CP X";
static char *str_NextCPY = "Suiv. CP Y";
static char *str_PrevCP = "Préc. CP:";
static char *str_PrevCPX = "Préc. CP X";
static char *str_PrevCPY = "Préc. CP Y";
static char *str_UnicodeName = "Nom Unicode:";
static char mnemonic_UnicodeName = 'N';
static char *str_UnicodeValue = "Valeur Unicode:";
static char mnemonic_UnicodeValue = 'V';
static char *str_UnicodeChar = "Car. Unicode:";
static char mnemonic_UnicodeChar = 'h';
static char *str_SetFromName = "Fait avec les noms";
static char mnemonic_SetFromName = 'a';
static char *str_SetFromValue = "Fait avec les valeurs";
static char mnemonic_SetFromValue = 'u';
static char *str_Ligature = "Ligature:";
static char mnemonic_Ligature = 'L';
static char *str_AccentedComponents = "Caractère accentué composé de:";
static char *str_CompositComponents = "Caractère composé de:";
static char *str_NoComponents = "Pas de composantes";
static char *str_Color = "Couleur:";
static char *str_TransformedBy = "Transformé avec:";
static char *str_NotUnicodeBMP = "Attention: cette valeur n'est pas dans la BMP Unicode.\nEst ce vraiment ce que vous souhaitez?";
static char *str_PossiblyTooBig = "Valeur peut-être hors limites";
static char *str_OutOfRange = "Valeur hors limites";
static char *str_TransformationMatrix = "Matrice de Transformation";
static char *str_TransformChanged = "Matrice de Transformation modifiée";
static char *str_TransformChangedApply = "Vous avez modifié la matrice de transformation, souhaitez vous utiliser sa nouvelle définition?";
static char *str_TransformPopup = "La matrice de transformation spécifie comment les points\n dans le caractère source doivent être transformés avant d'être\ninclus dans le nouveau caractère.\n x(nouveau) = tm[1,1]*x + tm[2,1]*y + tm[3,1]\n y(nouveau) = tm[1,2]*x + tm[2,2]*y + tm[3,2]";
    /* Import */
static char str_Duppixelsize[] = "Taille de pixel dupliquée";
/* "The font database already contains a bitmap\nfont with this pixelsize (%d)\nDo you want to overwrite it?" */
static char str_Duppixelsizepre[] = "La police contiend déja de bitmaps de cette\ntaille (";
static char str_Duppixelsizepost[] = ")\012Voulew vous l'écraser?";
static char str_NoBitmapFont = "Pas de police Bitmap";
static char str_NoBitmapFontIn = "Pas de police Bitmap dans%hs";
    /* Private Info */
static char str_Bluequest[] = "Cela va changer à la fois BlueValues et OtherBlues.\012Voulez vous continuer?";
static char str_Hstemquest[] = "Cela va changer à la fois StdHW et StemSnapH.\012Voulez vous continuer?";
static char str_Vstemquest[] = "Cela va changer à la fois StdVW et StemSnapV.\012Voulez vous continuer?";
static char str_Arrayquest[] = "Tableau attendu\012Continuer malgré tout?";
static char str_Numberquest[] = "Nombre attendu\012Continuer malgré tout?";
static char str_Boolquest[] = "Booléen attendu\012Continuer malgré tout?";
static char str_Codequest[] = "Code Attendu\012Continuer malgré tout?";
static char str_Badtype[] = "Type incorrect";
static char str_Delete[] = "Détruire";
static char mnemonic_Delete[] = 'D';
    /* Prefs */
static char str_Default[] = "Défaut";
static char *str_PrefsPopupAWS[] = "Changer la largeur d'un caractère changera\nla largeur de tous les caractères accentués\ncomposés à partir de celui ci.";
static char *str_PrefsPopupALS[] = "Changer l'espace gauche gauche d'un caractère modifiera\nl'espace gauche gauche de tous les caractères accentués\ncomposés à partir de celui ci";
static char *str_PrefsPopupForNewFonts[] = "Encodage par défaut\npour les nouvelles polices";
static char *str_PrefsPopupLoc[] = "Jeu de caractères utilisé par le presse-papier,\nle système de fichiers, etc. (seuls les jeux à 8\nbits sont supportés ici)";
static char *str_PrefsPopupAH[] = "AutoHint avant rastérisation";
static char *str_PrefsPopupFN[] = "Nom utilisé pour le champ Fondeur pour\nla création des polices BDF";
static char *str_PrefsPopupTFN[] = "Nom utilisé comme Identifiant Vendeur\npour la création des polices ttf (table OS/2).\nQuatre caractères maximum";
static char *str_PrefsPopupXU[] = "Si spécifiée, doit être une liste d'entiers séparés par des espaces, tous\ninférieurs à 16777216, qui identifie votre organisation de manière unique\nPfaEdit génèrera un nombre aléatoire pour la dernière valeur.";
static char *str_PrefsPopupRulers[] = "Montre les règles dans la vue 'caractère'";
static char *str_PrefsPopupSepHints[] = "Contrôles séparés pour les hints horizontaux et verticaux.";
static char *str_PrefsPopupIC[] = "Dans la fenêtre Outline, la touche Shift force un déplacement à\nêtre parallèle à l'inclinaison des italiques plutôt qu'à la verticale.";
static char *str_PrefsPopupAO[] = "Pourcentage d'un em pour séparer un accent de son caractère\nde base avec la commande 'Créer caractères accentués'";
static char *str_PrefsPopupGA[] = "Lorsqu'il met un accent grave ou aigu sur une lettre, PfaEdit\ndoit il le centrer en tenant compte de sa largeur ou doit il le\ncentrer en tenant compte du point le plus bas de l'accent?";
static char *str_PrefsPopupAA[] = "Nombre de em dont les flèches de déplacement\nvont bouger le point sélectionné";
static char *str_PrefsPopupGF[] = "Adobe a affecté les noms Delta, Omega et mu aux signes\nIncrément, Ohm et micro respectivement.\nCela semble très étrange aux dessinateurs de polices grecques\nqui utilisent les noms pour les lettres de l'alphabet.\nLes noms sont donc ambigus. Pfaedit contourne l'ambiguïté\nen créant des polices avec des glyphes supplémentaires.";
static char *str_PrefsPopupSD[] = "Spécifie la distance à laquelle le pointeur de la souris doit\nêtre près d'une ligne remarquable (ligne de base, largeur,\ngrille, splines, etc...), pour  sauter automatiquement dessus.";
static char *str_PrefsPopupBR[] = "Lors de la création d'un ensemble de polices BDF,\nPfaedit doit il demander la résolution écran, ou\nla deviner en fonction de la taille du pixel?";
static char *str_PrefsPopupATA[] = "Paramètres supplémentaires à passer à 'autotrace'";
static char *str_PrefsPopupATK[] = "Demander à l'utilisateur les paramètres pour 'autotrace' à chaque utilisation"
static char *str_PrefsPopupMFA[] = "Commandes à passer au programme 'mf' (metafont), le nom de fichier sera mis après";
static char *str_PrefsPopupMFK[] = "Demander à l'utilisateur les paramètres pour 'mf' à chaque utilisation"
static char *str_PrefsPopupMFB[] = "PfaEdit charge de grandes images en arrière plan des caractères\navant de les autotracer. Vous pouvez conserver ces images pour\nexaminer le résultat produit par 'mf', ou les enlever pour\néconomiser de la place"
static char *str_PrefsPopupMFE[] = "MetaFont (mf) produit beaucoup de verbiage sur stdout.\nLa plupart du temps, c'est sans importance, sauf lorsque quelque chose se passe mal."
static char *str_PrefsPopupG2N[] = "Lors de la création d'une police truetype ou opentype, il est parfois utile\nde connaitre la correspondance entre les ids des glyphes truetype et\nle nom des caractères. Cette option fait produire à PfaEdit un fichier\n(avec comme extension .g2n) contenant ces informations.";
static char *str_Generic[] = "Généralités";
static char *str_PrefsFontInfo[] = "Font Info";
static char *str_PrefsApps[] = "Arguments";
static char *str_ScriptMenu[] = "Menu Script";
static char *str_MenuName[] = "Nom du Menu";
static char *str_ScriptMenuPopup[] = "Vous pouvez créer un menu de scripts contenant jusqu'à 10 entrées.\nChaque entrée doit comporter un nom à afficher et un nom de script\nà exécuter. Le nom du menu peut contenir n'importe quels caractères Unicode.\nLe bouton marqué \"...\" permet de rechercher un fichier de script à exécuter.";
static char *str_ScriptFile[] = "Fichier de Script";
static char *str_BrowseForFile[] = "...";
static char *str_MenuNameWithNoScript[] = "Item du menu sans script associé";
static char *str_ScriptWithNoMenuName[] = "Script sans entrée dans le menu";
    /* Hints */
static char *str_base = "Base:";
static unichar_t mnemonic_base = 'B';
static char *str_size = "Taille:";
static unichar_t mnemonic_size = 'S';
static char *str_HStem = "HStem";
static unichar_t mnemonic_HStem = 'H';
static char *str_VStem = "VStem";
static unichar_t mnemonic_VStem = 'V';
static char *str_Create = "Créer";
static unichar_t mnemonic_Create = 'e';
static char *str_PrevArrow = "< Préc.";
static unichar_t mnemonic_PrevArrow = 'P';
static char *str_NextArrow = "Suivant >";
static unichar_t mnemonic_NextArrow = 'N';
static char *str_MovePoints = "Move Points";
static unichar_t mnemonic_MovePoints = 'M';
static char *str_MovePointsPopup = "When the hint's position is changed\nadjust the postion of any points\nwhich lie on that hint";
static char *str_CreateHint = "Create Hint...";
static char *str_CreateHorizontalHint = "Créer un Hint de jambage Horizontal";
static char *str_CreateVerticalHint = "Créer un Hint de jambage Vertical";
    /* expand stroke */
static char *str_LineCap = "Line Cap";
static char *str_Butt = "Butt";
static unichar_t mnemonic_Butt = 'B';
static char *str_Round = "Round";
static unichar_t mnemonic_Round = 'R';
static char *str_Squareq = "Square";
static unichar_t mnemonic_Squareq = 'q';
static char *str_LineJoin = "Line Join";
static char *str_Miter = "Miter";
static unichar_t mnemonic_Miter = 'M';
static char *str_Roundu = "Round";
static unichar_t mnemonic_Roundu = 'u';
static char *str_Bevel = "Bevel";
static unichar_t mnemonic_Bevel = 'v';
static char *str_StrokeWidth = "Stroke Width:";
static unichar_t mnemonic_StrokeWidth = 'W';
static char *str_Strok = "Stroke";
static unichar_t mnemonic_Stroke = 'S';
static char *str_Caligraphic = "Calligraphie";
static unichar_t mnemonic_Caligraphic = 'C';
static char *str_PenAngle = "Angle Plume:";
static unichar_t mnemonic_PenAngle = 'A';
static char *str_BadStroke = "Bad Stroke";
static char *str_StrokeWidthTooBig = "La largeur du trait est si grande que le chemin créé va\nse couper lui même en %.100hs";
    /* Auto Width/Kern */
static char *str_EnterTwoCharRange = "Entrez 2 groupes de caractères";
static char *str_ToBeAdjusted = "à ajuster.";
static char *str_CharsLeft = "Caractères à Gauche";
static char *str_CharsRight = "Caractères à Droite";
static char *str_All = "All";
static char *str_stdCharRange = "A-Za-z0-9";
static char *str_StdCharRangeKernL = "A-Za-z";
static char *str_StdCharRangeKernR = "a-z.,:;-";
static char *str_Selected = "Selected";
static char *str_Spacing = "Espacement";
static char *str_TotalKerns = "Total Kerns:";
static char *str_Threshold = "Seuil:";
static char *str_NoCharsSelected = "Aucun caractère sélectionné.";
static char *str_KernPairFilePopup = "Rechercher un fichier contenant une liste de paires de crénage\nDeux caractères par ligne. PfaEdit considèrera seulement ces paires\npour les infos de crénage.";
static char *str_LoadKernPairs = "Chargement des paires de crénage";
static char *str_NoKernPairs = "Aucune paires de crénage";
static char *str_NoKernPairsFile = "Aucune paire de crénage trouvée dans %.200hs";
    /* Auto Trace */
static char *str_NothingToTrace = "Rien à tracer";
static char *str_NoAutotrace = "Impossible de lancer autotrace";
static char *str_NoAutotraceProg = "Impossible de trouver le programme 'autotrace'.\nVous pouvez peut-être positionner la variable d'environnement AUTOTRACE.";
static char *str_AdditionalAutotraceArgs = "Arguments additionnels pour le programme autotrace:";
static char *str_NoMF = "Mf pas trouvé";
static char *str_NoMFProg = "Impossible de trouver mf-- metafont => variable d'environnement MF, ou télécharger depuis:\n  http://www.tug.org/\n  http://www.ctan.org/\nC'est inclus dans la distribution de TeX";
static char *str_NoTempDir = "Impossible de créer le répertoire temporaire";
static char *str_CantRunMF = "Impossible de lancer mf";
static char *str_MFHadError = "MetaFont s'est fini en erreur";
static char *str_MFBadOutput = "Impossible de lire (ou de trouver) le fichier de sortie de mf";
    /* Bitmap dlg */
static char *str_AllChars = "Tous les caractères";
static char *str_SelChars = "Les caractères sélectionnés";
static char *str_CurChar = "Le caractère courant";
static char *str_BadRegenSize = "Essai de génération d'une taille de pixel qui n'a pas été créée: ";
static char *str_PixelSizes = "Taille de Pixel:";
static char *str_listPixelSizes = "Liste des tailles actuelles des bitmaps";
static char *str_RemovingSize = " Effacer une taille la supprimera.";
static char *str_AddingSize = " Ajouter une taille la créera.";
static char *str_AddingSizeScale = " Ajouter une taille la créera par mise à l'échelle.";
static char *str_SpecifyRegenSizes = "Spécifez les tailles à régénérer";
static char *str_PointSizes75  = "Taille du Point sur un écran à 75 dpi";
static char *str_PointSizes100 = "Taille du Point sur un écran à 100 dpi";
static char *str_PointSizes96  = "Taille du Point sur un écran à 96 dpi";
static char *str_PointSizes120 = "Taille du Point sur un écran à 120 dpi";
static char *str_PointSizes72  = "Taille du Point sur un écran à 72 dpi";
static char *str_XSizes = "X";
static char *str_WinSizes = "Win";
static char *str_MacSizes = "Mac";
static char *str_UseFreeType = "Utiliser FreeType";
static char *str_ScalingBitmaps = "Mise à l'échelle des bitmaps";
static char *str_CantScaleGreymap = "Impossible de mettre à l'échelle une police avec des niveaux de gris";
static char *str_CantDeleteAllBitmaps = "Impossible de supprimer toutes les bitmaps";
    /* Bitmap view */
/* "%s at %d size %d from %s", charactername, encoding, pixelsize, fontname */
static char *str_BvTitle = "%1$.75hs à %2$d taille %3$d venant de %4$.75hs"
static char *str_RecalculateBitmaps = "Recalculer Bitmaps";
    /* BV Edit */
static char *str_skewRatio = "Entrer le rapport x:y de l'inclinaison";
static char str_BadNumber[] = "Valeur incorrecte";
    /* Char View */
/* "%s at %d from %s", charactername, encoding, fontname */
static char *str_CvTitle = "%1$.80hs à %2$d venant de %3$.80hs"
    /* CV Export */
static char *str_PixelSizeQ = "Pixel size?";
static char *str_PixelSize = "Pixel size:";
static char *str_BitsPerPixel = "Bits/Pixel:";
static char *str_InvalidBits = "Les seules valeurs autorisées pour les bits/pixel sont 1, 2, 4 et 8";
    /* CV Images */
static char *str_CantFindFile = "Impossible de trouver le fichier";
static char *str_BadXFigFile = "Fichier XFIG incorrect";
static char *str_BadImageFile = "Fichier image incorrect";
static char *str_BadImageFileName = "Fichier image incorrect: %.100hs";
static char *str_BadImageFileNotBitmap = "Fichier image incorrect, pas une bitmap: %.100hs";
static char *str_NothingLoaded = "Rien n'a été chargé";
static char *str_NothingSelected = "Rien n'est sélectionné";
static char *str_MoreImagesThanSelected = "Plus d'images que de caractères sélectionnés";
static char *str_BadTemplate = "Motif incorrect";
static char *str_BadTemplateNoExtension = "Motif incorrect, pas d'extension";
static char *str_BadTemplateUnrecognized = "Motif incorrect, format non reconnu";
static char *str_UnicodeNotInFont = "Valeur Unicode absente de la police";
static char *str_UnicodeValueNotInFont = "Valeur Unicode (%x)  absente de la police, ignorée";
static char *str_EncodingNotInFont = "Valeur de l'encodage absente de la police";
static char *str_EncodingValueNotInFont = "Valeur de l'encodage (%x) absente de la police, ignorée";
static char *str_Image = "Image";
static char *str_TeXBitmap = "Bitmap TeX";
static char *str_Template = "Motif "Image\"";
static char *str_EPSTemplate = "Motif EPS";
static char *str_AsBackground = "En arrière-plan";
static char *str_OnlyOneFont = "Seulement une police";
static char *str_OnlyOneFontBackground = "Une seule police peut être importée en arrière-plan";
    /* CV Palettes */
static char *str_SizeOfPoints="Taille des Points";
static char *str_Regular="Regular";
static char *str_Points="Points:";
static char *str_RRRad="Round Rectangle Radius";
static char *str_Polygon="Polygon";
static char *str_Star="Star";
static char *str_NumPSVert="Nombre de sommets (étoile) ou de cotés (polygone)";
/* V is an abbreviation for "Visible", and E for Editable */
static char *str_V="V";
static char *str_E="E";
static char *str_Layer="Calque";
static char *str_IsEdit="Ce calque est-il Éditable?";
static char *str_IsVis="Ce calque est-il Visible?";
/* For Foreground. Should be short */
static char *str_Fore="Premier-plan";
static char *str_Back="Arrière-plan";
static char *str_Grid="Guide";
static char *str_HHints="HHints";
static char *str_VHints="VHints";
static char *str_DHints="DHints";
static char *str_HMetrics="HMetrics";
static char *str_VMetrics="VMetrics";
static char *str_Blues="Bleues";
static char *str_Bitmap="Bitmap";
static char *str_ShapeType = "Type de la Forme";
/* Popups */
static char *str_Pointer = "Pointer";
static char *str_PopMag = "Agrandir (Rétrécir avec alt)";
static char *str_AddCurvePoint = "Ajouter un point courbe";
static char *str_AddCornerPoint = "Ajouter un point angulaire";
static char *str_AddTangentPoint = "Ajouter un point tangeant";
static char *str_AddPenPoint = "Ajouter un point, puis tirer ses points de contôle";
static char *str_popKnife = "Scinder la courbe";
static char *str_popRuler = "Mesurer la distance ou l'angle entre 2 points";
static char *str_popScale = "Mettre à l'échelle la sélection";
static char *str_popFlip = "Flip the selection";
static char *str_popRotate = "Pivoter la sélection";
static char *str_popSkew = "Pencher la sélection";
static char *str_popRectElipse = "Rectangle ou Ellipse";
static char *str_popPolyStar = "Polygone ou Étoile";
static char *str_popPencil = "Mettre/Effacer des Pixels";
static char *str_popLine = "Tracer une ligne";
static char *str_popShift = "Glisser toute la Bitmap";
static char *str_popHand = "Défiler la vue de la Bitmap";
    /* Undoes */
static char *str_BitmapPaste = "Coller Bitmap";
static char *str_YesToAll = "Oui à Tout";
static char *mnemonic_YesToAll = 'A';
static char *str_NoToAll = "Non à Tout";
static char *mnemonic_NoToAll = 'o';
/* "The clipboard contains a bitmap character of size %d,\na size which is not in your database.\nWould you like to create a bitmap font of that size,\nor ignore this character?" */
static char *str_ClipContainsPre = "Le presse-papier contiend un caractère bitmap de taille ";
static char *str_ClipContainsPost = ",\ntaille qui n'est pas parmi les valeurs actuelles.\nVoulez vous créer une police bitmap de cette taille,\nou ignorer ce caractère";
static char *str_Pasting = "Coller...";
static char *str_SelfRef = "Caractère avec auto-référence"
static char *str_AttemptSelfRef = "Vous essayez de créer un caractère qui se référence lui même";
static char *str_BadReference = "Référence incorrecte";
static char *str_FontNoRef = "Vous essayer de coller une référence vers %1$hs dans %2$hs.\nMais %1$hs n'existe pas dans cette police.\nVoulez vous copier la courbe d'origine, ou supprimer la référence?";
static char *str_FontNoRefNoOrig = "Vous essayer de coller une référence vers %1$hs dans %2$hs.\nMais %1$hs n'existe pas dans cette police, et Pfaedit ne trouve pas le caractère auquel il se référait.\nLe caractère ne sera pas copié.";
static char *str_DontWarnAgain = "Ne pas avertir à nouveau";
static char *mnemonic_DontWarnAgain = 'W';
static char *str_NoVerticalMetrics = "Pas de Métriques Verticales";
static char *str_FontNoVerticalMetrics = "Les métriques verticales ne sont pas activées dans cette police";
    /* dump pfa */
static char *str_CvtPS = "Converting Postscript";
    /* encoding */
static char *str_BadEncFormat = "Format du fichier d'encodage incorrect";
static char *str_PleaseNameEnc = "SVP, nommez cet encodage";
/* Either insert first, second or third, or the number followed by the "th" string (5th, 6th, etc.) */
/* Please name the %d/first/second/third encoding in this file" */
static char *str_PleaseNameEncPre = "SVP, donnez un nom au ";
static char *str_PleaseNameEncPost = " encodage dans ce fichier";
static char *str_First = "premier";
static char *str_Second = "second";
static char *str_Third = "troisième";
static char *str_th = "ième";
static char *str_RemoveEncoding = "Suppression de l'encodage";
static char *str_LoadEncoding = "Chargement de l'encodage";
static char *str_UseCidMap = "utilisation de la map CID";
static char *str_SearchForCIDMap = "Cette police est basée sur le jeu de caractère %1$.20hs-%2$.20hs-%3$d, mais ce que j'ai troiuvé de mieux c'est %1$.20hs-%2$.20hs-%4$d.\nUtiliserai-je cette valeur ou préférez vous chercher?";
static char *str_UseIt = "Utilisez la";
static char mnemonic_UseIt = 'U';
static char *str_Search = "Chercher";
static char mnemonic_Search = 'S';
static char *str_GiveUp = "Abandonner";
static char mnemonic_GiveUp = 'G';
static char *str_NoCidmap = "Pas de fichier cidmap..."
static char *str_LookForCidmap = "PfaEdit n'a pas réussi à trouver un fichier de map cid pour cette police. Ce n'est pas indispensable, mais certaines choses marcheaient mieux avec. Si vous n'en avez pas, vous pourriez télécharger des maps cid depuis:\n   http://pfaedit.sourceforge.net/cidmaps.tgz\net les installer, décompressées et détarrées dans:\n  %.80hs\n\nVoudriez vous rechercher un fichier approprié sur votre disque local?"
static char *str_AreYouSureCharset = "Êtes vous sur de ne pas vouloir utiliser la map cid que j'ai trouvé?";
static char *str_FindCharset = "Recherche d'un fichier  de table CID..."
static char *str_Browse = "Recherche...";
static char mnemonic_Browse = 'B';
static char *str_SelectCIDOrdering = "SVP, sélectionnez une table CID"
static char *str_ExtraCharsTitle = "Caractères sur-numéraires";
static char *str_ExtraChars = "L'encodage actuel contient des caractères que Pfaedit ne sait pas mapper vers CID.\nFaut-il les détruire ou les ajouter à la fin (ce qui pourra poser problème avec de future définitions)?";
static char *str_FindCMap = "Recherche d'un fichier Adobe CMap...";
static char *str_NotACIDFont = "Cette police n'est pas CID-encodée";
static char *str_MultipleEncodingIgnored = "EncodagesMultiplesIgnorés";
static char *str_CIDGlyphMultEncoded = "Le glyphe en CID %d est mappé vers plus de %d encodages. Seuls les %d premiers seront pris en compte.";

    /* fv composit */
static char *str_MissingChar = "Caractère manquants...";
static char *str_Missingdotlessi="Votre police ne contient pas de caractère dotlessj.\nSVP, ajoutez en un et refaites vos caractères accentués";
static char *str_Missingdotlessj="Votre police ne contient pas de caractère dotlessj.\nSVP, ajoutez en un et refaites vos caractères accentués";
    /* fv fonts */
static char *str_MergingProb = "Problème de fusion";
static char *str_MergingFontSelf = "Fusionner une police avec elle même ne conduit à rien";
static char *str_Other = "Autre ..."
static char *str_FontToMergeInto = "Police à fusionner avec %.20hs";
static char *str_InterpolatingProb = "Problème d'interpolation";
static char *str_InterpolatingFontSelf = "Interpoler une police avec elle même ne conduit à rien";
static char *str_Amount = "Quantité";
static char *str_InterpBetween = "Interpolation entre %.20hs et:";
static char *str_by = "de";
    /* fv metrics */
static char *str_SetWidthTo      = "Fixer largeur:";
static char *str_SetLBearingTo   = "Fixer Espace Gauche:";
static char *str_SetRBearingTo   = "Fixer Espace Droit:";
static char *str_SetVWidthTo     = "Fixer Avance Verticale:";
static char *str_IncrWidthBy     = "Augmenter largeur:";
static char *str_IncrLBearingBy  = "Augmenter Espace Gauche:";
static char *str_IncrRBearingBy  = "Augmenter Espace Droit:";
static char *str_IncrVWidthBy    = "Augmenter Avance Verticale:";
static char *str_ScaleWidthBy    = "Coefficient largeur:";
static char *str_ScaleLBearingBy = "Coefficient Espace Gauche:";
static char *str_ScaleRBearingBy = "Coefficient Espace Droit:";
static char *str_ScaleVWidthBy   = "Coefficient Avance Verticale:";
    /* Import bdf */
static char *str_PixelSizeFont = "Quelle est la taille en pixel de la police contenue dans ce fichier?";
static char *str_CouldNotOpenFile = "Lecture du fichier impossible"
static char *str_CouldNotOpenFileName = "Impossible de lire le fichier %.200hs"
static char *str_NotBdfFile = "Pas un fichier BDF"
static char *str_NotBdfFileName = "Pas un fichier BDF %.200hs"
static char *str_NotPkFile = "Pas un fichier PK"
static char *str_NotPkFileName = "Pas un fichier PK (metafont) %.200hs"
static char *str_NotGfFile = "Pas un fichier GF"
static char *str_NotGfFileName = "Pas un fichier GF (metafont) %.200hs"
static char *str_NotPcfFile = "Pas un fichier PCF"
static char *str_NotPcfFileName = "Pas un fichier PCF X11 %.200hs"
static char *str_LoadingFrom = "Chargement depuis %.100hs";
static char *str_DuplicateName = "Nom Dupliqué";
static char *str_DuplicateCharName = "Nom de caractère (%hs) dupliqué dans la police";
    /* problems */
static char *str_ProbOpenPath = "Les 2 points sélectionnés sont les extrémités d'une courbe ouverte";
static char *str_ProbPointsTooClose = "Les 2 points sélectionnés sont trop proches";
static char *str_ProbMissingExtreme = "La courbe sélectionnée n'a pas de point à au moins l'une de ses extrémités";
static char *str_ProbXNear = "La coordonnée en X du point sélectionné est proche de la valeur de consigne";
static char *str_ProbYNear = "La coordonnée en Y du point sélectionné est proche de la valeur de consigne";
static char *str_ProbYBase = "La coordonnée en Y du point sélectionné est proche de la ligne de base";
static char *str_ProbYXHeight = "La coordonnée en Y du point sélectionné est proche de la hauteur X";
static char *str_ProbYCapHeight = "La coordonnée en Y du point sélectionné est proche de la hauteur des majuscules";
static char *str_ProbYAs = "La coordonnée en Y du point sélectionné est proche de l'ascender height";
static char *str_ProbYDs = "La coordonnée en Y du point sélectionné est proche du descender height";
static char *str_ProbLineHor  = "Le segment sélectionné est presque horizontal";
static char *str_ProbLineVert = "Le segment sélectionné est presque vertical";
static char *str_ProbLineItal = "Le segment sélectionné est proche de l'inclinaison des italiques";
static char *str_ProbAboveHor  = "Le point de contrôle au dessus du point sélectionné est presque horizontal";
static char *str_ProbAboveVert = "Le point de contrôle au dessus du point sélectionné est presque vertical";
static char *str_ProbAboveItal = "Le point de contrôle au dessus du point sélectionné est proche de l'inclinaison des italiques";
static char *str_ProbBelowHor  = "Le point de contrôle au dessous du point sélectionné est presque horizontal";
static char *str_ProbBelowVert = "Le point de contrôle au dessous du point sélectionné est presque vertical";
static char *str_ProbBelowItal = "Le point de contrôle au dessous du point sélectionné est proche de l'inclinaison des italiques";
static char *str_ProbLeftHor  = "Le point de contrôle à gauche du point sélectionné est presque horizontal";
static char *str_ProbLeftVert = "Le point de contrôle à gauche du point sélectionné est presque vertical";
static char *str_ProbLeftItal = "Le point de contrôle à gauche du point sélectionné est proche de l'inclinaison des italiques";
static char *str_ProbRightHor  = "Le point de contrôle à droite du point sélectionné est presque horizontal";
static char *str_ProbRightVert = "Le point de contrôle à droite du point sélectionné est presque vertical";
static char *str_ProbRightItal = "Le point de contrôle à droite du point sélectionné est proche de l'inclinaison des italiques";
static char *str_ProbPtNearHHint = "The selected point is near a horizontal stem hint";
static char *str_ProbPtNearVHint = "The selected point is near a vertical stem hint";
static char *str_ProbHintHWidth = "Ce caractère contient un hint horizontal proche de la largeur du caractère";
static char *str_ProbHintVWidth = "Ce caractère contient un hint vertical proche de l'avance verticale du caractère";
static char *str_ProbHintControl = "Ce hint n'est utilisé par aucun point";
static char *str_ProbHint3Width = "Ce hint a une largeur incorrecte pour un hint 3-hampes";
static char *str_ProbHint3Spacing = "Les yeux entre ces hints n'ont pas exactement la même taille, ce qui ne convient pas pour un hint 3-hampes";
static char *str_ProbHint3Four = "Ce caractère a 4 hints, mais en enlevant celui ci, cela conviendrait pour un hint 3-hampes"
static char *str_NoProbHint3 = "Ce caractère peut utiliser un hint 3-hampes";
static char *str_ProbExpectedCounter = "Ce chemin devrait aller en sens inverse des aiguilles d'une montre";
static char *str_ProbExpectedClockwise = "Ce chemin devrait aller dans le sens des aiguilles d'une montre";
static char *str_ProbFlippedRef = "This reference has been flipped, so the paths in it are drawn backwards"
static char *str_ProbMissingBitmap = "Ce caractère contour n'a pas de pendant bitmap"
static char *str_ProbMissingOutline = "Ce caractère contour vide a bizarrement un pendant bitmap"
static char *str_ProbBadWidth = "L'avance de ce caractère est différente de l'avance standard"
static char *str_ProbBadVWidth = "L'avance Verticale de ce caractère est différente de l'avance verticale standard"
static char *str_ProbAboveOdd = "Le point de contrôle au dessus du point sélectionné est en dehors du segment de la courbe";
static char *str_ProbBelowOdd = "Le point de contrôle au dessous du point sélectionné est en dehors du segment de la courbe";
static char *str_ProbRightOdd = "Le point de contrôle à droite du point sélectionné est en dehors du segment de la courbe";
static char *str_ProbLeftOdd  = "Le point de contrôle à gauche du point sélectionné est en dehors du segment de la courbe";
static char *str_ProbCIDMult = "Ce caractère est défini dans plus d'une des sous polices CID";
static char *str_ProbCIDBlank = "Ce caractère n'est défini dans aucune des sous polices CID";
static char *str_ProbExplain = "Explication des problèmes";
static char *str_Fix = "Corriger";
static char *str_Stop = "Stop";
static char *mnemonic_Stop = 'S';
static char *str_Next = "Suivant";
static char *mnemonic_Next = 'N';
static char *str_OpenPaths = "Chemins ouverts";
static char *mnemonic_OpenPaths = 'P';
static char *str_OpenPathsPopup = "Tous les chemins devraient être fermés,\nil ne devrait pas y avoir d'extrémité isolée";
static char *str_Points2Close = "Points trop proches";
static char *mnemonic_Points2Close = 't';
static char *str_Points2ClosePopup = "Si deux points adjacents sur le même chemin sont trop proches,\ncertaines commandes de Pfaedit pourraient avoir des\nproblèmes. Cependant, le problème ne se retrouve pas en PostScript.";
/*static char *str_MissingExtrema = "Missing Extrema";
/*static char *mnemonic_MissingExtrema = 'E';
/*static char *str_MissingExtremaPopup = "Ghostview (perhaps other interpreters) has a problem when a\nhint exists without any points that lie on it. Usually this is because\nthere are no points at the extrema";*/
static char *str_XNear = "X environ";
static char *mnemonic_XNear = 'X';
static char *str_XNearPopup = "Permet de vérifier que les bras verticaux de plusieurs\ncaractères commencent au même endroit.";
static char *str_YNear = "Y environ";
static char *mnemonic_YNear = 'Y';
static char *str_YNearPopup = "Permet de vérifier que les bras horizontaux de plusieurs\n.caractères commencent au même endroit";
static char *str_YNearStd = "Y proche de la hauteur standard";
static char *mnemonic_YNearStd = 'S';
static char *str_YNearStdPopup = "Permet de trouver les points légèrement à coté\nde la ligne de base, de l'oeil, de la hauteur capitale,\ndes ascendantes ou des descendantes.";
static char *str_LineStd = "Bords presque horizontaux/verticaux";
static char *str_LineStd2 = "Bords presque horizontaux/verticaux/italiques";
static char *mnemonic_LineStd = 'E';
static char *str_LineStdPopup = "Pour trouver les lignes qui sont presque,\nmais pas tout à fait horizontales ou verticales\n(ou qui sont inclinées comme les italiques).";
static char *str_CpStd = "Points de Contrôle quasi horiz./vert.";
static char *str_CpStd2 = "Points de Contrôles quasi horiz./vert./italic";
static char *mnemonic_CpStd = 'C';
static char *str_CpStdPopup = "Permet de trouver les points de contrôle qui forment presque,\nmais pas tout à fait une horizontale ou une verticale avec leur\npoint de base (ou la même inclinaison que les italiques).";
static char *str_CpOdd = "Points de contrôle en dehors de la courbe";
static char *mnemonic_CpOdd = 'b';
static char *str_CpOddPopup = "Permet de trouver les points de contrôle qui après projection\nsur la courbe sont à l'extérieur des points adjacents";
static char *str_HintNoPt = "Hints ne contrôlant aucun point";
static char *mnemonic_HintNoPt = 'H';
static char *str_HintNoPtPopup = "Ghostview (et peut-être d'autres) a un problème quand\nun hint existe mais ne s'applique à aucun point.";
static char *str_PtNearHint = "Points near hint edges";
static char *mnemonic_PtNearHint = 'P';
static char *str_PtNearHintPopup = "Souvent quand un point est voisin d'un hint, c'est parce qu'une\nhampe est composée de plusieurs tronçons, et que la largeur\nde l'un d'entre eux est incorrecte.";
static char *str_HintWidth = "Largeur Hints: environ";
static char *mnemonic_HintWidth = 'W';
static char *str_HintWidthPopup = "Permet de vérifier que les hampes ont des largeurs homogènes...";
static char *str_Hint3 = "Presque un hint 3-hampes";
static char *mnemonic_Hint3 = '3';
static char *str_Hint3Popup = "Regarde si ce caractère est presque, mais pas exactement,\nconforme aux spécifications d'un hint 3-hampes.\nC'est à dire, soit verticalement soit horizontalement, il doit y avoir\nexactactement 3 hints, de même largeur, et espacés régulièrement."
static char *str_ShowExactHint3 = "Montrer les 3-hampes exacts";
static char *mnemonic_ShowExactHint3 = 'S';
static char *str_ShowExactHint3Popup = "Montrer si ce caractère est exactement un hint 3-hampes";
static char *str_CheckDirection = "Chemins extérieurs dans le sens horaire";
static char *mnemonic_CheckDirection = 'o';
static char *str_CheckDirectionPopup = "Postscript et TrueType demandent que les chemins soient traçés\ndans le sens horaire.  Ceci vous permet de faire cette vérification.";
static char *str_CheckFlippedRefs = "Vérifier les réferences retournées";
static char *mnemonic_CheckFlippedRefs = 'r';
static char *str_CheckFlippedRefsPopup = "Postscript et TrueType demandent que les chemins soient traçés\ndans le sens horaire. Si vous avez une référence qui a été retournée,\nles chemins de cette référence sont probablement dans le mauvais sens.\nVous devez défaire le lien et appliquer 'Corriger la Direction' dessus.";
static char *str_CheckBitmaps = "Vérifier les bitmaps manquantes";
static char *mnemonic_CheckBitmaps = 'b';
static char *str_CheckBitmapsPopup = "Y a-t-il des caractères n'ayant pas de bitmap dans l'une des polices bitmap?\nÀ l'inverse, y a-t-il des caractères bitmaps n'ayant pas leur pendants vectoriels?"
static char *str_CIDMultiple = "Recherche des CIDs définis 2 fois.";
static char *mnemonic_CIDMultiple = 'O';
static char *str_CIDMultiplePopup = "Verifier si un CID est défini dans plus d'une sous-police";
static char *str_CIDBlank = "Rechercher les CIDs non définis";
static char *mnemonic_CIDBlank = 'O';
static char *str_CIDBlankPopup = "Vérifier si un CID n'est défini dans aucune sous-police";
static char *str_PointsNear = "Points \"Proches\" si à moins de ";
static char *mnemonic_PointsNear = 'N';
static char *str_Near = "Near";
static char *str_ExplainErr = "Stoppe après chaque erreur et explique";
static char *mnemonic_ExplainErr = 'A';
static char *str_IgnoreProblemFuture = "Ignorer ce problème à l'avenir";
/* "Found %g, expected %g" */
static char *str_Found = "Trouvé ";
static char *str_Expected = ", attendu ";
static char *str_Paths = "Chemins";
static char *str_Random = "Hasard";
static char *str_PointsNoC = "Points";
static char *str_ClearAll = "Effacer tout";
static char *str_SetAll = "Sélectionner tout";
static char *str_AdvanceWidth = "Vérifier l'avance:";
static char *str_AdvanceWidthPopup = "Vérifier les caractères dont l'avance n'est pas la valeur indiquée."
static char *str_AdvanceVWidth = "Vérifier l'avance Verticale:
static char *str_AdvanceVWidthPopup = "Vérifier les caractères dont l'avance verticale n'est pas la valeur indiquée."
	/* Meta font */
static char *str_MetaFont = "Meta Font...";
static char mnemonic_MetaFont = 'M';
static char *str_CounterTooSmallT = "Oeil trop petit";
static char *str_CounterTooSmall = "L'oeil demandé était trop petit, il a été augmenté à sa valeur minimum";
static char *str_Simple = "Simple";
static char *str_Advanced = "Avancée";
static char *str_Embolden = "Graisser";
static char *str_Condense = "Condenser";
static char *str_Expand = "Elargir";
static char *str_Stems = "Stems";
static char *str_HCounters = "H Compteurs";
static char *str_VCounters = "V Compteurs";
static char *str_StemScale = "Scale Stems By:";
static char *str_CounterScale = "Scale Counters By:";
static char *str_XHeightFrom = "XHeight depuis:";
static char *str_To = "Jusque:";
static char *str_MetamorphosingFont = "Métamorphose...";
	/* to ttf */
static char *str_PickFont = "Choisissez une police, n'importe laquelle...";
static char *str_MultipleFontsPick = "Il y a plusieurs polices dans ce fichier, choisissez en une";
static char *str_AutoHintingFont = "Auto Hinting Font...";
static char *str_SavingOpenTypeFont = "Saving OpenType Font";
static char *str_LoadBitmapFonts = "Load bitmap fonts?";
static char *str_LoadTTFBitmaps = "Voulez vous chargez la police bitmap contenue dans ce fichier true/open type?\n(Si oui, laquelle)";
static char *str_BadEncoding = "Encodage défectueux";
static char *str_ExtraneousSingleByte = "Il y a un caractère sur un octet (%d) utilisantun emplacement pour les caractères à deux octet";
static char *str_OutOfEncoding = "Il y a un caractère (%d) qui ne peut pas être encodé";
static char *str_NotNormallyEncoded = "Il y a un caractère (%d) qui n'est normalement pas dans l'encodage";
	/* Spline Fill */
static char *str_Rasterizing = "Rasterizing...";
static char *str_GenBitmap = "Generating bitmap font";
static char *str_GenAntiAlias = "Generating anti-alias font";
/* "%d pixels" (for the size of the font being rasterized) */
static char *str_Pixels = " pixels";
	/* print */
static char *str_PrintingFont = "Impression de la police";
static char *str_GeneratingPostscriptFont = "Génération d'une police Postscript";
static char *str_FailedGenPost = "Échec de la génération d'une police postscript";
static char *str_PageSetup = "Mise en page";
static char *str_Setup = "Setup";
static char mnemonic_Setup = 'e';
static char *str_Other2 = "Autre";
static char mnemonic_Other = 'o';
static char *str_PrintOtherPopup = "N'importe quelle commande avec tous ses arguments.\nLa commande doit être prévue pour traiter une police postcript\nqu'elle trouvera en lisant son entrée standard.";
static char *str_ToFile = "Vers un fichier";
static char mnemonic_ToFile = 'F';
static char *str_PageSize = "Page:";
static char mnemonic_PageSize = 'S';
static char *str_Copies = "Copies:";
static char mnemonic_Copies = 'C';
static char *str_Printer = "Imprimante:";
static char mnemonic_Printer = 'P';
static char *str_PrintToFile = "Impression dans un fichier...";
static char *str_Pointsize = "Taille:";
static char mnemonic_Pointsize = 'P';
static char *str_FullFont = "Police complète";
static char mnemonic_FullFont = 'F';
static char *str_FullFontPopup = "Affiche tous les glyphes de la police dans un cadrillage rectangulaire à une taille donnée";
static char *str_FullPageChar = "Caractère pleine page";
static char mnemonic_FullPageChar = 'C';
static char *str_FullPageChars = "Caractères pleine page";
static char mnemonic_FullPageChars = 'C';
static char *str_FullPageCharPopup = "Affiche tous les caractères de la police, à raison d'un par page,\ndans une taille extrèmement grande";
static char mnemonic_SampleText = 'S';
static char *str_SampleTextC = "Spécimen de texte:";
static char mnemonic_SampleTextC = 'T';
static char *str_MultiSizeChar = "Caractère, tailles Multiples";
static char mnemonic_MultiSizeChar = 'M';
static char *str_MultiSizeChars = "Caractères, tailles Multiples";
static char mnemonic_MultiSizeChars = 'M';
static char *str_MultiSizeCharPopup = "Afficher tous les caractères sélectionnés, en plusieurs tailles";
static char *str_SampleTextPopup = "Imprimer le texte ci dessous dans la(les) taille(s) spécifiée(s)"
static char *str_FailedOpenTemp = "Échec de l'ouverture d'un fichier de sortie temporaire";
static char *str_NoCommandSpecified = "Aucune Commande Specifiée";
static char *str_InvalidPointsize = "Taille du point Invalide";
    /* alignment */
static char *str_CoordinateAlongWhich = "Espacement selon quelle coordonnée";
static char *str_X = "X";
static char mnemonic_X = 'X';
static char *str_Y = "Y";
static char mnemonic_Y = 'Y';
static char *str_MaximumDistanceBetweenPts = "Distance Maximum entre points dans une région";
static char mnemonic_MaximumDistanceBetweenPts = 'M';
static char *str_NotEnoughLines = "Pas assez de lignes";
static char *str_CantParallel = "Parallelisation impossible";
static char *str_ShareCommonEndpoint = "Ces 2 lignes partagent une extrémité, Je ne peux pas les  rendre parallèles.";
    /* parsettf */
static char *str_ReadingNames = "Lecture des noms";
static char *str_FixingupReferences = "Ajustement des Références";
static char *str_NoBitmaps = "No Bitmap Strikes";
static char *str_NoBitmapsInTTF = "No (useable) bitmap strikes in this TTF font: %hs";
static char *str_NotInCollection = "Not in Collection";
static char *str_FontNotInCollection = "%hs n'est pas dans %.100hs";
    /* sfd */
static char *str_Saving = "Enregistrement...";
static char *str_SavingDb = "Enregistrement du fichier de Splines";
static char *str_SavingOutlines = "Enregistrement des contours";
static char *str_SavingBitmaps = "Enregistrement des images";
static char *str_RecoveryFailed = "Échec de la récupération";
static char *str_RecoveryOfFailed = "Échec de la récupération automatique des changements dans %.80hs.\nPfaEdit doit il essayer à nouveau à son prochain lancement?";
static char *str_TryAgain = "Essayer à nouveau";
static char *str_ForgetIt = "Oublier";
    /* start.c */
static char *str_PfaEdit = "PfaEdit";
    /* cvpointer.c */
static char *str_NegativeWidth = "Largeur négative";
static char *str_NegativeWidthCheck = "Les caractères de largeur négative ne sont pas autorisés dans les polices TrueType\nVoulez vous vraiment une largeur négative?";
    /* hanyang.c */
static char *str_Hangul = "Hangul";
static char mnemonic_Hangul = 'H';
static char *str_NewComposition = "Nouvelle Composition...";
static char mnemonic_NewComposition = 'N';
static char *str_ModifyComposition = "Modifer la Composition...";
static char mnemonic_ModifyComposition = 'M';
static char *str_BuildSyllables = "Construction des Syllabes";
static char mnemonic_BuildSyllables = 'B';
static char *str_ChoSung = "Cho-Sung";
static char *str_JungSung = "Jung-Sung";
static char *str_JongSung = "Jong-Sung";
static char *str_ChoSungC = "Cho-Sung:";
static char *str_JungSungC = "Jung-Sung:";
static char *str_JongSungC = "Jong-Sung:";
static char *str_Mapping = "Mapping...";
static char mnemonic_Mapping = 'M';
static char *str_Width = "Width...";
static char mnemonic_Width = 'W';
static char *str_Reset = "Reset";
static char *str_LoadFrom = "Chargement depuis...";
static char mnemonic_LoadFrom = 'L';
static char *str_BadWidth = "Largeur incorrecte";
static char *str_BadGroup = "Groupe incorrect";
static char *str_JamoHoleTitle = "Variante de glyphe inusitée";
static char *str_JamoHole = "Pour le groupe %d dans %s, la variante de glyphe %d est remplacée par %d.\nContinuer vraiment?";
static char *str_NoRules = "Pas de règle";
static char *str_FileHasNoRules = "%.100hs ne contient pas de règle de composition";
static char *str_DeleteNo = "Supprimer";	/* With no mnemonic */
    /* Need a different mnemonic */
static char *str_AddAll = "Ajouter tout";
static char mnemonic_AddAll = 'd';
static char *str_DisplayCompositions = "Afficher les Compositions...";
static char mnemonic_DisplayCompositions = 'D';
static char *str_NoGroups = "Cette variante de ce jamo n'est jamais utilisée";
static char *str_UniVarient = "Unicode %04X, Variante %d, %s";
static char *str_BuildingKoreanFont = "Construction d'une police coréenne";
    /* Transform */
static char *str_TransformBackground = "Transformation de l'arrière plan aussi";
static char mnemonic_TransformBackground = 'B';
static char *str_Warning = "Attention";
static char *str_RotateSkewWarning = "Après une rotation ou une transformation de caractère, vous devriez probablement refaire Element->Ajouter Extrema";
    /* scripting */
static char *str_Call = "Appel...";
static char mnemonic_Call = 'a';
static char *str_CallScript = "Appel d'un Script";
    /* start (about box) */
static char *str_FreePress = "Une presse libre trie\nparmi les illettrés.";
static char *str_GaudiamusLigature = "Gaudiamus Ligature!";
    /* search */
static char *str_SearchPattern = "Motif de recherche:";
static char *str_ReplacePattern = "Motif de remplacement:";
static char *str_Allow = "Autorise:";
static char *str_Flipping = "Symétrie";
static char *str_Scaling = "Mise à l'échelle";
static char *str_Rotating = "Rotation";
static char *str_AllowTransPopup = "Trouve une concordance même si le motif sélectionné doit\nêtre transformé à l'aide d'une combinaison des\ntransformations suivantes.";
static char *str_SearchSelected = "Recherche des caractères sélectionnés";
static char *str_SearchSelectedPopup = "Recherche seulement parmi les caractères sélectionnés dans la vue\nNormallement, la recherche se fait sur tous les caractères de la police.";
static char *str_Find = "Trouve";
static char *str_FindIn = "Trouve dans %.100hs";
static char *str_FindNext = "Trouve le Suivant";
static char *str_FindAll = "Trouve Tout";
static char *str_ReplaceFind = "Remplace/Trouve"
static char *str_ReplaceAll = "Remplace Tout"
static char *str_BadRefInSearchRpl = "Dans %1$s, il y a une référence vers %2$.20hs qui n'existe pas dans la nouvelle police.\nFaut-il supprimer la référence?";
static char *str_NotFound = "Not Found"
static char *str_PatternNotFound = "Le motif cherché n'a pas été trouvé dans la police %.100hs";
static char *str_PatternNotFoundAgain = "Le motif cherché n'a pas été trouvé à nouveau dans la police %.100hs";
static char *str_FindReplace = "Trouve / Remplace"
static char *mnemonic_FindReplace = "i";

    /* combinaisons */
static char *str_SelectLigature = "Sélectionner une ligature à regarder"
static char *str_SortBy = "Trier par:"
static char *str_FirstChar = "Caractère Gauche"
static char *str_SecondChar = "Caractère Droit"
static char *str_KernSize = "Taille du Crénage"

    /* tilepath */
static char *str_Center_ = "Centrer";
static char mnemonic_Center_ = 'e';
static char *str_CenterPopup = "La tuile (venant du presse papier) doit être centrée sur le chemin"
static char *str_Left = "Gauche";
static char mnemonic_Left = 'G';
static char *str_LeftPopup = "La tuile (venant du presse papier) doit être placée à gauche du chemin\ncomme le chemin est tracé depuis son point de début vers son point final"
static char *str_Right = "Right";
static char mnemonic_Right = 'R';
static char *str_RightPopup = "La tuile (venant du presse papier) doit être placée à droite du chemin\ncomme le chemin est tracé depuis son point de début vers son point final"
static char *str_Tile = "Tuile";
static char mnemonic_Tile = 'T';
static char *str_TilePopup = "Plusieurs copies de la sélection doivent être empilées sur le chemin"
static char *str_Scale = "Mise à l'échelle";
static char mnemonic_Scale = 'S';
static char *str_ScalePopup = "la sélection doit être mise à l'échelle, de façon à\ncorrespondre à la longueur du chemin"
static char *str_TileScale = "Mise à l'échelle & Tuile";
static char mnemonic_TileScale = 'a';
static char *str_TileScalePopup = "Un nombre entier de sélection seront utilisées pour recouvrir le chemin\nSi la taille du chemin n'est pas un multiple exact de la hauteur\nde la sélection, celle ci sera légèrement mise à l'échelle"
    /* Display fonts */
static char *str_AA = "AA";
static char mnemonic_AA = 'A';
static char *str_AAPopup = "AntiAlias (greymap) characters, or bitmap characters";
static char *str_PixelSizePopup = "Indique la taille en pixel du caractère sur l'affichage";
static char *str_FormatPopup = "Spécifie le format de fichier à passer à freetype\n  pfb -- format postscript type1 standard\n  ttf -- format truetype\n  httf-- truetype avec hints\n  otf -- format opentype\n  bitmap -- freetype n'est pas utilisé\n    Les bitmap doivent déjà exister\n  pfaedit -- utiliser le moteur de PfaEdit, pas celui de\n    freetype. Seulement en dernier recours";
static char *str_BadSize = "Taille incorrecte";
static char *str_RequestedSizeNotAvail = "La taille demandée pour les bitmaps n'est pas dans la police. Sont disponibles: %hs";
static char *str_BadFont = "Police Incorrecte";

static int num_buttonsize = 70;
static int num_ScaleFactor = 120;
