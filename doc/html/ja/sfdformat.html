<HTML>
<HEAD>
  <!-- Created with AOLpress/2.0 -->
  <!-- AP: Created on: 7-Dec-2000 -->
  <!-- AP: Last modified: 14-Jun-2006 -->
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<!--<TITLE>Spline Font Database File Format</TITLE>-->
    <TITLE>スプラインフォントデータベースファイルフォーマット</TITLE>
  <LINK REL="icon" href="../fftype16.png">
  <LINK REL="stylesheet" TYPE="text/css" HREF="FontForge.css">
</HEAD>
<BODY>
<DIV id="in">
  <H1 ALIGN=Center>
<!--Spline Font Database-->
    スプラインフォントデータベース
  </H1>
  <P>
<!--
  <FONT COLOR="Red"><STRONG>This page is often grievously out of date. It was
  a fair approximation to reality on 13 December 2005.</STRONG></FONT> Even
  if out of date it should be helpful, but if you really need to know the current
  format look at
  <A HREF="http://cvs.sourceforge.net/viewcvs.py/fontforge/fontforge/fontforge/sfd.c">sfd.c</A>
  and see what it parses. Some descriptions of esoteric features are not complete,
  but I hope they give you enough hints that you can figure the format out
  (especially after looking it up in sfd.c) -->
  <FONT COLOR="Red"><STRONG>このページは悲しくなるほど時代遅れです。これは2005年12月13日に事実だったことの大まかな近似です。</STRONG></FONT>時代遅れであっても、これは役に立つでしょうが、現在のフォーマットについて本当に知りたい場合は <A HREF="http://cvs.sourceforge.net/viewcvs.py/fontforge/fontforge/fontforge/sfd.c">sfd.c</A> を参照して、それがどのように読み込みを行うかを調べてください。いくつかの秘教めいた機能の説明は完全ではありませんが、あなたが (とくに sfd.c を調べた後に) フォーマットを記述できるようになるためのヒントとなることを私は望んでいます。
  <P>
<!--
  FontForge's <A HREF="sfd.html">sfd</A> files are ASCII files (so they can
  be copied easily across the internet and so that diffs are somewhat meaningful).
  They contain a full description of your font. -->
  FontForge の <A HREF="sfd.html">sfd</A> ファイルは ASCII ファイルです (なのでそれらは Internet を介して簡単にコピーでき、diff を取ることには何らかの異義があります。それにはあなたのフォントの完全な記述が含まれます。
  <P>
<!--
  They are vaguely modeled on bdf files. The first few lines contain general
  font properties, then there's a section for each character, then a section
  for each bitmap font. -->
  それらはかすかに BDF ファイルから範をとっています。最初のごくわずかな行にフォント全体の属性が含まれ、それに続いて各文字のセクションが続き、最後に各ビットマップフォントのセクションがきます。
  <UL>
    <LI>
<!--  <A HREF="sfdformat.html#Font-Header">Font Header</A>-->
      <A HREF="sfdformat.html#Font-Header">フォントヘッダ</A>
    <LI>
<!--  <A HREF="sfdformat.html#Outline-Char-Data">Outline Character Data</A> -->
      <A HREF="sfdformat.html#Outline-Char-Data">アウトライン文字データ</A>
    <LI>
<!--  <A HREF="sfdformat.html#Bitmap-Fonts">Bitmap Fonts</A>-->
      <A HREF="sfdformat.html#Bitmap-Fonts">ビットマップフォント</A>
    <LI>
<!--  <A HREF="sfdformat.html#CID-keyed-fonts">CID keyed fonts</A>-->
      <A HREF="sfdformat.html#CID-keyed-fonts">CID キー指定フォント</A>
    <LI>
<!--  <A HREF="sfdformat.html#Multiple-Master-fonts">Multiple Master fonts</A>-->
      <A HREF="sfdformat.html#Multiple-Master-fonts">マルチプルマスターフォント</A>
    <LI>
<!--  <A HREF="sfdformat.html#Autosave-Format">AutoSave Format</A>-->
      <A HREF="sfdformat.html#Autosave-Format">自動保存フォーマット</A>
  </UL>
  <P>
<!--
  <FONT COLOR="Red"><STRONG><BIG>WARNING: </BIG></STRONG></FONT>It is tempting
  to cut and paste information from one sfd file to another. This is usually
  ok, but there are a couple of cases than need to be avoided: -->
  <FONT COLOR="Red"><STRONG><BIG>警告: </BIG></STRONG></FONT>ある SFD ファイルから他のファイルへ情報をカット&amp;ペーストしたいという誘惑を覚えます。これは大抵の場合は問題ありませんが、これを避けなければならない場合が 2 つあります:
  <UL>
    <LI>
<!--  If you copy a glyph with truetype instructions, those instructions may call
      subroutines defined in the old font but not the new. Unexpected things may
      happen when the glyph is grid fit (including system crashes) -->
      TrueType 命令を含むグリフをコピーした場合、それらの命令が古いフォントには定義されていても新しいフォントには未定義のサブルーチンを呼んでいる可能性があります。グリフがグリッド合わせを行ったとき、予想外の事柄 (システムクラッシュを含む) が起こる可能性があります。
    <LI>
<!--  If you copy a substitution (ligature, kern, contextual chaining, ...) item
      from one font to another, the substitution contains an index into a table
      of script/languages maintained by the font. Bad things (FontForge crashes)
      can happen if these tables do not match. -->
      置換 (合字、カーニング、連鎖型文脈依存、…) をあるフォントから別のフォントにコピーしたときには、置換にはフォントに保存されているスクリプト/言語テーブル内のインデックスが保存されています。それらのテーブルが一致していなければ、悪い事 (FontForge のクラッシュ) が起こるかもしれません。
    <LI>
<!--  If you copy a glyph containing references these are done by glyph index (which
      is probably different from font to font). You may end up refering to the
      wrong glyph. -->
      グリフインデックス (これはフォント語とに異なります) によって指定された参照を含むグリフをコピーすると、間違ったグリフを参照する結果となるでしょう。
  </UL>
  <H3>
<!--<A NAME="Font-Header">Font Header</A>-->
    <A NAME="Font-Header">フォントヘッダ</A>
  </H3>
  <P>
<!--
  Here is an example of what the first few lines look like (order is largely
  irrelevant within this section): -->
  ここに示すのは、最初のごく僅かな行がどのような感じかを示す例です (このセクションでは、順番はほとんど意味をもちません):
  <BLOCKQUOTE>
    <PRE>SplineFontDB: 1.0
FontName: Ambrosia
FullName: Ambrosia
FamilyName: Ambrosia
Weight: Medium
Copyright: Copyright (C) 1995-2000 by George Williams
Comments: This is a funny font.
Version: 001.000
ItalicAngle: 0
UnderlinePosition: -133
UnderlineWidth: 20
Ascent: 800
Descent: 200
DisplaySize: -24
AntiAlias: 1
WinInfo: 64 16 4
FitToEm: 1
XUID: 3 18 21
Encoding: unicode
Order2: 1
OnlyBitmaps: 0
MacStyle: 0
TeXData: 1 10485760 0 269484 134742 89828 526385 1048576 89828
</PRE>
</BLOCKQUOTE>
  <P>
<!--
  The first line just identifies the file as an sfd file. The next few lines
  give the various different names that postscript allows fonts to have. Then
  some fairly self-explanatory items (if they don't make sense, look them up
  in the <A HREF="fontinfo.html">font info</A> dlg). A few things need some
  explanation: -->
  最初の行は、単にこのファイルが SFD ファイルであることを示すだけのものです。その下の 3 行は、PostScript でフォントに設定することができる各種の異なる名前を示しています。それに続く項目群は、まったくその名の通りに用いられます (意味が分からない場合は、<A HREF="fontinfo.html">フォント情報</A>ダイアログで調べてみてください)。2, 3 の項目にはちょっと説明が必要でしょう:
  <DL>
    <DT>
      TeXData
    <DD>
<!--  These are the TeX font parameters (and some similar info). The first number
      is 1,2 or 3 and indicates that the font is a text, math or math ext font.
      The next number is the design pointsize (times (1&lt;&lt;20)). Then follow
      the font parameters. These values are usually in TeX fix_word format where
      there is a binary point after the first 20 binary digits (so to get the number
      divide by (1&lt;&lt;20)). -->
      これらは TeX のフォントパラメータ (およびいくつかの同種の情報) です。最初の数値は 1, 2 または 3 で、フォントがテキスト、数学または数学拡張フォントのどれであるかを示します。次の数値はデザインポイントサイズ (×(1&lt;&lt;20)) です。その後にフォントパラメータが続きます。これらの数値は通常 TeX の fix_word フォーマットで表されます。このフォーマットでは 2 進数で先頭 20 桁目に小数点が来ます (ですから、実際の数値を得るためには (1&lt;&lt;20) で割ってください)。
    <DT>
      DisplaySize
    <DD>
<!--  This is the number of pixels per em that will be used by default to display
      the font in fontviews (it may be changed of course). Negative numbers mean
      to rasterize the display from the outlines, positive numbers mean to use
      a prebuilt bitmap font of that size. -->
      これは、フォントビュー内でフォントを表示する際のデフォルトとして用いられる、1 em あたりのピクセル数です (もちろん変更可能です)。負の数字は、アウトラインをラスタライズして表示することを意味し、正の数字は、そのサイズに一致する作成済みのビットマップを使用することを意味します。
    <DT>
      AntiAlias
    <DD>
<!--  Whether the fontview should display the font as antialiased or black and
      white. (AntiAliased looks better, but will be slower) -->
      フォントビューで、フォントをアンチエイリアス表示するか、白黒表示するか。(アンチエイリアスの方がきれいに表示されますが、遅くなります)
    <DT>
      FitToEm
    <DD>
<!--  Controls whether Fit to Em is checked by default in a fontview that displays
      this font. -->
      このフォントを表示するフォントビューで、<CODE>表示を全角に固定(<U>F</U>)</CODE> にデフォルトでチェックを入れておくか。
    <DT>
      WinInfo
    <DD>
<!--  Has three pieces of data on the default display of windows containing this
      font. The first datum says that the window should be scrolled so that glyph
      at encoding 64 should be visible, the second that the window should have
      16 character columns horizontally, and the last that there should be 4 character
      rows vertically. -->
      このフォントを表示するウィンドウのデフォルト画面を表す 3 つの値です。最初の値は、ウィンドウは符号位置 64 にあるグリフが見えるようにスクロールするかを表し、2 番目の値は、ウィンドウが横幅 16 文字分の欄をもつかどうかを、最後の値は建てに 4 文字分の欄を持つかどうかを表します。
    <DT>
      Encoding
    <DD>
<!--  For normal fonts this will be one of the names (or a close approximation
      thereto) that appears in the Encoding pulldown list. CID keyed fonts will
      not have encodings. Instead they'll have something like: -->
      普通のフォントでは、これは <CODE>エンコーディング(<U>E</U>)</CODE> プルダウンリストに表示される名前のどれかと同じ (か、それに非常に近い) ものとなるでしょう。CID キー指定フォントは、Encoding 行を含まず、以下のようなものが含まれるでしょう。
  </DL>
  <BLOCKQUOTE>
    <PRE>Registry: Adobe
Ordering: japan1
Supplement: 4
CIDVersion: 1.2
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  Some fonts will have some TrueType information in them too (look at the
  <A HREF="http://www.microsoft.com/typography/tt/tt.htm">truetype spec</A>
  for the meanings of these, they usually live in the OS/2, hhea, or vhea tables). -->
  フォントによっては、いくつかの TrueType 情報もここに含まれるでしょう (それらの意味については <A HREF="http://www.microsoft.com/typography/tt/tt.htm">TrueType の仕様書</A>を参照してください。それらは大抵 OS/2, hhea, vhea テーブルのいずれかにあるはずです。
  <BLOCKQUOTE>
    <PRE>FSType: 4
PFMFamily: 17
TTFWeight: 400
TTFWidth: 5
Panose: 2 0 5 3 0 0 0 0 0 0
LineGap: 252
OS2LineGap: 252
VLineGap: 0
OS2Vendor: 'PfEd'
OS2FamilyClass: 2050
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  These items also come from the OS/2 and hhea tables but are slightly more
  complex. The keywords are paired, so <CODE>HheadAscent</CODE> and
  <CODE>HheadAOffset</CODE> work together. If the offset keyword is 1 (true)
  then the other keyword is treated as a value relative to what FontForge thinks
  should be the correct value, FontForge will calculate what it thinks the
  value should be and then will add the value specified in the keyword. So
  in the example below, FF will figure out what it thinks
  <CODE>HheadAscent</CODE> should be and then add "0" to it to get the value
  stored in a truetype font's OS/2 table. However if the Offset flag is set
  to 0 (false) then the Ascent would be used exactly as specified. -->
  以下の項目は OS/2 および hhea テーブルからも取得されますが、それらは僅かにより複雑です。それらのキーワードは対になっているので <CODE>HheadAscent</CODE> と <CODE>HheadAOffset</CODE> は一緒に動作します。*Offset キーワードが 1 (真) である場合、もう片方のキーワードは、FontForge が正しい値として認識する値を基準とした相対値として扱われます。その場合 FontForge は適切と思われる値を計算して、それにキーワードで指定された値を加えます。ですから以下の例では、FF は TrueType フォントの OS/2 テーブルに格納された値を得るために <CODE>HheadAscent</CODE> に“0”を加えるべきと考えます。その一方、Offset フラグが 0 (偽) に設定されている場合、アセントの値は指定されたとおりの物が使用されます。
  <BLOCKQUOTE>
    <PRE>HheadAscent: 0
HheadAOffset: 1
HheadDescent: 0
HheadDOffset: 1
OS2TypoAscent: 0
OS2TypoAOffset: 1
OS2TypoDescent: 0
OS2TypoDOffset: 1
OS2WinAscent: 0
OS2WinAOffset: 1
OS2WinDescent: 0
OS2WinDOffset: 1
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  The OS/2 table contains information on the position of subscripts, superscripts
  and strike throughs: -->
  OS/2 テーブルには下付き文字、上付き文字および取り消し線の位置情報が含まれています:
  <BLOCKQUOTE>
    <PRE>OS2SubXSize: 1351
OS2SubYSize: 1228
OS2SubXOff: 0
OS2SubYOff: -446
OS2SupXSize: 1351
OS2SupYSize: 1228
OS2SupXOff: 0
OS2SupYOff: 595
OS2StrikeYSize: 143
OS2StrikeYPos: 614
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  The MacStyle field (if present) indicates whether the font is bold, italic,
  condensed, extended, etc. -->
  MacStyle フィールドは、(存在すれば) そのフォントがボールド、イタリック、コンデンスト、エクステンディドなどに該当するかどうかを示します。
  <P>
<!--
  Some fonts will have Postscript specific information contained in the Private
  dictionary -->
  一部のフォントは、Private 辞書に含まれる PostScript 固有の情報をもっています。
  <BLOCKQUOTE>
    <PRE>BeginPrivate: 1
BlueValues 23 [-19 0 502 517 750 768]
EndPrivate
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  If the font has any opentype features it will have a list of
  <A HREF="charinfo.html#ScriptLang">script language</A> entries: -->
  フォントに OpenType 機能が含まれているならば、<A HREF="charinfo.html#ScriptLang">用字系・言語</A>項目のリストもあるはずです:
  <BLOCKQUOTE>
    <PRE>ScriptLang: 3
 1 latn 1 ROM   
 1 latn 4 DEU  ROM  VIT  dflt 
 3 cyrl 1 dflt grek 1 dflt latn 5 DEU  ROM  TRK  VIT  dflt
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  The first line says that there are 3 sets of script lang entries and they
  follow on the next three lines. The next line says that this entry is only
  active for one script ('latn') and then only if the language is 'ROM '. The
  next line says the entry is again only active for one script, but that this
  time any of the four languages 'DEU ', 'ROM ', 'VIT ' or the default language
  apply to it. And the last line gives an example of an entry that is active
  for several scripts with several languages. -->
  最初の行は、用字系・言語項目が 3 セット存在することを示し、その後の 3 行にそれらの項目が含まれます。2 行目は、この項目が有効になるのがただ 1 個の用字系 (&lsquo;latn&rsquo;) のみで、なおかつ言語が&lsquo;ROM &rsquo;であるときに限られることを示します。その次の行も 1 個の用字系のみに対して有効であることを示しますが、今度は 4 個の言語 (&lsquo;DEU &rsquo;,&lsquo;ROM &rsquo;,&lsquo;VIT &rsquo;またはデフォルト言語) に対して適用されることを表します。最後の行では、複数の用字系と複数の言語において有効となる項目の例を示しています。
  <P>
<!--
  OpenType features are stored with an index into this list. If a feature has
  index "0" then that feature is only active for the latin script in the Romanian
  language. If it has index 2 it will be active for cyrillic, greek and latin
  scripts. A special script index of 65535 is used to mean that this feature
  is "Nested", that is it is never activated by itself, but its activation
  is controlled by a contextual or contextual chaining lookup (which in turn
  will have its own script language index). -->
  OpenType 機能はこのリスト内のインデックスを用いて格納されます。この場合、ある機能がインデックス“0”であるならば、その機能はルーマニア語のラテン文字表記のときにのみ有効になります。インデックスが 2 であるならば、その機能はキリル文字・ギリシャ文字およびラテン文字に対して有効になるわけです。その機能が「入れ子」になった物であることを表すための特別な用字系インデックスとして、65535 を使っています。これはそれ自体で起動されることは決してなく、文脈依存または文脈依存連鎖の照合  (これ自体は、独自の用字系・言語インデックスを備えています) によって起動が制御されるものです。
  <P>
<!--
  If your font has any kerning classes -->
  フォントに何らかのカーニングクラスが含まれていれば、
  <BLOCKQUOTE>
    <PRE>KernClass: 31 64 2 0
 1 F
 41 L Lacute glyph78 Lcommaaccent Ldot Lslash
 1 P
...
 6 hyphen
 5 space
...
 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 -152 -195 -152 -225 0 0 0 0 0 0 0 0 0 0 0 0 0 -145 -145 -130
 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 -130 0 0 0 0 0 0 0 0 0 0 -145 0 -115 0 0 0 0 -65 0 -140 -120 -120
...
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  The first line says that this Kerning Class has 31 different classes for
  the first character, and 64 for the second. It is active for entry 2 in the
  script lang list above. The <A HREF="charinfo.html#lookup-flags">OpenType
  flags </A>will be 0. The next line says that the first character class of
  the first character (numbered 1, class 0 is reserved and usually is not defined)
  consists of only one character "F" (the number in front is the string length
  of the line. It speeds up processing the sfd file but has no semantic content).
  The next line is for class 2 of the first character, it has more characters
  in it and a longer string length. After 30 entries we start on the classes
  for the second character. They look exactly like classes for the first character.
  After all the second character classes have been defined we have an array
  of numbers, &lt;char1 class cnt&gt;*&lt;char2 class cnt&gt; of them in fact.
  This specifies the amount of kerning that should be placed between a characters
  of the given classes of left and right characters (ie. if char1 was in left
  class 2 and char2 was in right class 4 then we would index this array with
  3*&lt;char2 class cnt&gt; + 4). -->
  最初の行は、このカーニングクラスに含まれる先頭文字のクラスが 31 種類存在し、第二文字のクラスが 64 種類存在することを表しています。これは、上記の用字系・言語リストの項目 2 に対して有効になります。<A HREF="charinfo.html#lookup-flags">OpenType フラグ</A> は 0 となります。次の行は、最初の文字 (クラス 0 は予約済みで、通常は定義する必要がないので、この番号は 1 となります) の先頭文字クラスは文字“F”1 文字からなることを表します (“F”の前にある数字は行の文字数です。これは SFD ファイルの処理速度の向上に役立ちますが、それ自体で意味を持つ情報ではありません)。次の行は、先頭文字のクラス 2 で、より多くの文字を含んでいるため文字列長も長くなっています。30 個の項目が続いた後に、第二文字のクラスが始まります。これは、先頭文字のクラスと全く同様です。第二文字のクラスを全部定義し終わった後に、多数(正確には &lt;先頭文字クラスの個数×第二文字クラスの個数&gt;) の数値からなる 1 個の配列が来ます。これは、該当するクラスの対における左右の文字間に施されるカーニングの量を指定しています (例えば、文字1 が先頭文字クラス 2 に属し、文字2 が第二文字クラス 4 に属している場合、この配列のインデックス 3×&lt;文字2 のクラス番号&gt; + 4 で指定することになります)
  <P>
<!--
  If your fontforge has been configured with device table support you may find
  <A HREF="#device-table">device</A> tables interspersed among the kerning
  offsets array: -->
  お使いの FontForge がデバイステーブルサポートつきの設定でコンパイルされている場合、<A HREF="#device-table">デバイス</A>テーブルがカーニングオフセット配列の間に組み込まれているのが見つかるでしょう:
  <BLOCKQUOTE>
    <PRE>...
0 {} 0 {} 0 {} ...
-145 {12-13 -1,1} -145 {} -130 {8-9 -1,-1} ...
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  The order of opentype features within GPOS/GSUB tables may be stored: -->
  GPOS/GSUB テーブルに含まれる OpenType 機能の順番も保存することができます:
  <BLOCKQUOTE>
    <PRE>TableOrder: GPOS 4
	'subs'
	'sinf'
	'mark'
	'kern'
TableOrder: GSUB 2
	'frac'
	'nutf'
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  If the font contains ttf hinting, then the file may contain unparsed truetype
  tables (understanding ttf hinting is beyond FontForge's abilities, but it
  can at least preserve the data): -->
  フォントに TTF のヒント情報が含まれている場合、ファイルには TrueType テーブルを解析しないで格納することができます (TTF のヒントを理解することは FontForge の能力を超えていますが、少なくともデータを保存することはできます):
  <BLOCKQUOTE>
    <PRE>TtfTable: prep 4360
5S;o3()It?eJ8r@H[HSJH[H^@!b&amp;BQ*?Vcm@'XSh+1MACZ&gt;Up/\,o1+Ca't2!&lt;ocH+Wn2p"@,t&amp;
+Wo+[()Is6G8:u7D/^7,*,KO/(E=N5!=s)LCMjn,:Mp3:DSL&amp;j05dG#cY`hLCN"!&lt;CBO$@s(_ZX
...
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  The first line says that the 'prep' table is 4360 bytes long. Subsequent
  lines will provide 4360 bytes of data, packed in
  <A HREF="#ASCII85Encode">ASCII85Encode<SUP>1</SUP></A> (which takes binary
  data and packs it into ASCII without too much expansion. See the PostScript
  Reference Manual (3rd edition, pages 131-132) for a description of this packing,
  or <CODE>$&nbsp;man&nbsp;btoa</CODE>). -->
  最初の行は、&lsquo;prep&rsquo;テーブルの長さが 4360 バイトであることを表します。後ろに続く行には、4360 バイトのデータが <A HREF="#ASCII85Encode">ASCII85Encode<SUP>1</SUP></A> (入力されたバイナリデータをあまりサイズを大きくしないで ASCII にパックします。この方式の説明は、PostScript リファレンスマニュアル (第3版、原書 131〜132 ページ) を参照するか、<CODE>$&nbsp;man&nbsp;btoa</CODE> で調べてください) にパックされて納められています。
  <P>
<!--
  The <CODE>LangName</CODE> entries represent the TrueType name table: the
  number represents the language and is followed by a list of strings encoded
  in UTF-7. The first string corresponds to ID=0 (Copyright), the second to
  ID=1 (Family), ... trailing empty strings will be omitted. In the American
  English language (1033) section, if one of these names exactly matches the
  equivalent postscript item then that name will be omitted (this makes it
  easier to handle updates, users only have to change the copyright in one
  place) -->
  TrueType の name テーブルは複数の <CODE>LangName</CODE> 項目によって表されます: 数字は言語を表し、その後ろに続くのは UTF-7 で符号化された文字列のリストです。最初の文字列は ID=0 (著作権) に対応し、2 番目は ID=1 (ファミリー) に対応し、…という具合で、末尾にある空文字列はすべて省略されます。アメリカ英語 (1033) のセクションでは、これらの名前のどれかが、等価な PostScript 項目と正確に一致している場合、その名前は省略されます (これにより更新の取扱いが簡単になり、ユーザは 1 箇所で著作権表示を変更するだけでよくなります)。
  <BLOCKQUOTE>
    <PRE>LangName: 1033 "" "" "Regular" "GWW:Caliban Regular: Version 1.0" "" "Version 1.0"
LangName: 1032 "" "" "+A5oDsQ09A78DvQ05A7oDrAAA"
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  If your font has any anchor classes: -->
  フォントに何らかのアンカークラスが含まれている場合:
  <BLOCKQUOTE>
    <PRE>AnchorClass: "top" mark 4 7 1 "bottom" mark 4 7 1 "Anchor-2" mark 4 7 1 "Anchor-3" mark 4 7 2 "Anchor-4" mark 4 7 2 "Anchor-5" mark 4 7 3 "Anchor-6" mark 4 7 4 
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  There is an Anchor Class named "top" which has feature tag 'mark', opentype
  flags 4, a script lang index of 7, and it should be merged with other anchor
  classes marked with "1". The next class is named "bottom", the next "Anchor-2"
  and so forth. (Anchor class names are output in UTF7) -->
  ここには“top”という名前で、機能タグ“mark”を含み、OpenType フラグが 4 で、用字系/言語インデックスが 7 であるアンカークラスが存在し、これが“1”と印づけられた他のアンカークラスと併合すべきであることを示します。次のクラスは“bottom”という名前で、その次は“Anchor-2”という名前で、以下同様に続きます。(アンカークラス名は UTF-7 で出力されます)
  <P>
<!--
  Contextual or contextual chaining lookups are also stored in the font header.
  The are introduced by one of the keywords: "ContextPos", "ContextSub",
  "ChainPos", "ChainSub" and "ReverseChain", and are ended by "EndFPST". Contextual
  chaining lookups may check previous glyphs (called backtracking), current
  glyphs and lookahead glyphs, while Contextual lookups only check for a string
  of current glyphs. There are four formats:<BR> -->
  文脈依存または文脈依存連鎖の照合も、フォントヘッダに格納されます。それらはキーワード“ContextPos”,“ContextSub”,“ChainPos”,“ChainSub”または“ReverseChain”で始まり、キーワード“ENDFPST”で終了します。文脈依存の照合は現在位置にあるグリフ列を所定の文字列群と照合することしかできませんが、文脈依存連鎖の照合は現在のグリフ、および先読みグリフだけでなく先行するグリフをチェックすることができます (これをバックトラックといいます)。このフォーマットには 4 種類あります。<BR>
<!--   By coverage tables -->
  適用範囲テーブルによる方法
  <BLOCKQUOTE>
    <PRE>ChainSub: coverage 0 0 'abvs' 0 0 0 1
 1 1 0
  Coverage: 7 uni0C40
  BCoverage: 8 glyph388
 1
  SeqLookup: 0 '0013'
EndFPST
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  This defines a simple context chaining substitution by coverage class. The
  opentype flags are 0, script/lang index is 0, the feature tag is 'abvs'.
  There are no classes, no backtracking classes and no lookahead classes defined
  (it's by coverage table). There is one rule. (For a greater explanation of
  these cryptic comments see the OpenType specs on contextual lookups). -->
  これは適用範囲クラスによる単純文脈連鎖依存の置換を定義しています。OpenType フラグは 0, 用字系/言語インデックスは 0 で、機能タグは&lsquo;abvs&rsquo;です。クラスもバックトラッククラスも先読みクラスも定義されていません (適用範囲テーブルで指定しています)。ルールが 1 個あります (これらの暗号のようなコメントのより詳しい説明については、OpenType 仕様書の、文脈依存照合 (contextual lookup) について述べた箇所を調べてください)。
  <P>
<!--
  Then follows the first rule. The first line, "1 1 0", says how many coverage
  tables there are in the normal list (1), how many in the backtrack list (1)
  and how many in the lookahead list (0). Then we get the one normal coverage
  table, which describes a single glyph (uni0C40). Then one backtracking coverage
  table which also defines one glyph (glyph388). Finally there is one sequence
  lookup, at normal position 0, we should apply the substitution named '0013'. -->
  その後に最初のルールが続きます。1 行目の“1 1 0”というのは、何個の適用範囲テーブルが通常リスト (1 個)、バックトラックリスト (1 個) および先読みリスト (0 個) が含まれているかを表します。その次にあるのが 1 個の通常適用範囲テーブルで、これは 1 個のグリフ (uni0C40) を記述しています。続いて 1 個のバックトラック適用範囲テーブルがあり、これも 1 個のグリフ  (glyph388) を定義しています。最後にあるのが 1 個の連鎖型照合で、通常位置 0 において&lsquo;0013&rsquo;という名前の置換を適用する必要があることを表します。
  <P>
<!--
  That is to say: If we find the glyph stream "glyph388 uni0C40", then it will
  match this lookup and we should apply substitution '0013' (found elsewhere)
  to uni0C40. -->
  一言で言うとこうなります: グリフの連鎖“glyph388 uni0C40”が見つかったら、それはこの照合に一致し、その時は (よそで定義されている) 置換&lsquo;0013&rsquo;を uni0C40 に適用すること。
  <P>
<!--
  By classes -->
  クラスによる方法
  <BLOCKQUOTE>
    <PRE>ChainSub: class 0 0 'calt' 3 3 0 1
  Class: 52 b o v w b.high o.high v.high w.high r.alt.high r.alt
  Class: 43 a c d e f g h i j k l m n p q r s t u x y z
  BClass: 52 b o v w b.high o.high v.high w.high r.alt.high r.alt
  BClass: 43 a c d e f g h i j k l m n p q r s t u x y z
 1 1 0
  ClsList: 2
  BClsList: 1
  FClsList:
 1
  SeqLookup: 0 'high'
EndFPST
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  This defines a context chaining substitution, by classes. The format of the
  first line is the same as described above. Here we have three classes for
  the normal match and three for the backtracking match, and one rule. The
  next 4 lines define the classes. As with kerning by classes, class 0 does
  not need to be explicitly defined, it is implicitly defined to be "any glyph
  not defined in another class". So we define class 1 to be "b,o,v,..." and
  class 2 to be "a,c,d,e,...". And then we define the backtracking classes
  (which here happen to be the same as the classes for the normal match, but
  that isn't always the case). -->
  これは、クラスによる文脈連鎖型置換を 1 つ定義しています。最初の行のフォーマットは上で説明したのと同じです。ここでは通常の一致に対する 3 つのクラスとバックトラックによる一致に対する 3 つのクラスが定義されています。その後ろの 4 行はクラスを定義しています。クラスによるカーニングの場合と同じく、クラス 0 は明示的に定義する必要はなく、「他のクラスのどれにも定義されていない任意のグリフ」として暗黙に定義されます。そこで、クラス 1 を“b,o,v,…”と定義し、クラス 2 を“a,c,d,e,…”と定義することになります。次に、クラス群のバックトラックを定義します（ここでは通常の一致のためのクラスとたまたま同じですが、常にそうであるわけではありません)。
  <P>
<!--
  The one rule says that if we get something in normal class 2 following something
  in backtracking class 1 (that is, if we get something like "ba" or "oc")
  then apply substitution 'high' -->
  ルールの 1 つでは、通常クラス 2 に含まれる何かの後にバックトラッククラス 1 が来た場合 (つまり、“ba”や“oc”のような何らかの文字列がある場合) 置換&lsquo;high&rsquo;を適用しています。
  <P>
<!--
  By glyphs -->
  グリフによる方法
  <BLOCKQUOTE>
    <PRE>ChainSub: glyph 0 1 'calt' 0 0 0 1
 String: 1 D
 BString: 3 c b
 FString: 1 e
 1
  SeqLookup: 0 'rigl'
EndFPST
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  Again we have one rule. That rule says that if we get the sequence of glyphs
  "c b D e" then we should apply substitution 'rig1' to glyph "D". -->
  この例でも 1 個のルールが定義されています。このルールでは、グリフの連鎖“c b D e”が存在した場合、置換&lsquo;rig1&rsquo;をグリフ“D”に適用するように指示しています。
  <P>
<!--
  And finally by reverse coverage tables -->
  最後は、逆順の適用範囲テーブルによる方法です。
  <BLOCKQUOTE>
    <PRE>ChainSub: revcov 0 0 'foo ' 0 0 0 1
 1 1 0
  Coverage: 7 uni0C40
  BCoverage: 8 glyph388
 1
  Replace: 11 uni0C40.alt
EndFPST
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  Which says that when glyph388 precedes uni0C40 then uni0C40 should be replaced
  by uni0C40.alt -->
  これは、グリフ 388 の前に uni0C40 が来た場合、uni0C40 を uni0C40.alt に置き換えるべきであることを表しています。
  <P>
<!--
  There may be apple state machines. These are introduced by one of the keywords:
  "MacIndic", "MacContext", "MacInsert" and "MacKern", and they are terminated
  with "EndASM". -->
  Apple 状態機械を含めることができます。それはキーワード“MacIndic”,“MacContext”,“MacInsert”または“MacKern”で始まり、“EndASM”で終了します。
  <BLOCKQUOTE>
    <PRE>MacContext: 2,2 16384 9 5
  Class: 320 yehhamzaabovearabic beharabic teharabic theharabic jeemarabic haharabic khaharabic seenarabic sheenarabic sadarabic dadarabic taharabic zaharabic ainarabic ghainarabic feharabic qafarabic kafarabic lamarabic meemarabic noonarabic heharabic alefmaksuraarabic yeharabic peharabic tteharabic tcheharabic veharabic gafarabic
  Class: 227 noonghunnaarabic alefmaddaabovearabic alefhamzaabovearabic wawhamzaabovearabic alefhamzabelowarabic alefarabic tehmarbutaarabic dalarabic thalarabic reharabic zainarabic wawarabic ddalarabic rreharabic jeharabic yehbarreearabic
  Class: 201 shaddakasraarabic shaddakasratanarabic shaddafathaarabic shaddadammaarabic shaddadammatanarabic fathatanarabic dammatanarabic kasratanarabic fathaarabic dammaarabic kasraarabic shaddaarabic sukunarabic
  Class: 13 tatweelarabic
  Class: 17 ttehinitialarabic
 0 0 ~ ~ 
 0 0 ~ ~ 
 0 0 ~ ~ 
 0 0 ~ ~ 
 2 32768 ~ ~ 
 ... 
 3 32768 'M002' 'M003' 
 ...
EndASM
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  The state machine begins with a line defining what mac feature,setting invokes
  it, some mac flags, the number of classes, and number of states in the machine.
  The first four states on the mac are predefined, so we start with class 4
  (yehhamzaabovearabic...). Finally there will be &lt;number of
  classes&gt;*&lt;number of states&gt; lines describing transitions. We begin
  with the transition for state 0, class 0, then the transition for state 0,
  class 1, ... -->
  状態機械は、どの Mac 機能/設定の対によって呼び出されるかの定義と、いくつかの Mac フラグおよび機械に含まれる状態の個数を含む行から始まります。
  Mac 上の最初の 4 状態は定義済みなので、クラス 4 (yehhamzaabovearabic) から始まることになります。最後に、状態遷移を表す行が &lt;クラスの個数&gt;×&lt;状態の個数&gt; だけの行数にわたって続きます。状態 0, クラス 0 の定義が最初にあり、続いて状態 0, クラス 1 …と続きます。
  <P>
<!--
  Each transition contains the next state to go to, a set of flags. There may
  also be other arguments depending on the type of the state machine. -->
  各状態遷移には、次に移る状態と、一連のフラグが含まれます。そのほかの、状態機械のタイプに依存する引数も置くことができます。
  <TABLE BORDER CELLPADDING="2">
    <TR>
      <TD VALIGN="Top">MacIndic</TD>
<!--  <TD>This format has no additional arguments</TD>-->
      <TD>このフォーマットには追加の引数はありません</TD>
    </TR>
    <TR>
      <TD VALIGN="Top">MacContext</TD>
<!--  <TD>This format potentially contains the names of two substitutions. One
	to be applied to the marked glyph, one to be applied to the current glyph
	(the special substitution "~" means do nothing and is used as a place holder).
	See above.</TD> -->
      <TD>このフォーマットは 2 個の置換の名前を潜在的に含みます。1 個はマーク付きグリフに適用される物で、もう 1 個は現在のグリフに適用される物です (特殊な置換“~”は何もしないことを意味し、プレースホルダとして用いられます。</TD>
    </TR>
    <TR>
      <TD VALIGN="Top">MacInsert</TD>
<!--  <TD>This format contains two glyph lists, each preceded by a number indicating
	how many bytes follow. -->
      <TD>このフォーマットには 2 個のグリフリストが含まれ、それぞれの前には、後ろに何バイト続くかを表す数値が置かれます。</TD>
	<BLOCKQUOTE>
	  <PRE>2 0 <B>0 3 a b</B>
0 32768 <B>4 fi q 0</B>
</PRE>
	</BLOCKQUOTE>
	<P>
<!--    The first line indicates that no characters should be insert at the marked
	glyph but that "a" and "b" should be insert at the current glyph. The second
	line indicates that "fi" and "q" should be insert at the marked glyph and
	no characters at the current glyph. The flags determine whether characters
	are insert before or after the glyph.</TD> -->
	最初の行は、マーク付きグリフの箇所には挿入する物がなにも無いが、現在グリフの位置には“a”と“b”を挿入することを表しています。2 行目は“fi”と“q”はマーク付きグリフの位置に挿入され、現在グリフの位置には何も挿入しないことを表します。グリフの前に文字を挿入するか、後ろに挿入するかはフラグによって決まります。</TD>
    </TR>
    <TR>
      <TD VALIGN="Top">MacKern</TD>
<!--  <TD>This format contains a list of kerning offsets. First is a count field
	saying how many numbers follow, then a list of numbers which adjust the kerning
	for glyphs that have previously been pushed on the kerning stack.</TD> -->
      <TD>このフォーマットはカーニングオフセットのリストを含みます。最初にあるのは個数フィールドで、後ろに何個の数値が続くかを表しており、それに続いて、あらかじめカーニングスタックにプッシュされたグリフのカーニングを調整する数値のリストが置かれます。</TD>
    </TR>
  </TABLE>
  <P>
<!--
  The GenTags entry describes a list of feature tags that FontForge has generated
  itself -->
  項目 GenTags は、FontForge が自分で生成した機能タグのリストを記述します。
  <BLOCKQUOTE>
    <PRE>GenTags: 1 sb'rigl'
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  This line says that FontForge has generated 1 tag, the generated tag is used
  for a substitution lookup (sb=&gt;substitution), and the tag is 'rig1'. -->
  この行は、FontForge が 1 個のタグを生成しており、生成されたタグは置換参照に用いられ (sb⇒substitution)、そのタグ名が&lsquo;rig1&rsquo;であることを表しています。
  <P>
<!--
  There may be a list of Mac Feature/Setting names -->
  Mac の機能/設定の名前リストを置くことができます。
  <BLOCKQUOTE>
    <PRE>MacFeat: 0 0 0
MacName: 0 0 24 "All Typographic Features"
MacSetting: 0
MacName: 0 0 12 "All Features"
MacFeat: 1 0 0
MacName: 0 0 9 "Ligatures"
MacSetting: 0
MacName: 0 0 18 "Required Ligatures"
MacSetting: 2
MacName: 0 0 16 "Common Ligatures"
MacFeat: 2 1 2
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  There may be a Grid entry near the top of the font, this specifies the splines
  to be drawn in the grid layer for the font, <A HREF="#splineset">see below
  for a description of the splineset format</A>: -->
  フォントの先頭近くに項目 Grid を置くことができます。これはフォントのグリッドレイヤに描画されるスプラインを指定します。<A HREF="#splineset">スプラインセットのフォーマットの説明については以下を参照してください</A>:
  <BLOCKQUOTE>
    <PRE>Grid
678 -168 m 5
 -40 -168 l 5
-678 729 m 1
 1452 729 l 1
-678 525 m 1
 1452 525 l 1
EndSplineSet
</PRE>
  </BLOCKQUOTE>
  <H3>
<!--<A NAME="Outline-Char-Data">Outline Character Data</A>-->
    <A NAME="Outline-Char-Data">アウトライン文字データ</A>
  </H3>
  <P>
<!--
  Then for non-CID fonts you should find a line like: -->
  その次に、非 CID フォントでは、以下のような行が現れます:
  <BLOCKQUOTE>
    <PRE>BeginChars: 285 253
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  This means that the font's encoding has room for 285 characters and that
  there are a total of 253 glyphs defined (usually control characters are not
  defined). A character looks like: -->
  これは、フォントのエンコーディングには 285 文字ぶんの場所が取られており、全部で 253 個が定義済みであることを表します (通常、制御文字は定義されません)。文字は以下のように表現されます:
  <BLOCKQUOTE>
    <PRE>StartChar: exclam
Encoding: 33 33 3
Width: 258
Flags: 
HStem: 736 13&lt;39 155&gt;  -14 88&lt;162 180&gt;
VStem: 71 84&lt;49 396&gt; 
Fore
195 742 m 0
 195 738 193 736 189 736 c 0
 175 736 155 743 155 682 c 0
 155 661 130 249 130 131 c 0
 130 100 96 99 96 131 c 0
 96 149 71 662 71 682 c 0
 71 731 51 736 37 736 c 0
 33 736 31 738 31 742 c 0
 31 748 36 747 38 749 c 1
 188 749 l 1
 190 747 195 748 195 742 c 0
80 32 m 0
 81 53 95 75 116 74 c 0
 137 73 150 53 150 32 c 0
 150 10 137 -14 115 -14 c 0
 93 -14 79 10 80 32 c 0
EndSplineSet
EndChar
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  The first line names the character, the next line gives the encoding, first
  in the current font, then in unicode, and finally the original position (GID).
  Then the advance width. -->
  最初の行では文字名を定義しています。次の行では文字符号を定義していて、最初に現在のフォント内の符号値があり、次に Unicode での符号値がきて、最後にフォント独自の位置 (GID) が来ます。それから、次の行に送り幅が来ます。
  <P>
<!--
  Then a set of flags (there are currently five flags: "H" =&gt; the character
  has been changed since last hinted, "M" the character's hints have been adjusted
  manually, "W" the width has been set explicitly, "O" =&gt; the character
  was open when last saved, and "I" the character's instructions are out of
  date). -->
  その次の行にフラグ文字を並べた文字列が来ます (現在 5 つのフラグが定義されています:“H”⇒ 最後にヒント付けを行って以降文字が変更された、“M”⇒ 文字のヒントが手動で調整された、“W”⇒ 幅がユーザの指定で設定された、および“O”⇒ 最後に保存したときにその文字が開いていた、“I”⇒その文字の命令が最新の状態と一致しない) 
  <P>
<!--
  Then horizontal and vertical (postscript) stem hints (set of several two
  number pairs, the first number in the pair is the location of the stem, the
  next number is the width of the stem, the numbers in brokets (&lt;&gt;) indicate
  where the hint is valid). -->
  次に水平および垂直方向の (PostScript) ステムヒントが来ます (いくつかの 2 個の数値対の集まりで、対の最初の数値はステムの位置を表し、次の数値がステムの幅を表し、角括弧 (&lt;&gt;) で囲まれた数値対はそのヒントがどこで有効かを表します)。
  <P>
<!--
  For fonts with vertical metrics there may also be a -->
  縦書きメトリックを含むフォントでは、縦書きの送り幅を指定する
  <BLOCKQUOTE>
    <PRE>VWidth: 1000
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  specifying the vertical advance width. -->
  という定義を置くことができます。
  <P>
<!--
  The entry <CODE>Fore</CODE> starts the foreground
  <A NAME="splineset">splines</A>, they are encoded as postscript commands
  with moveto abbreviated to m, curveto to c and lineto to l (lower case el).
  The digit after after the letter is a set of flags whose bits have the following
  meanings: -->
  項目 <CODE>Fore</CODE> は前面<A NAME="splineset">スプライン</A>の始まりを指定します。それらは PostScript コマンドで表されますが、moveto を m に、curveto を c に、lineto を l (小文字エル) に省略しています。文字の後ろに来る数値はフラグの組で、各ビットには以下のような意味があります。
  <TABLE CELLPADDING="2">
    <TR>
<!--  <TH>mask</TH>-->
      <TH>マスク</TH>
<!--  <TH>meaning</TH>-->
      <TH>意味</TH>
    </TR>
    <TR>
      <TD>0x3</TD>
<!--  <TD>indicates whether the point is curve (0), corner (1) or tangent (2).</TD> -->
      <TD>その点が曲線上の点 (0) か、角の点 (1) か曲線の開始点 (2) であるかを示します。</TD>
    </TR>
    <TR>
      <TD>0x4</TD>
<!--  <TD>point selected</TD>-->
      <TD>この点は選択されている</TD>
    </TR>
    <TR>
      <TD>0x8</TD>
<!--  <TD>point has default next control point</TD>-->
      <TD>この点に、デフォルトの次の制御点が存在する</TD>
    </TR>
    <TR>
      <TD>0x10</TD>
<!--  <TD>pont has default prev control point</TD>-->
      <TD>この点に、デフォルトの前の制御点が存在する</TD>
    </TR>
    <TR>
      <TD>0x20</TD>
<!--  <TD>point is to be rounded in x (truetype hinting. doesn't really work)</TD>-->
      <TD>この点は x 方向に丸められる必要がある (TrueType のヒントづけです。実際には動作しません)</TD>
    </TR>
    <TR>
      <TD>0x40</TD>
<!--  <TD>point is to be rounded in y (truetype hinting. doesn't really work)</TD>-->
      <TD>この点は y 方向に丸められる必要がある (TrueType のヒントづけです。実際には動作しません)</TD>
    </TR>
    <TR>
      <TD>0x80</TD>
<!--  <TD>point was interpolated between two control points (when<BR>
	read from a ttf file) and so has no point number of its own</TD> -->
      <TD>この点は (TTF ファイルからの読み込み時に)  2 個の制御点の中点に<BR>補間されたので、独自の点番号が存在しない</TD>
    <TR>
      <TD>0x100</TD>
<!--  <TD>point should never be interpolated</TD> -->
      <TD>この点は決して補間してはならない</TD>
    </TR>
  </TABLE>
  <P>
<!--
  Splines for a truetype font will have two additional numbers after the flags.
  These are the truetype point numbers for the point itself and for the subsequent
  control point. If the value is -1 then this point has no number. -->
  TrueType フォント用のスプラインには、フラグの後ろに 2 個の追加の数値が存在します。
  点それ自身と、引き続く制御点に対しては TrueType 点番号が振られています。値が -1 の場合は、その点には番号が振られていないことを表します。
  <P>
<!--
  Splines for a font with hint substitution will have a hint mask after any
  point before which hint substitution occurs, -->
  ヒント置換を含むフォントのスプラインは、ヒント置換が発生する全ての点の前にヒントマスクが存在します:
  <BLOCKQUOTE>
    <PRE>459 422 m 1xc0
 339 442 l 1xa0
 312 243 l 1
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  So the first two points have hint masks "xc0" and "xa0", these masks may
  be (almost) arbitrarily long, depending on the number of hints in the glyph.
  "xc0" means that the first two hints are active (0x80 &amp; 0x40) while "xa0"
  means that the first and third are (0x80 and 0x20). -->
  ここでは最初の 2 個の点はヒントマスク“xc0”および“xa0”を含みます。これらのマスクはグリフ内のヒントの個数に応じて (ほとんど) 任意の長さを持つことができます。“xc0”は、最初の 2 個のヒント (0x80 と 0x40) が有効になっていることを示し、“xa0”は、最初と 3 番目 (0x80 と 0x20) が有効であることを意味します。
  <P>
<!--
  A set of splines in the background is similar, it will be introduced by a
  <CODE>Back</CODE> entry. -->
  背景に置かれる一連のスプラインもこれ同様ですが、項目 <CODE>Back</CODE> で始まります。
  <P>
<!--
  While a background image is stored in the following horrible format: -->
  一方、背景イメージは以下の恐ろしげなフォーマットで格納されます:
  <BLOCKQUOTE>
    <PRE>StartChar: A
...
Image: 167 301 0 21 2 1 23 753 2.53892 2.53892
J:N0SYd"0-qu?]szzz!!#7`s7cQozzz!!!!(s8Viozzzz"98E!zzzz!!3-"rVuouzzz!!!'"
s8N'!zzz!!!!$s8W,7zzzz"98E$huE`WzJ+s!Dz!"],0s6p!g!!!!"s8W-!n,NFg!!!Q0s8Vio
z5QCc`s82is!!!!`s8W,gz!WW3"s8W&amp;uzJ,fQKp](9o!!iQ(s8W-!z!&lt;&lt;*!s7cQo!!",@s8W-!
...
EndImage
EndChar
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  Where the numbers on the image line mean respectively: width (of image in
  pixels), height, image type (0=&gt;mono, 1=&gt;indexed, 2=&gt;true), bytes
  per line, number of color entries in the color table, the index in the color
  table of the transparent color (or for true color images the transparent
  color itself), the x and y coordinates of the upper left corner of the image,
  the x and y scale factors to convert image pixels into character units. Then
  follows a bunch of binary data encoded using Adobe's Encode85 filter (See
  the PostScript Reference manual for a description). These data contain all
  the colors in the color table followed by a dump of the image pixel data. -->
  ここで、Image: 行の各数値はそれぞれ以下の意味をもちます: (画像の) 幅 (ピクセル単位)、高さ、画像のタイプ (0⇒単色、1⇒インデックスカラー、2⇒トゥルーカラー)、1 行あたりのバイト数、カラーテーブル内のカラー項目の個数、カラーテーブル内の透明色のインデックス (トゥルーカラー画像においては透明色そのもの)、画像の左上の x 座標および y 座標、画像ピクセルを文字ユニットに変換するための x, y 方向の拡大率です。それから Adobe の Encode85 フィルタによるバイナリデータの束が続きます (この説明は PostScript リファレンスマニュアルを参照してください)。これらのデータはカラーテーブルに含まれる全ての値と、それに続く画像ピクセルデータのダンプです。
  <P>
<!--
  Bitmap data will be compressed by run length encoding. I'm not going to go
  into that in detail, if you want to understand it I suggest you look at the
  file sfd.c and search for image2rle to see how it is done. The image is
  compressed using rle and then output as above, only now there is one more
  parameter on the "Image:" line which gives the number of bytes to be read
  from the data stream. -->
  ビットマップデータはランレングスエンコーディングで圧縮されます。これの詳細を説明するつもりはありませんので、それを理解する必要がある場合はファイル sfd.c から image2rle を検索して、どう処理を行っているかを調べることをお勧めします。画像はランレングスエンコーディング (RLE) で圧縮され、上記の形式で出力されます。この場合のみ、“Image:”にはデータストリームから読み込まれるバイト数を表すもう 1 つのパラメータが必要となります。
  <P>
<!--
  A character need not contain any splines: -->
  文字には、必ずしも何らかのスプラインが含まれないとならないわけではありません。
  <BLOCKQUOTE>
    <PRE>StartChar: semicolon
Encoding: 59 59
Width: 264
Flags: 
HStem: 
VStem: 
Refer: 33 44 N 1 0 0 1 0 0 1
Refer: 35 46 N 1 0 0 1 0 414 2
EndChar
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  Above is one with just references to other characters (a semi-colon is drawn
  here by drawing a comma and stacking a period on top of it). The first number
  is the glyph index of the character being refered to (in the current font
  of course), the next number is the unicode code point, the N says the reference
  is not selected (An "S" indicates it is selected), the following 6 numbers
  are a postscript transformation matrix, the one for comma (unicode 44) is
  the identity matrix, while the one for period (unicode 46) just translates
  it vertically 414 units. The final number is a set of truetype flags: -->
  上の例は、他の文字への参照のみを含んでいる一例です (セミコロンを、カンマを描画して、その上にピリオドを載せることによって描画しています)。最初の数値は参照先の文字のグリフインデックス (当然、現在のフォント内での) です。2 番目の数値は Unicode の符号位置で、N は、参照が選択されていないことを表し、それに続く 6 個の数値は PostScript の変換行列を表します。カンマ (Unicode 44) の行列は恒等行列で、ピリオド (Unicode 46) に対する行列は垂直方向に 414 ユニット平行移動しています。最後の数値は TrueType フラグの集合です:
  <UL>
    <LI>
<!--  1 =&gt; Use My Metrics -->
      1 ⇒ メトリックで使用
    <LI>
<!--  2 =&gt; Round to Grid -->
      2 ⇒ グリッドに合わせて丸める
    <LI>
<!--  4 =&gt; Position reference by point match (rather than by offset)<BR>
      If this is set there will be two additional numbers, the first indicating
      the point number in the base glyph, and the second the point number in the
      current reference. -->
      4 ⇒ (オフセットでなく) 点の一致による位置参照<BR>
      このフラグがセットされている場合、2 個の数字が追加されます。最初の数字は基底グリフ内の点番号で、2 番目の数字は現在の参照における点番号です。
      <BLOCKQUOTE>
	<PRE>Ref: 33 44 N 1 0 0 1 0 0 1
Ref: 35 46 N 1 0 0 1 0 414 6 3 7 O
</PRE>
      </BLOCKQUOTE>
      <P>
<!--  The bottom line indicates that point 3 and point 7 will be positioned together.
      The optional "O" is a flag which indicates that this information is out of
      date. -->
      最後の行は、点 3 と点 7 が一緒には位置されることを示しています。最後の省略可能な “O”は、この情報が最新の状態と一致しないことを表します。
  </UL>
  <P>
<!--
  Old versions of sfd files will use the format: -->
  古い版の SFD ファイルは以下のフォーマットを使っていました:
  <BLOCKQUOTE>
    <PRE>Ref: 44 44 N 1 0 0 1 0 0
Ref: 46 46 N 1 0 0 1 0 414
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  Where the first number gives the refered components' encoding. -->
  この最初の数値は、被参照要素の符号位置を指定しています。
  <P>
<!--
  A postscript glyph may also contain countermasks: -->
  PostScript のグリフにはカウンタマスクを含めることもできます:
  <BLOCKQUOTE>
    <PRE>StartChar: m
Encoding: 109 109 77
Width: 785
HStem: 0 18&lt;28 224 292 488 566 752&gt; 445 27&lt;280 296 542 558&gt;
VStem: 98 56&lt;45 376&gt; 362 56&lt;45 378&gt; 626 56&lt;45 378&gt;
CounterMasks: 1 38
...
EndChar
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  The CounterMasks line in this example declares one counter group (first
  argument). The "38" (and any other values following it) is a bitmask, given
  in hex, that describes a group. The size of the bitmask is always a multiple
  of eight (i.e. always an even number of hex digits). The highest-order bit
  in the mask specifies whether the first stem hint is present (1) or absent
  (0) in the counter group. The second-highest-order bit does the same for
  the second hint, and so on. Any extra low-order bits not corresponding to
  any hint are ignored. (I know, starting from the high bit instead of the
  low bit seems strange, but that was Adobe's design decision.) Here, the third
  (0x20), fourth (0x10) and fifth (0x08) stem hints (i.e. the three vertical
  stems) are in the group, yielding a counter mask of 0x38. If we were to add
  four more VStem hints to the glyph, making nine hints in all, then the mask
  would have to be given as 0x3800 (because two bytes are needed to accommodate
  nine bits).-->
  この例では、CounterMasks: 行は 1 個のカウンタグループを (最初の引数で) 宣言しています。“38”(およびそれに続く他のすべての値) は、16 進表記のビットマスクで、グループを表しています。ビットマスクのサイズは常に 8 の倍数です (つまり、16 進数は常に偶数桁となります)。マスク内の最上位ビットは、最初のステムヒントが存在する(1) か存在しない(0) かを表します。2 番目の上位ビットは同様に 2 番目のヒントに相当し、以下同様です。どのヒントにも対応しない余計な下位ビットはすべて無視されます。(最下位ビットでなく最上位ビットから始めるのは奇妙だと私も知っていますが、これは Adobe の技術的決定です)。ここでは、3 番目 (0x20), 4 番目 (0x10) および 5 番目 (0x08) のステムヒントがグループ内に存在し、カウンタマスク値は 0x38 となっています。グリフに 4 個の VSTEM ヒントを追加した場合、全部でヒントは 9 個となるので、マスクは 0x3800 となります (9 ビットを格納するには 2 バイト必要だからです)。
  <P>
<!--
  If a font has been loaded from a truetype file it may containing hinting
  information (FontForge does not attempt to understand truetype hints, just
  to preserve them) -->
  フォントが TrueType ファイルから読み込まれた場合、ヒント情報を含めることができます (FontForge は TrueType ヒントを理解しようとは試みず、単に保持するだけです)。
  <BLOCKQUOTE>
    <PRE>TtfInstrs: 107
5Xtqo&amp;gTLA(_S)TQj!Kq"UP8&lt;!&lt;rr:&amp;$QcW!"K,K&amp;kWe?(^pl]#mUY&lt;!s\f7"U&gt;G:!%\s-3WRec
$pP.r$uZOWNsl$t"H&gt;'?EW%CM&amp;Cer:&amp;f3P&gt;eEnad5&lt;Qq=rQYuk3AE2g&gt;q7E*
EndTtf
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  This is 107 bytes of ASCII85Encode encoded binary data. -->
  これは ASCII85Encode で符号化された 107 バイトのバイナリデータです。
  <P>
<!--
  If the character contains Anchor Points these will be included: -->
  文字がアンカーポイントを含んでいれば、それらは以下のように取り込まれます:
  <BLOCKQUOTE>
    <PRE>AnchorPoint: "bottom" 780 -60 basechar 0
AnchorPoint: "top" 803 1487 basechar 0
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  the point names the anchor class it belongs to (in UTF-7), its location,
  what type of point it is (basechar, mark, baselig, basemark, entry, exit),
  and for ligatures a number indicating which ligature component it refers
  to. If you have configured fontforge with support for device tables, you
  may also see: -->
  アンカークラスが所属する点の名前 (UTF-7 で)、位置、点のタイプが (基底文字、マーク、基底合字、基底マーク、始筆、収筆のうち) どれであるか、そして合字については、それがどの合字要素を参照しているかを示す番号です。デバイステーブルをサポートする設定でコンパイルされた FontForge を使用している場合、以下のような記述が含まれているかもしれません:
  <BLOCKQUOTE>
    <PRE>AnchorPoint: "bottom" 780 -60 basechar 0 {12-13 -1,-1} {8-14 1,0,-1,-1,-2,-2,-2}
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  Where the items in braces are horizontal/vertical
  <A NAME="device-table">device</A> tables. The first indicates that the
  (horizontal) device table applies to pixel sizes 12 through 13 with pixel
  adjustments of -1 pixel each. The second indicates a vertical device table
  applies to pixel sizes 8 through 14 with pixel adjustments of 1, 0, -1, -1,
  -2, -2, -2 pixels. -->
  ここで、波括弧内の項目は水平/垂直<A NAME="device-table">デバイス</A>テーブルです。最初の括弧は、(水平) デバイステーブルが 12〜13 ピクセルの範囲のサイズで、それぞれ -1 ピクセルの補正を施すことを表しています。2 番目は、垂直デバイステーブルが 8〜14 ピクセルの範囲においてでそれぞれ 1, 0, -1, -1, -2, -2, -2 ピクセルの補正を施すことを表します。
  <P>
<!--
  Finally a TrueType font may position an anchor point based on a normal point
  within the glyph (if this is done a device table may not be present). -->
  最後に、TrueType フォントは 1 個のアンカーポイントをグリフ内の 1 個の基準点に基づいて配置することができます (これが行われる場合、デバイステーブルを置くことはできません)。
  <BLOCKQUOTE>
    <PRE>AnchorPoint: "bottom" 780 -60 basechar 0 23
  </PRE>
  </BLOCKQUOTE>
  <P>
<!--
  Indicates that this anchor point will be positioned at the same location
  (which is normally 780,-60 but which might be moved by an instruction) as
  truetype point 23. -->
  は、このアンカーポイントが TrueType グリフの点番号 23 と同じ位置 (通常は (780,-60) ですが、命令によって移動することができます) に配置されることを表しています。
  <P>
<!--
  If the user has set the glyph class -->
  ユーザがグリフクラスを設定している場合、
  <BLOCKQUOTE>
    <PRE>GlyphClass: 2
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  Where the number is 1 more than the 'GDEF' glyph class it represents. (so
  the 2 above means a base glyph (class 1)). -->
  この番号は、それが表す&lsquo;GDEF&rsquo;グリフクラスよりも 1 つ大きい値になっています (ですから、この例の 2 はベースグリフ (クラス 1) を意味します)
  <P>
<!--
  If the character is the first in any kern pairs (not a pair defined by a
  kern class, however) -->
  その文字がカーニングペアのどれか (ただし、カーニングクラスに定義されているペアを除く) の先頭文字である場合:
  <BLOCKQUOTE>
    <PRE>KernsSLIFO: 60 -100 1 0 {12-13 -1,-1} 63 -92 1 0 70 -123 1 0 45 -107 1 0 76 -107 1 0
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  Where each kern pair is represented by 4 numbers (and an optional
  <A HREF="sfdformat.html#device-table">device</A> table, see above). The first
  is the original position of the second character (in the current font), the
  next is the horizontal kerning amount, then the script lang index, and finally
  the open type flags. Then we start over with the next kernpair. -->
  ここでは各カーニングペアは 4 個の数値 (および省略可能な<A HREF="sfdformat.html#device-table">デバイス</A>テーブル。上記参照) で表されます。最初に来るのは 2 番目の文字の (現在のフォント内での) 位置で、次に来るのは横書きのカーニング量で、スクリプト・言語インデックスがその次に置かれ、最後に OpenType のフラグが来ます。それから、次のカーニングペアの記述が始まります。
  <P>
<!--
  Old sfd files may contain a slightly different format:-->
  古い SFD ファイルは以下の僅かに異なるフォーマットの行を含んでいるかもしれません:
  <BLOCKQUOTE>
    <PRE>KernsSLIF: 114 -100 1 0 {12-13 -1,-1} 117 -92 1 0 101 -123 1 0 97 -107 1 0 111 -107 1 0
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  where the first number is the encoding of the second glyph in the kern pair. -->
  ここで、最初の数値はカーニングペアの 2 番目のグリフの符号位置です。
  <P>
<!--
  Data that are to go into other GPOS, GSUB or GDEF sub-tables are stored like
  this: -->
  その他の GPOS, GSUB または GDEF サブテーブルに送られるデータは、以下のような形で格納されます:
  <BLOCKQUOTE>
    <PRE>Position: 12 0 'sinf' dx=0 dy=-900 dh=0 dv=0
PairPos: 12 0 'dist' B dx=0 dy=0 dh=0 dv=0  dx=-10 dy=0 dh=0 dv=0
Ligature: 12 0 'frac' one slash four
Substitution: 12 3 'smcp' agrave.sc
AlternateSubs: 12 0 'swsh' glyph490 A.swash
MultipleSubs: 12 0 'ccmp' a grave
Ligature: 12 4 'liga' f f
LCarets: 0 0 '    ' 1 650 
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  In most of these lines the first two numbers provide a script lang index
  and a set of opentype flags (except for LCarets where they are ignored).
  This is followed by an opentype tag (also ignored for ligature carets). A
  simple position change is expressed by the amount of movement of the glyph
  and of the glyph's advance width. A ligature contains the names of the characters
  of two adjacent glyphs (kerning is a special case of this). A ligature contains
  the names of the characters that make it up. A simple substitution contains
  the name of the character that it will become. An alternate sub contains
  the list of characters that the user may choose from. A multiple substitution
  contains the characters the current glyph is to be decomposed into. A ligature
  caret contains a count of the number of carets defined, and the a list of
  the locations of those carets. -->
  これらの行のほとんどは、最初の 2 個の数値では用字系/言語インデックスと、一連の OpenType フラグの情報を提供しています (LCaret は例外で、それらは無視されます)。その後ろに OpenType が来ます (合字キャレットではこれらも無視されます)。単純位置変更はグリフの移動量とグリフの送り幅によって表現されます。ペア単位の位置指定は 2 個の隣り合うグリフの位置を指定します (カーニングはこの特殊な場合です)。合字には、それを構成する各文字の名前が含まれます。単純置換には、それが置き換えられる文字の名前が含まれます。選択型置換には、ユーザが選ぶ文字のリストが含まれます。複数置換は現在のグリフが分解される文字群が含まれます。合字キャレットには、定義されるキャレットの個数と、それらのキャレットの位置のリストが含まれます。
  <P>
<!--
  A glyph may have an arbitrary comment associated with it, this will be output
  in UTF-7 -->
  グリフには、それに付随する任意のコメント (UTF-7 で出力されます) や、
  <BLOCKQUOTE>
    <PRE>Comment: Hi
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  or a color -->
  または色をもたせることができます。
  <BLOCKQUOTE>
    <PRE>Colour: ff0000
</PRE>
  </BLOCKQUOTE>
  <H4>
<!--Outline character extensions for multilayered fonts (type3)-->
    複数レイヤフォント (Type3) のためのアウトラインフォントの拡張
  </H4>
  <P>
<!--
  (these are only supported if FontForge has been configured for multi-layered
  editing) -->
  これらは、FontForge の複数レイヤ編集機能が有効な設定のときのみにサポートされます。
  <P>
<!--
  Instead of having a single "Fore"ground layer, multilayered fonts have
  (potentially) several layers, each one introduced by a Layer line which specifies
  things like filling and stroking info for this layer, within each layer are
  a splineset, a list of references and a list of images (any or all may be
  omitted). The syntax for these is the same as in the normal case above. -->
  複数レイヤフォントは“Fore”で前面レイヤを 1 個定義するだけでなく、複数のレイヤをもつ (ことが可能な) もので、各レイヤには、そのレイヤの塗りつぶしや太線のような物を指定する Layer: 行が存在し、各レイヤにはスプラインセット、参照のリストや画像のリストが含まれます (これらの任意の物を省略することができます)。これらの構文は、上で説明した通常の場合と同じです。
  <BLOCKQUOTE>
    <PRE>LayerCount: 3
Layer: 1  1 1 1  #fffffffe 1  #fffffffe 1 40 round round [1 0 0 1] []
SplineSet
...
EndSplineSet
Layer: 2  1 0 1  #00ff00 1  #0000ff 1 19 miter butt [0.5 0 0 1] [10 5]
SplineSet
...
EndSplineSet
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  The LayerCount line gives the number of layers in the glyph (the background
  layer is layer 0, so this number is one more than the number of layers that
  will actually be specified -- the background layer is still specified the
  way it was before, but is included in this count). This line is not required,
  if omitted (or wrong) FontForge will figure that out. -->
  LayerCount: 行は、グリフ内のレイヤの個数を指定します (背景レイヤはレイヤ 0 なので、この個数は実際に指定されている個数より 1 多くなります——背景レイヤは通常フォントと同様の方法で格納されますが、個数の勘定には入ります)。この行は必須ではなく、省略された (または間違いの) 場合、FontForge は自分で個数を算定します。
  <P>
<!--
  The Layer line contains too much information. First is a number saying which
  layer, next are three booleans, the first specifies whether to fill the splineset
  (or use an imagemask for images), the second whether to stroke the splineset,
  the third is currently pretty much meaningless. Next follows the RGB value
  of the fill color (the special value of #fffffffe means the color is
  inherited), then the opacity (the special value -1 means inherited), then
  the stroke color and opacity. Then the stroke width (again -1 means inherited),
  the linejoin type (miter, round, bevel, inherited), the linecap type (butt,
  round,square,inherited), the transformation matrix to be applied to the pen
  and finally the dash array. -->
  Layer: 行にはあまりにも多量すぎる情報を含んでいます。最初は何番目のレイヤかを表す数字です。その次には 3 個のブール値があり、1 個目はスプラインセットを塗り潰すかどうかを表し、2 番目はスプラインセットをストロークとして描くかどうかを表し、3 番目は現在のところ全く無意味です。その次に、塗り潰し色の RGB 値が続き (特別な値 #fffffffe は、色が継承されることを意味します)、次に透明度 (特別な値 -1 は、継承を意味します)。次にストロークの色と透明度が続きます。それからストロークの太さ (この場合も -1 が継承されることを表します)、線の結びのタイプ (miter, round, bevel, inherited のいずれか), 線端のタイプ (butt, round, square, inherited のいずれか)、ペンに適用される変換行列が来て、最後に、破線を表す配列が来ます。
  <P>
<!--
  Any SplineSet, Ref, Images between this Layer and the next (or the end of
  the character) are part of this layer. -->
  この Layer 行から次の Layer 行 (またはこの文字の終り) までに来るすべての SplineSet, Ref, Images はこのレイヤの一部であるとして扱われます。
  <H3>
<!--<A NAME="Bitmap-Fonts">Bitmap Fonts</A> -->
    <A NAME="Bitmap-Fonts">ビットマップフォント</A>
  </H3>
  <P>
<!--
  After all the outline characters have been described there is an EndChars
  entry and then follow any bitmap fonts: -->
  アウトライン文字の記述がすべて終った後、項目 EndChars が 1 個あり、ビットマップフォントはすべてその後に出現します。
  <BLOCKQUOTE>
    <PRE>EndChars
BitmapFont: 12 285 10 2 1
BDFStartProperties: 2
COMMENT 0 "This is a bdf comment property"
FONT_DESCENT 18 2
BDFEndProperties
Resolution: 75
BDFChar: 32 3 0 0 0 0
z
BDFChar: 3 33 3 0 1 0 9
^d(.M5X7S"!'gMa
</PRE>
</BLOCKQUOTE>
<P>
<!--
  The bitmap font line contains the following numbers: the pixelsize of the
  font, the number of potential characters in the font, the ascent and the
  descent of the font and the depth of font (number of bits in a pixel). -->
  BitmapFont: 行には以下の数値が含まれます: フォントのピクセルサイズ、フォント内の可能な文字の個数、フォントの高さおよび深さおよび諧調 (1 ピクセルあたりのビット数) です。
  <P>
<!--
  Optionally there may be a set of BDF properties. If there are any properties
  there will be a line "BDFStartProperties:" with a count of properties. There
  should be that many property lines, and then a "BDFEndProperties" line. Each
  property is of the form:<BR> -->
  そこには省略可能な BDF の属性値を書き込むことができます。何らかの属性がある場合には、“BDFStartProperties:”の後に属性の個数を並べた行が置かれます。指定した個数だけの属性行を並べ、最後に“BDFEndProperties”という行がくる必要があります。各属性は以下のような形で指定します:<BR>
  <CODE>&lt;NAME&gt; &lt;TYPE&gt; &lt;VALUE&gt;</CODE><BR>
<!--
  Where &lt;NAME&gt; is the property name, &lt;TYPE&gt; is 0 for a string,
  1 for an atom, 2 for an int, 3 for an unsigned int. In addition
  &lt;TYPE&gt; may have a 16 ored to one of the above values indicating the
  line is a true property (rather than information from somewhere else in the
  BDF header). &lt;VALUE&gt; will either be a quoted string or an integer. -->
  ここで &lt;NAME&gt; は属性名、&lt;TYPE&gt; は 0: 文字列・1: アトム、2: 整数、3: 符号なし整数を表します。さらに、それらの値が (BDF ヘッダの他のどこかから持ってきた値ではなく) 真の設定値を表す場合に &lt;TYPE&gt; の値は 16 との論理和を取った値を格納します。&lt;VALUE&gt; は引用符で囲った文字列か整数かのいずれかです。
  <P>
<!--
  Optionally there may be a resolution line, which specifies the design resolution
  of the font. -->
  フォントのデザイン解像度を指定する“Resolution:”行 (省略可能) を最後に置くことができます。
  <P>
<!--
  This is followed by a list of bitmap characters, the bitmap character line
  contains the following numbers: the original position, the encoding (local),
  the width, the minimum x value, the minimum y value, the maximum x value
  and the maximum y value. If the bitmap font has vertical metrics there will
  also be a vwidth. This is followed by another set of binary data encoded
  as above. There will be (ymax-ymin+1)* ((xmax-xmin)/(8/depth)+1) (unencoded)
  bytes, there is no color table here (the high order bit comes first in the
  image, set bits should be colored black, clear bits transparent). -->
これに続き、ビットマップ文字のリストが続きます。BDFChar: 行には以下の数値が含まれます: 元の位置、(フォント内での) 符号位置、幅、x 座標の最小値、y 座標の最小値、x 座標の最大値および y 座標の最大値です。もし、ビットマップに縦書メトリックが存在する場合、縦方向の送り幅が追加されます。この後ろには、上記の例のようにエンコードされた 1 組のデータがさらに続き、このデータの (エンコード前の) サイズは (ymax-ymin-1)*((xmax-xmin+8)/8) バイトになります。ここにはカラーテーブルはありません (上位ビットが画像の最初に来て、1 になっているビットが黒く塗られ、0 のビットが透明になります)。
  <P>
<!--
  A bitmap font is ended by: -->
  ビットマップフォントは次のようにして終了します:
  <BLOCKQUOTE>
    <PRE>EndBitmapFont
BitmapFont: 17 285 14 3 1
BDFChar: 0 17 0 0 0 0
z
...
EndBitmapFont
EndSplineFont
</PRE>
  </BLOCKQUOTE>
  <H3>
<!--<A NAME="CID-keyed-fonts">CID keyed fonts</A>-->
    <A NAME="CID-keyed-fonts">CID キー指定フォント</A>
  </H3>
  <P>
<!--
  A CID font is saved slighlty differently. It begins with the normal font
  header which contains the information in the top level CID font dictionary.
  As mentioned above this will include special keys that specify the CID charset
  (registry, ordering, supplement). It will also include: -->
  CID フォントはわずかに異なる形で保存されます。それは通常のフォントヘッダで始まりますが、そこにはトップレベルの CID フォント辞書に含まれる情報が格納されます。上で述べたように、これには CID 文字集合 (登録簿、順序づけ、補遺番号) を指定する特別なキーを含んでいるでしょう。そこには以下のような行も含まれるはずです:
  <BLOCKQUOTE>
    <PRE>CIDVersion: 2.0
BeginSubFonts: 5 8318
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  The <CODE>CIDVersion</CODE> is self-explanatory. The
  <CODE>BeginSubFonts</CODE> line says that there are 5 subfonts the largest
  of which contains slots for 8318 characters (again some of these may not
  be defined). This will be followed by a list of the subfonts (dumped out
  just like normal fonts) and their characters. Only the top level font will
  contain any bitmap characters, anchor classes, etc. -->
  <CODE>CIDVersion</CODE> はその名の通りです。<CODE>BeginSubFonts</CODE> 行では、 5 個のサブフォントが存在し、そのうちの最大のものは 8318 文字ぶんのスロットが含まれることを示します (この場合も、そのうちのいくつかは定義できません)。これに続きサブフォントのリスト (通常のフォントと同じ形で出力されます) と、それらに含まれる文字が続きます。トップレベルフォントのみがビットマップ文字、アンカークラスなどを含むことができます。
  <H3>
<!--<A NAME="Multiple-Master-fonts">Multiple Master fonts</A>-->
    <A NAME="Multiple-Master-fonts">マルチプルマスターフォント</A>
  </H3>
  <P>
<!--
  Multiple master fonts start with a different style of file header, and are
  followed by a set of sub fonts. If the mm font has 4 instances then there
  will be 5 subfonts (one for each instance, and one for the blended font).
  The font header looks like: -->
  マルチプルマスターフォントは異なるスタイルのファイルヘッダから始まり、それに続いて一連のサブフォントの置かれます。マルチプルマスターフォントに 4 個のインスタンスがある場合は、5 個のサブフォントが存在します (各インスタンスにつき 1 個、混ぜ合わせたフォントにもう 1 個)。フォントヘッダは以下のような形です:
  <BLOCKQUOTE>
    <PRE>SplineFontDB: 1.0
MMCounts: 4 2 0 0
MMAxis: Weight Width
MMPositions: 0 0 1 0 0 1 1 1
MMWeights: 0.31502 0.13499 0.38499 0.16499
MMAxisMap: 0 2 0=&gt;50 1=&gt;1450
MMAxisMap: 1 2 0=&gt;50 1=&gt;1450
MMCDV:
{
1 index 1 2 index sub mul 3 1 roll 
1 2 index sub 1 index mul 3 1 roll 
1 index 1 index mul 3 1 roll 
pop pop
0 1 1 3 {index add} for 1 exch sub 4 1 roll
}
EndMMSubroutine
MMNDV:
{
exch 50 sub 1400 div
exch 50 sub 1400 div
}
EndMMSubroutine
BeginMMFonts: 5 0
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  The "MMCounts" line gives the number of instances (4) and the number of axes
  (2) in this font also whether it is an apple distortable font (0) and if
  so the number of named styles (0) in that font. The "MMAxis" line gives the
  names of the axes. The MMPositions line is an array of real numbers (with
  instance_count*axis_count elements) describing the coordinates of each instance
  along each axis. The MMWeights line provides the weights (blends) of the
  instance fonts to which, when interpolated, yield the default font. There
  will be one AxisMap line for each axis, it provides the mapping from design
  space to normalized space. The first line -->
  "MMCounts" 行 では、このフォントに含まれるインスタンスの個数 (4) と軸の本数 (2) に加え、これが Apple 変形可能フォントであるか (0) と、その場合、そのフォントに含まれる名前つきスタイルの個数 (0) を指定します。"MMAxis" 行は、軸の名前を指定します。MMPositions 行は (インスタンスの個数×軸の本数 個の要素からなる) 実数の配列で、各インスタンスの各軸に沿った座標を記述します。MMWeights 行は、補間を行ったときにデフォルトフォントとなるインスタンスフォントのウェイト (混ぜ合わせ) を記述します。AxisMap 行が各軸ごとに 1 個存在し、これは、デザイン空間から正規化された空間への対応づけを提供します。最初の行
  <BLOCKQUOTE>
    <PRE>MMAxisMap: 0 2 0=&gt;50 1=&gt;1450
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  says that axis 0 has two mapping points. One is at normalized position 0
  and corresponds to design position 50, the other is at normalized position
  1 and corresponds to design position 1450. There are two subroutines stored
  here, both are simple postscript. The first is the /NormalizeDesignVector
  routine and the second is the /ConvertDesignVector routine. -->
  では、軸 0 には 2 箇所の点の対応づけが存在することを表します。片方は正規化された位置 0 で、デザイン位置 50 に該当し、もう片方は正規化された位置 1 でデザイン位置 1450 に該当します。ここに格納された 2 個のサブルーチンが存在し、どちらも単純な PostScript です。最初は /NormalizeDesignVector ルーチンで、2 番目は /ConvertDesignVector ルーチンです。
  <P>
<!--
  Finally we have the actual instance fonts.  -->
  最後に、実際のインスタンスフォントが来ます。
    <HR>
  <P>
<!--
  Fonts with information for Apple's '*var' tables ('fvar', 'gvar', 'avar'
  and 'cvar') have a slightly different format: -->
  Apple の&lsquo;*var&rsquo;テーブル群 (&lsquo;fvar&rsquo;,&lsquo;gvar&rsquo;,&lsquo;avar&rsquo;および&lsquo;cvar&rsquo;) の情報を含むフォントはわずかにフォーマットが異なります。
  <BLOCKQUOTE>
    <PRE>MMCounts: 8 2 1 10
MMAxis: Weight Width
MMPositions: 1 0 -1 0 0 1 0 -1 -1 -1 1 -1 1 1 -1 1
MMWeights: 0 0 0 0 0 0 0 0
MMAxisMap: 0 3 -1=&gt;0.479996 0=&gt;1 1=&gt;3.2
MacName: 0 0 6 "Weight"
MacName: 0 1 15 "Type de graisse"
...
MMAxisMap: 1 3 -1=&gt;0.619995 0=&gt;1 1=&gt;1.3
MacName: 0 0 5 "Width"
MacName: 0 1 7 "Largeur"
...
MMNamedInstance: 0  3.2 1
MacName: 0 0 5 "Black"
MacName: 0 1 9 "Tr\217s gras"
...
</PRE>
</BLOCKQUOTE>
  <P>
<!--
  In Adobe's format coordinates range between [0,1], while in Apple's format
  they range [-1,1]. Adobe generally specifies 2 instances per axis (at the
  extrema) while Apple expects 3 (the extrema and the default setting at 0).
  So a two axis font for Adobe will normally contain 4 instances and a default
  version, while one for Apple will contain 8 instances and a default version.
  The MMWeights field is irrelevant for Apple. Each axis has a set of names,
  for that axis translated into various languages. Finally Apple allows certain
  points in design space to be given names, here the point Weight=3.2, Width=1
  is named "Black" or "Tr&eacute;s gras". -->
  Adobe のフォーマットでは、座標は区間 [0, 1] をとりますが、Apple のフォーマットでは範囲は [-1, 1] となります。Adobe では一般に、軸ごとに 2 個のインスタンスを(極値で) 指定しますが、Apple では 3 つ (極値と、0 におけるデフォルトの設定) を想定しています。ですから Adobe 方式の 2 軸のフォントでは通常 4 個のインスタンスとデフォルトの版を含むことになりますが、Apple 方式のフォントでは 8 個のインスタンスとデフォルトの版を含むことになります。MMWeights フィールドは、Apple では不適切です。各軸には 1 組の名前があり、各種の言語に翻訳されたその軸の名前を表します。最後に、Apple ではデザイン空間上のいくつかの点に名前をつけることができます。ここでは Weight=3.2, Width=1 の点には“Black”または“Tr&eacute;s gras”という名前がつけられています。
  <H2>
<!--<A NAME="Autosave-Format">Autosave Format</A>-->
    <A NAME="Autosave-Format">自動保存フォーマット</A>
  </H2>
  <P>
<!--
  <A HREF="errrecovery.html">Error recovery</A> files are saved in
  ~/.FontForge/autosave, they have quite random looking names and end in .asfd.
  They look very similar to .sfd files above. -->
  <A HREF="errrecovery.html">エラー回復</A>ファイルは ~/.FontForge/autosave に保存され、それらはランダムに見える名前がついていて最後に .asfd で終ります。これは上記の .sfd ファイルと非常によく似ています。
  <P>
<!--
  If an asfd file starts with a line: -->
  ある asfd ファイルが次の行で始まるとしたら:
  <BLOCKQUOTE>
    <PRE>Base: /home/gww/myfonts/fontforge/Ambrosia.sfd
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  Then it is assumed to be a list of changes applied to that file (which may
  be an sfd file or a font file). If it does not start with a
  "<CODE>Base:</CODE>" line then it is assumed to be a new font. The next line
  contains the encoding, as above. The next line is a <CODE>BeginChars</CODE>
  line. The number given on the line is not the number of characters in the
  file, but is the maximum number that could appear in the font. Then follows
  a list of all changed characters in the font (in the format described above). -->
  この場合、それはそのファイル (これは SFD ファイルでもフォントファイルでも構いません) に適用された変更のリストであると想定されます。最初の行が "<CODE>Base:</CODE>" でない場合、新しいフォントであると想定されます。次の行には通常と同様の文字符号が含まれます。その次の行が <CODE>BeginChars</CODE> 行です。この行の数値はファイル内の文字数ではなく、フォント内に現れることのできる最大の数値です。その後ろにフォント内の変更された全ての文字のリストが (上で説明したフォーマットで) 続きます。
  <P>
<!--
  Bitmaps are not preserved. Grid changes are not preserved. -->
  ビットマップは保存されません。グリッドの変更は保存されません。
  <P>
  <P ALIGN=Center>
  — <A HREF="src.html">前</A> — <A HREF="overview.html">目次</A> —
  <A HREF="bezier.html">次</A> —
  <P ALIGN=Left>
<!--
  <A NAME="ASCII85Encode"><SUP>1</SUP>ASCII85Encode</A>: an encoding which
  takes 4 binary bytes and converts them to 5 ASCII characters between '!'
  and 'u'. Suppose we have 4 binary bytes: (b1 b2 b3 b4) then we want to find
  (c1 c2 c3 c4 c5) such that: -->
  <A NAME="ASCII85Encode"><SUP>1</SUP>ASCII85Encode</A>: 4 バイトのバイナリを&lsquo;!&rsquo;から&lsquo;u&rsquo;までの ASCII 文字 5 文字に変換する符号化方式の一つです。バイナリ 4 バイト (b1 b2 b3 b4) があるとして、それに対して次の条件を満たす (c1 c2 c3 c4 c5) を探すことを考えましょう:
  <BLOCKQUOTE>
    <PRE><I>b<SUB>1</SUB> * 256<SUP>3</SUP>  +  b<SUB>2</SUB> * 256<SUP>2</SUP>  +  b<SUB>3</SUB> * 256  +  b<SUB>4</SUB> =</I>
<I>	c<SUB>1</SUB> * 85<SUP>4</SUP>  +  c<SUB>2</SUB> * 85<SUP>3</SUP>  +  c<SUB>3</SUB> * 85<SUP>2</SUP>  +  c<SUB>4</SUB> * 85  +  c<SUB>5</SUB></I>
</PRE>
  </BLOCKQUOTE>
  <P>
<!--
  The final output is obtained by adding 33 ('!') to each of the
  <I>c<SUB>i</SUB></I>. If all four bytes are 0, then rather than writing '!!!!!',
  the letter 'z' may be used instead. -->
  最終的な出力は、<I>c<SUB>i</SUB></I> のそれぞれの値に 33 (&lsquo;!&rsquo;) を加えることによって得られます。4 つのバイトがすべて 0 の場合、&lsquo;!!!!!&rsquo;を書き出さないで代わりに文字&lsquo;z&rsquo;を使うことができます。
  <P>
<!--
  Unfortunately, not all streams of binary data have a length divisible by
  4. So at the end of the run, assume there are <I>n</I> bytes left over. Append
  <I>4-n</I> zero bytes to the data stream, and apply the above transformation
  (without the 'z' special case for all zeros), and output <I>n+1 </I>of the
  <I>c<SUB>i</SUB></I> bytes. -->
  残念ながら、バイナリデータのストリームの長さは必ずしも 4 で割り切れるわけではありません。そこで、一連のデータの最後に <I>n</I> バイトが残っていたとしましょう。その場合、<I>4-n</I> 個のゼロバイトをデータストリームの末尾に付け加え、上記の変換を適用し (すべてゼロの場合に&lsquo;z&rsquo;を出力する特別な処理を除く)、<I>c<SUB>i</SUB></I> のバイト列のうち最初の <I>n+1</I> 個を出力します。
  <P>
<!--
  So to encode a single 0 byte we would: -->
  ですから、1 個のバイト値 0 を変換するした場合には以下のようになります:
  <UL>
    <LI>
<!--  append 3 additional 0 bytes (n==1 =&gt; add 4-1=3 bytes)-->
      3 個の追加の 0 を後ろに追加する (n==1 ⇒ 4-1=3 バイトを追加)
    <LI>
<!--  find that all the <I>c<SUB>i</SUB></I> were also zero-->
      すべての <I>c<SUB>i</SUB></I> が 0 になる
    <LI>
<!--  add '!' to each (all are now '!')-->
      それぞれに&lsquo;!&rsquo;を加える (全バイトが&lsquo;!&rsquo;になる)
    <LI>
<!--  output two&lsquo;!&rsquo;(n+1 = 2)-->
      2 個の&lsquo;!&rsquo;を追加する (n+1 = 2 だから)
  </UL>
  <P>
</DIV>
</BODY></HTML>
