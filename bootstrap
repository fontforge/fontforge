#! /bin/sh

# Bootstrap an Autotooled package from checked-out sources.
# Written by Gary V. Vaughan, 2010

# Copyright (C) 2010-2012 Free Software Foundation, Inc.
# This is free software; see the source for copying conditions.  There is NO
# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

# Source required external libraries:
# Set a version string for this script.
scriptversion=2014-07-30.00; # UTC

# General shell script boiler plate, and helper functions.
# Written by Gary V. Vaughan, 2004

# Copyright (C) 2004-2012 Free Software Foundation, Inc.
# This is free software; see the source for copying conditions.  There is NO
# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

# As a special exception to the GNU General Public License, if you distribute
# this file as part of a program or library that is built using GNU Libtool,
# you may include this file under the same distribution terms that you use
# for the rest of that program.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNES FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

# Please report bugs or propose patches to gary@gnu.org.


## ------ ##
## Usage. ##
## ------ ##

# Evaluate this file near the top of your script to gain access to
# the functions and variables defined here:
#
#   . `echo "$0" | ${SED-sed} 's|[^/]*$||'`/build-aux/funclib.sh
#
# If you need to override any of the default environment variable
# settings, do that before evaluating this file.


## -------------------- ##
## Shell normalisation. ##
## -------------------- ##

# Some shells need a little help to be as Bourne compatible as possible.
# Before doing anything else, make sure all that help has been provided!

DUALCASE=1; export DUALCASE # for MKS sh
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '${1+"$@"}'='"$@"'
  setopt NO_GLOB_SUBST
else
  case `(set -o) 2>/dev/null` in *posix*) set -o posix ;; esac
fi

# NLS nuisances: We save the old values in case they are required later.
_G_user_locale=
_G_safe_locale=
for _G_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES
do
  eval "if test set = \"\${$_G_var+set}\"; then
          save_$_G_var=\$$_G_var
          $_G_var=C
	  export $_G_var
	  _G_user_locale=\"$_G_var=\\\$save_\$_G_var; \$_G_user_locale\"
	  _G_safe_locale=\"$_G_var=C; \$_G_safe_locale\"
	fi"
done

# CDPATH.
(unset CDPATH) >/dev/null 2>&1 && unset CDPATH

# Make sure IFS has a sensible default
sp=' '
nl='
'
IFS="	$sp$nl"

# There are still modern systems that have problems with 'echo' mis-
# handling backslashes, among others, so make sure $bs_echo is set to a
# command that correctly interprets backslashes.
# (this code from Autoconf 2.68)

# Printing a long string crashes Solaris 7 /usr/bin/printf.
bs_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
bs_echo=$bs_echo$bs_echo$bs_echo$bs_echo$bs_echo
bs_echo=$bs_echo$bs_echo$bs_echo$bs_echo$bs_echo$bs_echo
# Prefer a ksh shell builtin over an external printf program on Solaris,
# but without wasting forks for bash or zsh.
if test -z "$BASH_VERSION$ZSH_VERSION" \
    && (test "X`print -r -- $bs_echo`" = "X$bs_echo") 2>/dev/null; then
  bs_echo='print -r --'
  bs_echo_n='print -rn --'
elif (test "X`printf %s $bs_echo`" = "X$bs_echo") 2>/dev/null; then
  bs_echo='printf %s\n'
  bs_echo_n='printf %s'
else
  if test "X`(/usr/ucb/echo -n -n $bs_echo) 2>/dev/null`" = "X-n $bs_echo"; then
    bs_echo_body='eval /usr/ucb/echo -n "$1$nl"'
    bs_echo_n='/usr/ucb/echo -n'
  else
    bs_echo_body='eval expr "X$1" : "X\\(.*\\)"'
    bs_echo_n_body='eval
      arg=$1;
      case $arg in #(
      *"$nl"*)
	expr "X$arg" : "X\\(.*\\)$nl";
	arg=`expr "X$arg" : ".*$nl\\(.*\\)"`;;
      esac;
      expr "X$arg" : "X\\(.*\\)" | tr -d "$nl"
    '
    export bs_echo_n_body
    bs_echo_n='sh -c $bs_echo_n_body bs_echo'
  fi
  export bs_echo_body
  bs_echo='sh -c $bs_echo_body bs_echo'
fi


## ------------------------------- ##
## User overridable command paths. ##
## ------------------------------- ##

# All uppercase variable names are used for environment variables.  These
# variables can be overridden by the user before calling a script that
# uses them if a suitable command of that name is not already available
# in the command search PATH.

: ${CP="cp -f"}
: ${ECHO="$bs_echo"}
: ${EGREP="grep -E"}
: ${FGREP="grep -F"}
: ${GREP="grep"}
: ${LN_S="ln -s"}
: ${MAKE="make"}
: ${MKDIR="mkdir"}
: ${MV="mv -f"}
: ${RM="rm -f"}
: ${SED="sed"}
: ${SHELL="${CONFIG_SHELL-/bin/sh}"}


## -------------------- ##
## Useful sed snippets. ##
## -------------------- ##

sed_dirname='s|/[^/]*$||'
sed_basename='s|^.*/||'

# Sed substitution that helps us do robust quoting.  It backslashifies
# metacharacters that are still active within double-quoted strings.
sed_quote_subst='s|\([`"$\\]\)|\\\1|g'

# Same as above, but do not quote variable references.
sed_double_quote_subst='s/\(["`\\]\)/\\\1/g'

# Sed substitution that turns a string into a regex matching for the
# string literally.
sed_make_literal_regex='s|[].[^$\\*\/]|\\&|g'

# Sed substitution that converts a w32 file name or path
# which contains forward slashes, into one that contains
# (escaped) backslashes.  A very naive implementation.
sed_naive_backslashify='s|\\\\*|\\|g;s|/|\\|g;s|\\|\\\\|g'

# Re-'\' parameter expansions in output of sed_double_quote_subst that
# were '\'-ed in input to the same.  If an odd number of '\' preceded a
# '$' in input to sed_double_quote_subst, that '$' was protected from
# expansion.  Since each input '\' is now two '\'s, look for any number
# of runs of four '\'s followed by two '\'s and then a '$'.  '\' that '$'.
_G_bs='\\'
_G_bs2='\\\\'
_G_bs4='\\\\\\\\'
_G_dollar='\$'
sed_double_backslash="\
  s/$_G_bs4/&\\
/g
  s/^$_G_bs2$_G_dollar/$_G_bs&/
  s/\\([^$_G_bs]\\)$_G_bs2$_G_dollar/\\1$_G_bs2$_G_bs$_G_dollar/g
  s/\n//g"


## ----------------- ##
## Global variables. ##
## ----------------- ##

# Except for the global variables explicitly listed below, the following
# functions in the '^func_' namespace, and the '^require_' namespace
# variables initialised in the 'Resource management' section, sourcing
# this file will not pollute your global namespace with anything
# else. There's no portable way to scope variables in Bourne shell
# though, so actually running these functions will sometimes place
# results into a variable named after the function, and often use
# temporary variables in the '^_G_' namespace. If you are careful to
# avoid using those namespaces casually in your sourcing script, things
# should continue to work as you expect. And, of course, you can freely
# overwrite any of the functions or variables defined here before
# calling anything to customize them.

EXIT_SUCCESS=0
EXIT_FAILURE=1
EXIT_MISMATCH=63  # $? = 63 is used to indicate version mismatch to missing.
EXIT_SKIP=77	  # $? = 77 is used to indicate a skipped test to automake.

# Allow overriding, eg assuming that you follow the convention of
# putting '$debug_cmd' at the start of all your functions, you can get
# bash to show function call trace with:
#
#    debug_cmd='eval echo "${FUNCNAME[0]} $*" >&2' bash your-script-name
debug_cmd=${debug_cmd-":"}
exit_cmd=:

# By convention, finish your script with:
#
#    exit $exit_status
#
# so that you can set exit_status to non-zero if you want to indicate
# something went wrong during execution without actually bailing out at
# the point of failure.
exit_status=$EXIT_SUCCESS

# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh
# is ksh but when the shell is invoked as "sh" and the current value of
# the _XPG environment variable is not equal to 1 (one), the special
# positional parameter $0, within a function call, is the name of the
# function.
progpath=$0

# The name of this program.
progname=`$bs_echo "$progpath" |$SED "$sed_basename"`

# Make sure we have an absolute progpath for reexecution:
case $progpath in
  [\\/]*|[A-Za-z]:\\*) ;;
  *[\\/]*)
     progdir=`$bs_echo "$progpath" |$SED "$sed_dirname"`
     progdir=`cd "$progdir" && pwd`
     progpath=$progdir/$progname
     ;;
  *)
     _G_IFS=$IFS
     IFS=${PATH_SEPARATOR-:}
     for progdir in $PATH; do
       IFS=$_G_IFS
       test -x "$progdir/$progname" && break
     done
     IFS=$_G_IFS
     test -n "$progdir" || progdir=`pwd`
     progpath=$progdir/$progname
     ;;
esac


## ----------------- ##
## Standard options. ##
## ----------------- ##

# The following options affect the operation of the functions defined
# below, and should be set appropriately depending on run-time para-
# meters passed on the command line.

opt_dry_run=false
opt_quiet=false
opt_verbose=false

# Categories 'all' and 'none' are always available.  Append any others
# you will pass as the first argument to func_warning from your own
# code.
warning_categories=

# By default, display warnings according to 'opt_warning_types'.  Set
# 'warning_func'  to ':' to elide all warnings, or func_fatal_error to
# treat the next displayed warning as a fatal error.
warning_func=func_warn_and_continue

# Set to 'all' to display all warnings, 'none' to suppress all
# warnings, or a space delimited list of some subset of
# 'warning_categories' to display only the listed warnings.
opt_warning_types=all


## -------------------- ##
## Resource management. ##
## -------------------- ##

# This section contains definitions for functions that each ensure a
# particular resource (a file, or a non-empty configuration variable for
# example) is available, and if appropriate to extract default values
# from pertinent package files. Call them using their associated
# 'require_*' variable to ensure that they are executed, at most, once.
#
# It's entirely deliberate that calling these functions can set
# variables that don't obey the namespace limitations obeyed by the rest
# of this file, in order that that they be as useful as possible to
# callers.


# require_term_colors
# -------------------
# Allow display of bold text on terminals that support it.
require_term_colors=func_require_term_colors
func_require_term_colors ()
{
    $debug_cmd

    test -t 1 && {
      # COLORTERM and USE_ANSI_COLORS environment variables take
      # precedence, because most terminfo databases neglect to describe
      # whether color sequences are supported.
      test -n "${COLORTERM+set}" && : ${USE_ANSI_COLORS="1"}

      if test 1 = "$USE_ANSI_COLORS"; then
        # Standard ANSI escape sequences
        tc_reset='[0m'
        tc_bold='[1m';   tc_standout='[7m'
        tc_red='[31m';   tc_green='[32m'
        tc_blue='[34m';  tc_cyan='[36m'
      else
        # Otherwise trust the terminfo database after all.
        test -n "`tput sgr0 2>/dev/null`" && {
          tc_reset=`tput sgr0`
          test -n "`tput bold 2>/dev/null`" && tc_bold=`tput bold`
          tc_standout=$tc_bold
          test -n "`tput smso 2>/dev/null`" && tc_standout=`tput smso`
          test -n "`tput setaf 1 2>/dev/null`" && tc_red=`tput setaf 1`
          test -n "`tput setaf 2 2>/dev/null`" && tc_green=`tput setaf 2`
          test -n "`tput setaf 4 2>/dev/null`" && tc_blue=`tput setaf 4`
          test -n "`tput setaf 5 2>/dev/null`" && tc_cyan=`tput setaf 5`
        }
      fi
    }

    require_term_colors=:
}


## ----------------- ##
## Function library. ##
## ----------------- ##

# This section contains a variety of useful functions to call in your
# scripts. Take note of the portable wrappers for features provided by
# some modern shells, which will fall back to slower equivalents on
# less featureful shells.


# func_append VAR VALUE
# ---------------------
# Append VALUE onto the existing contents of VAR.

  # We should try to minimise forks, especially on Windows where they are
  # unreasonably slow, so skip the feature probes when bash or zsh are
  # being used:
  if test set = "${BASH_VERSION+set}${ZSH_VERSION+set}"; then
    : ${_G_HAVE_ARITH_OP="yes"}
    : ${_G_HAVE_XSI_OPS="yes"}
    # The += operator was introduced in bash 3.1
    case $BASH_VERSION in
      [12].* | 3.0 | 3.0*) ;;
      *)
        : ${_G_HAVE_PLUSEQ_OP="yes"}
        ;;
    esac
  fi

  # _G_HAVE_PLUSEQ_OP
  # Can be empty, in which case the shell is probed, "yes" if += is
  # useable or anything else if it does not work.
  test -z "$_G_HAVE_PLUSEQ_OP" \
    && (eval 'x=a; x+=" b"; test "a b" = "$x"') 2>/dev/null \
    && _G_HAVE_PLUSEQ_OP=yes

if test yes = "$_G_HAVE_PLUSEQ_OP"
then
  # This is an XSI compatible shell, allowing a faster implementation...
  eval 'func_append ()
  {
    $debug_cmd

    eval "$1+=\$2"
  }'
else
  # ...otherwise fall back to using expr, which is often a shell builtin.
  func_append ()
  {
    $debug_cmd

    eval "$1=\$$1\$2"
  }
fi


# func_append_quoted VAR VALUE
# ----------------------------
# Quote VALUE and append to the end of shell variable VAR, separated
# by a space.
if test yes = "$_G_HAVE_PLUSEQ_OP"; then
  eval 'func_append_quoted ()
  {
    $debug_cmd

    func_quote_for_eval "$2"
    eval "$1+=\\ \$func_quote_for_eval_result"
  }'
else
  func_append_quoted ()
  {
    $debug_cmd

    func_quote_for_eval "$2"
    eval "$1=\$$1\\ \$func_quote_for_eval_result"
  }
fi


# func_append_uniq VAR VALUE
# --------------------------
# Append unique VALUE onto the existing contents of VAR, assuming
# entries are delimited by the first character of VALUE.  For example:
#
#   func_append_uniq options " --another-option option-argument"
#
# will only append to $options if " --another-option option-argument "
# is not already present somewhere in $options already (note spaces at
# each end implied by leading space in second argument).
func_append_uniq ()
{
    $debug_cmd

    eval _G_current_value='`$bs_echo $'$1'`'
    _G_delim=`expr "$2" : '\(.\)'`

    case $_G_delim$_G_current_value$_G_delim in
      *"$2$_G_delim"*) ;;
      *) func_append "$@" ;;
    esac
}


# func_arith TERM...
# ------------------
# Set func_arith_result to the result of evaluating TERMs.
  test -z "$_G_HAVE_ARITH_OP" \
    && (eval 'test 2 = $(( 1 + 1 ))') 2>/dev/null \
    && _G_HAVE_ARITH_OP=yes

if test yes = "$_G_HAVE_ARITH_OP"; then
  eval 'func_arith ()
  {
    $debug_cmd

    func_arith_result=$(( $* ))
  }'
else
  func_arith ()
  {
    $debug_cmd

    func_arith_result=`expr "$@"`
  }
fi


# func_basename FILE
# ------------------
# Set func_basename_result to FILE with everything up to and including
# the last / stripped.
if test yes = "$_G_HAVE_XSI_OPS"; then
  # If this shell supports suffix pattern removal, then use it to avoid
  # forking. Hide the definitions single quotes in case the shell chokes
  # on unsupported syntax...
  _b='func_basename_result=${1##*/}'
  _d='case $1 in
        */*) func_dirname_result=${1%/*}$2 ;;
        *  ) func_dirname_result=$3        ;;
      esac'

else
  # ...otherwise fall back to using sed.
  _b='func_basename_result=`$ECHO "$1" |$SED "$sed_basename"`'
  _d='func_dirname_result=`$ECHO "$1"  |$SED "$sed_dirname"`
      if test "X$func_dirname_result" = "X$1"; then
        func_dirname_result=$3
      else
        func_append func_dirname_result "$2"
      fi'
fi

eval 'func_basename ()
{
    $debug_cmd

    '"$_b"'
}'


# func_dirname FILE APPEND NONDIR_REPLACEMENT
# -------------------------------------------
# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
# otherwise set result to NONDIR_REPLACEMENT.
eval 'func_dirname ()
{
    $debug_cmd

    '"$_d"'
}'


# func_dirname_and_basename FILE APPEND NONDIR_REPLACEMENT
# --------------------------------------------------------
# Perform func_basename and func_dirname in a single function
# call:
#   dirname:  Compute the dirname of FILE.  If nonempty,
#             add APPEND to the result, otherwise set result
#             to NONDIR_REPLACEMENT.
#             value returned in "$func_dirname_result"
#   basename: Compute filename of FILE.
#             value retuned in "$func_basename_result"
# For efficiency, we do not delegate to the functions above but instead
# duplicate the functionality here.
eval 'func_dirname_and_basename ()
{
    $debug_cmd

    '"$_b"'
    '"$_d"'
}'


# func_echo ARG...
# ----------------
# Echo program name prefixed message.
func_echo ()
{
    $debug_cmd

    _G_message=$*

    func_echo_IFS=$IFS
    IFS=$nl
    for _G_line in $_G_message; do
      IFS=$func_echo_IFS
      $bs_echo "$progname: $_G_line"
    done
    IFS=$func_echo_IFS
}


# func_echo_all ARG...
# --------------------
# Invoke $ECHO with all args, space-separated.
func_echo_all ()
{
    $ECHO "$*"
}


# func_echo_infix_1 INFIX ARG...
# ------------------------------
# Echo program name, followed by INFIX on the first line, with any
# additional lines not showing INFIX.
func_echo_infix_1 ()
{
    $debug_cmd

    $require_term_colors

    _G_infix=$1; shift
    _G_indent=$_G_infix
    _G_prefix="$progname: $_G_infix: "
    _G_message=$*

    # Strip color escape sequences before counting printable length
    for _G_tc in "$tc_reset" "$tc_bold" "$tc_standout" "$tc_red" "$tc_green" "$tc_blue" "$tc_cyan"
    do
      test -n "$_G_tc" && {
        _G_esc_tc=`$bs_echo "$_G_tc" | sed "$sed_make_literal_regex"`
        _G_indent=`$bs_echo "$_G_indent" | sed "s|$_G_esc_tc||g"`
      }
    done
    _G_indent="$progname: "`echo "$_G_indent" | sed 's|.| |g'`"  " ## exclude from sc_prohibit_nested_quotes

    func_echo_infix_1_IFS=$IFS
    IFS=$nl
    for _G_line in $_G_message; do
      IFS=$func_echo_infix_1_IFS
      $bs_echo "$_G_prefix$tc_bold$_G_line$tc_reset" >&2
      _G_prefix=$_G_indent
    done
    IFS=$func_echo_infix_1_IFS
}


# func_error ARG...
# -----------------
# Echo program name prefixed message to standard error.
func_error ()
{
    $debug_cmd

    $require_term_colors

    func_echo_infix_1 "  $tc_standout${tc_red}error$tc_reset" "$*" >&2
}


# func_fatal_error ARG...
# -----------------------
# Echo program name prefixed message to standard error, and exit.
func_fatal_error ()
{
    $debug_cmd

    func_error "$*"
    exit $EXIT_FAILURE
}


# func_grep EXPRESSION FILENAME
# -----------------------------
# Check whether EXPRESSION matches any line of FILENAME, without output.
func_grep ()
{
    $debug_cmd

    $GREP "$1" "$2" >/dev/null 2>&1
}


# func_len STRING
# ---------------
# Set func_len_result to the length of STRING. STRING may not
# start with a hyphen.
  test -z "$_G_HAVE_XSI_OPS" \
    && (eval 'x=a/b/c;
      test 5aa/bb/cc = "${#x}${x%%/*}${x%/*}${x#*/}${x##*/}"') 2>/dev/null \
    && _G_HAVE_XSI_OPS=yes

if test yes = "$_G_HAVE_XSI_OPS"; then
  eval 'func_len ()
  {
    $debug_cmd

    func_len_result=${#1}
  }'
else
  func_len ()
  {
    $debug_cmd

    func_len_result=`expr "$1" : ".*" 2>/dev/null || echo $max_cmd_len`
  }
fi


# func_mkdir_p DIRECTORY-PATH
# ---------------------------
# Make sure the entire path to DIRECTORY-PATH is available.
func_mkdir_p ()
{
    $debug_cmd

    _G_directory_path=$1
    _G_dir_list=

    if test -n "$_G_directory_path" && test : != "$opt_dry_run"; then

      # Protect directory names starting with '-'
      case $_G_directory_path in
        -*) _G_directory_path=./$_G_directory_path ;;
      esac

      # While some portion of DIR does not yet exist...
      while test ! -d "$_G_directory_path"; do
        # ...make a list in topmost first order.  Use a colon delimited
	# list incase some portion of path contains whitespace.
        _G_dir_list=$_G_directory_path:$_G_dir_list

        # If the last portion added has no slash in it, the list is done
        case $_G_directory_path in */*) ;; *) break ;; esac

        # ...otherwise throw away the child directory and loop
        _G_directory_path=`$ECHO "$_G_directory_path" | $SED -e "$sed_dirname"`
      done
      _G_dir_list=`$ECHO "$_G_dir_list" | $SED 's|:*$||'`

      func_mkdir_p_IFS=$IFS; IFS=:
      for _G_dir in $_G_dir_list; do
	IFS=$func_mkdir_p_IFS
        # mkdir can fail with a 'File exist' error if two processes
        # try to create one of the directories concurrently.  Don't
        # stop in that case!
        $MKDIR "$_G_dir" 2>/dev/null || :
      done
      IFS=$func_mkdir_p_IFS

      # Bail out if we (or some other process) failed to create a directory.
      test -d "$_G_directory_path" || \
        func_fatal_error "Failed to create '$1'"
    fi
}


# func_mktempdir [BASENAME]
# -------------------------
# Make a temporary directory that won't clash with other running
# libtool processes, and avoids race conditions if possible.  If
# given, BASENAME is the basename for that directory.
func_mktempdir ()
{
    $debug_cmd

    _G_template=${TMPDIR-/tmp}/${1-$progname}

    if test : = "$opt_dry_run"; then
      # Return a directory name, but don't create it in dry-run mode
      _G_tmpdir=$_G_template-$$
    else

      # If mktemp works, use that first and foremost
      _G_tmpdir=`mktemp -d "$_G_template-XXXXXXXX" 2>/dev/null`

      if test ! -d "$_G_tmpdir"; then
        # Failing that, at least try and use $RANDOM to avoid a race
        _G_tmpdir=$_G_template-${RANDOM-0}$$

        func_mktempdir_umask=`umask`
        umask 0077
        $MKDIR "$_G_tmpdir"
        umask $func_mktempdir_umask
      fi

      # If we're not in dry-run mode, bomb out on failure
      test -d "$_G_tmpdir" || \
        func_fatal_error "cannot create temporary directory '$_G_tmpdir'"
    fi

    $ECHO "$_G_tmpdir"
}


# func_normal_abspath PATH
# ------------------------
# Remove doubled-up and trailing slashes, "." path components,
# and cancel out any ".." path components in PATH after making
# it an absolute path.
func_normal_abspath ()
{
    $debug_cmd

    # These SED scripts presuppose an absolute path with a trailing slash.
    _G_pathcar='s|^/\([^/]*\).*$|\1|'
    _G_pathcdr='s|^/[^/]*||'
    _G_removedotparts=':dotsl
		s|/\./|/|g
		t dotsl
		s|/\.$|/|'
    _G_collapseslashes='s|/\{1,\}|/|g'
    _G_finalslash='s|/*$|/|'

    # Start from root dir and reassemble the path.
    func_normal_abspath_result=
    func_normal_abspath_tpath=$1
    func_normal_abspath_altnamespace=
    case $func_normal_abspath_tpath in
      "")
        # Empty path, that just means $cwd.
        func_stripname '' '/' "`pwd`"
        func_normal_abspath_result=$func_stripname_result
        return
        ;;
      # The next three entries are used to spot a run of precisely
      # two leading slashes without using negated character classes;
      # we take advantage of case's first-match behaviour.
      ///*)
        # Unusual form of absolute path, do nothing.
        ;;
      //*)
        # Not necessarily an ordinary path; POSIX reserves leading '//'
        # and for example Cygwin uses it to access remote file shares
        # over CIFS/SMB, so we conserve a leading double slash if found.
        func_normal_abspath_altnamespace=/
        ;;
      /*)
        # Absolute path, do nothing.
        ;;
      *)
        # Relative path, prepend $cwd.
        func_normal_abspath_tpath=`pwd`/$func_normal_abspath_tpath
        ;;
    esac

    # Cancel out all the simple stuff to save iterations.  We also want
    # the path to end with a slash for ease of parsing, so make sure
    # there is one (and only one) here.
    func_normal_abspath_tpath=`$ECHO "$func_normal_abspath_tpath" | $SED \
          -e "$_G_removedotparts" -e "$_G_collapseslashes" -e "$_G_finalslash"`
    while :; do
      # Processed it all yet?
      if test / = "$func_normal_abspath_tpath"; then
        # If we ascended to the root using ".." the result may be empty now.
        if test -z "$func_normal_abspath_result"; then
          func_normal_abspath_result=/
        fi
        break
      fi
      func_normal_abspath_tcomponent=`$ECHO "$func_normal_abspath_tpath" | $SED \
          -e "$_G_pathcar"`
      func_normal_abspath_tpath=`$ECHO "$func_normal_abspath_tpath" | $SED \
          -e "$_G_pathcdr"`
      # Figure out what to do with it
      case $func_normal_abspath_tcomponent in
        "")
          # Trailing empty path component, ignore it.
          ;;
        ..)
          # Parent dir; strip last assembled component from result.
          func_dirname "$func_normal_abspath_result"
          func_normal_abspath_result=$func_dirname_result
          ;;
        *)
          # Actual path component, append it.
          func_append func_normal_abspath_result "/$func_normal_abspath_tcomponent"
          ;;
      esac
    done
    # Restore leading double-slash if one was found on entry.
    func_normal_abspath_result=$func_normal_abspath_altnamespace$func_normal_abspath_result
}


# func_notquiet ARG...
# --------------------
# Echo program name prefixed message only when not in quiet mode.
func_notquiet ()
{
    $debug_cmd

    $opt_quiet || func_echo ${1+"$@"}

    # A bug in bash halts the script if the last line of a function
    # fails when set -e is in force, so we need another command to
    # work around that:
    :
}


# func_relative_path SRCDIR DSTDIR
# --------------------------------
# Set func_relative_path_result to the relative path from SRCDIR to DSTDIR.
func_relative_path ()
{
    $debug_cmd

    func_relative_path_result=
    func_normal_abspath "$1"
    func_relative_path_tlibdir=$func_normal_abspath_result
    func_normal_abspath "$2"
    func_relative_path_tbindir=$func_normal_abspath_result

    # Ascend the tree starting from libdir
    while :; do
      # check if we have found a prefix of bindir
      case $func_relative_path_tbindir in
        $func_relative_path_tlibdir)
          # found an exact match
          func_relative_path_tcancelled=
          break
          ;;
        $func_relative_path_tlibdir*)
          # found a matching prefix
          func_stripname "$func_relative_path_tlibdir" '' "$func_relative_path_tbindir"
          func_relative_path_tcancelled=$func_stripname_result
          if test -z "$func_relative_path_result"; then
            func_relative_path_result=.
          fi
          break
          ;;
        *)
          func_dirname $func_relative_path_tlibdir
          func_relative_path_tlibdir=$func_dirname_result
          if test -z "$func_relative_path_tlibdir"; then
            # Have to descend all the way to the root!
            func_relative_path_result=../$func_relative_path_result
            func_relative_path_tcancelled=$func_relative_path_tbindir
            break
          fi
          func_relative_path_result=../$func_relative_path_result
          ;;
      esac
    done

    # Now calculate path; take care to avoid doubling-up slashes.
    func_stripname '' '/' "$func_relative_path_result"
    func_relative_path_result=$func_stripname_result
    func_stripname '/' '/' "$func_relative_path_tcancelled"
    if test -n "$func_stripname_result"; then
      func_append func_relative_path_result "/$func_stripname_result"
    fi

    # Normalisation. If bindir is libdir, return '.' else relative path.
    if test -n "$func_relative_path_result"; then
      func_stripname './' '' "$func_relative_path_result"
      func_relative_path_result=$func_stripname_result
    fi

    test -n "$func_relative_path_result" || func_relative_path_result=.

    :
}


# func_quote_for_eval ARG...
# --------------------------
# Aesthetically quote ARGs to be evaled later.
# This function returns two values:
#   i) func_quote_for_eval_result
#      double-quoted, suitable for a subsequent eval
#  ii) func_quote_for_eval_unquoted_result
#      has just all characters which are still active within double
#      quotes backslashified.
func_quote_for_eval ()
{
    $debug_cmd

    func_quote_for_eval_unquoted_result=
    func_quote_for_eval_result=
    while test 0 -lt $#; do
      case $1 in
        *[\\\`\"\$]*)
	  _G_unquoted_arg=`printf '%s\n' "$1" |$SED "$sed_quote_subst"` ;;
        *)
          _G_unquoted_arg=$1 ;;
      esac
      if test -n "$func_quote_for_eval_unquoted_result"; then
	func_append func_quote_for_eval_unquoted_result " $_G_unquoted_arg"
      else
        func_append func_quote_for_eval_unquoted_result "$_G_unquoted_arg"
      fi

      case $_G_unquoted_arg in
        # Double-quote args containing shell metacharacters to delay
        # word splitting, command substitution and variable expansion
        # for a subsequent eval.
        # Many Bourne shells cannot handle close brackets correctly
        # in scan sets, so we specify it separately.
        *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
          _G_quoted_arg=\"$_G_unquoted_arg\"
          ;;
        *)
          _G_quoted_arg=$_G_unquoted_arg
	  ;;
      esac

      if test -n "$func_quote_for_eval_result"; then
	func_append func_quote_for_eval_result " $_G_quoted_arg"
      else
        func_append func_quote_for_eval_result "$_G_quoted_arg"
      fi
      shift
    done
}


# func_quote_for_expand ARG
# -------------------------
# Aesthetically quote ARG to be evaled later; same as above,
# but do not quote variable references.
func_quote_for_expand ()
{
    $debug_cmd

    case $1 in
      *[\\\`\"]*)
	_G_arg=`$ECHO "$1" | $SED \
	    -e "$sed_double_quote_subst" -e "$sed_double_backslash"` ;;
      *)
        _G_arg=$1 ;;
    esac

    case $_G_arg in
      # Double-quote args containing shell metacharacters to delay
      # word splitting and command substitution for a subsequent eval.
      # Many Bourne shells cannot handle close brackets correctly
      # in scan sets, so we specify it separately.
      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
        _G_arg=\"$_G_arg\"
        ;;
    esac

    func_quote_for_expand_result=$_G_arg
}


# func_stripname PREFIX SUFFIX NAME
# ---------------------------------
# strip PREFIX and SUFFIX from NAME, and store in func_stripname_result.
# PREFIX and SUFFIX must not contain globbing or regex special
# characters, hashes, percent signs, but SUFFIX may contain a leading
# dot (in which case that matches only a dot).
if test yes = "$_G_HAVE_XSI_OPS"; then
  eval 'func_stripname ()
  {
    $debug_cmd

    # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are
    # positional parameters, so assign one to ordinary variable first.
    func_stripname_result=$3
    func_stripname_result=${func_stripname_result#"$1"}
    func_stripname_result=${func_stripname_result%"$2"}
  }'
else
  func_stripname ()
  {
    $debug_cmd

    case $2 in
      .*) func_stripname_result=`$ECHO "$3" | $SED -e "s%^$1%%" -e "s%\\\\$2\$%%"`;;
      *)  func_stripname_result=`$ECHO "$3" | $SED -e "s%^$1%%" -e "s%$2\$%%"`;;
    esac
  }
fi


# func_show_eval CMD [FAIL_EXP]
# -----------------------------
# Unless opt_quiet is true, then output CMD.  Then, if opt_dryrun is
# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP
# is given, then evaluate it.
func_show_eval ()
{
    $debug_cmd

    _G_cmd=$1
    _G_fail_exp=${2-':'}

    func_quote_for_expand "$_G_cmd"
    eval "func_notquiet $func_quote_for_expand_result"

    $opt_dry_run || {
      eval "$_G_cmd"
      _G_status=$?
      if test 0 -ne "$_G_status"; then
	eval "(exit $_G_status); $_G_fail_exp"
      fi
    }
}


# func_show_eval_locale CMD [FAIL_EXP]
# ------------------------------------
# Unless opt_quiet is true, then output CMD.  Then, if opt_dryrun is
# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP
# is given, then evaluate it.  Use the saved locale for evaluation.
func_show_eval_locale ()
{
    $debug_cmd

    _G_cmd=$1
    _G_fail_exp=${2-':'}

    $opt_quiet || {
      func_quote_for_expand "$_G_cmd"
      eval "func_echo $func_quote_for_expand_result"
    }

    $opt_dry_run || {
      eval "$_G_user_locale
	    $_G_cmd"
      _G_status=$?
      eval "$_G_safe_locale"
      if test 0 -ne "$_G_status"; then
	eval "(exit $_G_status); $_G_fail_exp"
      fi
    }
}


# func_tr_sh
# ----------
# Turn $1 into a string suitable for a shell variable name.
# Result is stored in $func_tr_sh_result.  All characters
# not in the set a-zA-Z0-9_ are replaced with '_'. Further,
# if $1 begins with a digit, a '_' is prepended as well.
func_tr_sh ()
{
    $debug_cmd

    case $1 in
    [0-9]* | *[!a-zA-Z0-9_]*)
      func_tr_sh_result=`$ECHO "$1" | $SED -e 's/^\([0-9]\)/_\1/' -e 's/[^a-zA-Z0-9_]/_/g'`
      ;;
    * )
      func_tr_sh_result=$1
      ;;
    esac
}


# func_verbose ARG...
# -------------------
# Echo program name prefixed message in verbose mode only.
func_verbose ()
{
    $debug_cmd

    $opt_verbose && func_echo "$*"

    :
}


# func_warn_and_continue ARG...
# -----------------------------
# Echo program name prefixed warning message to standard error.
func_warn_and_continue ()
{
    $debug_cmd

    $require_term_colors

    func_echo_infix_1 "${tc_red}warning$tc_reset" "$*" >&2
}


# func_warning CATEGORY ARG...
# ----------------------------
# Echo program name prefixed warning message to standard error. Warning
# messages can be filtered according to CATEGORY, where this function
# elides messages where CATEGORY is not listed in the global variable
# 'opt_warning_types'.
func_warning ()
{
    $debug_cmd

    # CATEGORY must be in the warning_categories list!
    case " $warning_categories " in
      *" $1 "*) ;;
      *) func_internal_error "invalid warning category '$1'" ;;
    esac

    _G_category=$1
    shift

    case " $opt_warning_types " in
      *" $_G_category "*) $warning_func ${1+"$@"} ;;
    esac
}


# Local variables:
# mode: shell-script
# sh-indentation: 2
# eval: (add-hook 'write-file-hooks 'time-stamp)
# time-stamp-pattern: "10/scriptversion=%:y-%02m-%02d.%02H; # UTC"
# time-stamp-time-zone: "UTC"
# End:
#! /bin/sh

# Set a version string for this script.
scriptversion=2012-10-21.11; # UTC

# A portable, pluggable option parser for Bourne shell.
# Written by Gary V. Vaughan, 2010

# Copyright (C) 2010-2012 Free Software Foundation, Inc.
# This is free software; see the source for copying conditions.  There is NO
# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Please report bugs or propose patches to gary@gnu.org.


## ------ ##
## Usage. ##
## ------ ##

# This file is a library for parsing options in your shell scripts along
# with assorted other useful supporting features that you can make use
# of too.
#
# For the simplest scripts you might need only:
#
#   #!/bin/sh
#   . relative/path/to/funclib.sh
#   . relative/path/to/options-parser
#   scriptversion=1.0
#   func_options ${1+"$@"}
#   eval set dummy "$func_options_result"; shift
#   ...rest of your script...
#
# In order for the '--version' option to work, you will need to have a
# suitably formatted comment like the one at the top of this file
# starting with '# Written by ' and ending with '# warranty; '.
#
# For '-h' and '--help' to work, you will also need a one line
# description of your script's purpose in a comment directly above the
# '# Written by ' line, like the one at the top of this file.
#
# The default options also support '--debug', which will turn on shell
# execution tracing (see the comment above debug_cmd below for another
# use), and '--verbose' and the func_verbose function to allow your script
# to display verbose messages only when your user has specified
# '--verbose'.
#
# After sourcing this file, you can plug processing for additional
# options by amending the variables from the 'Configuration' section
# below, and following the instructions in the 'Option parsing'
# section further down.

## -------------- ##
## Configuration. ##
## -------------- ##

# You should override these variables in your script after sourcing this
# file so that they reflect the customisations you have added to the
# option parser.

# The usage line for option parsing errors and the start of '-h' and
# '--help' output messages. You can embed shell variables for delayed
# expansion at the time the message is displayed, but you will need to
# quote other shell meta-characters carefully to prevent them being
# expanded when the contents are evaled.
usage='$progpath [OPTION]...'

# Short help message in response to '-h' and '--help'.  Add to this or
# override it after sourcing this library to reflect the full set of
# options your script accepts.
usage_message="\
       --debug        enable verbose shell tracing
   -W, --warnings=CATEGORY
                      report the warnings falling in CATEGORY [all]
   -v, --verbose      verbosely report processing
       --version      print version information and exit
   -h, --help         print short or long help message and exit
"

# Additional text appended to 'usage_message' in response to '--help'.
long_help_message="
Warning categories include:
       'all'          show all warnings
       'none'         turn off all the warnings
       'error'        warnings are treated as fatal errors"

# Help message printed before fatal option parsing errors.
fatal_help="Try '\$progname --help' for more information."



## ------------------------- ##
## Hook function management. ##
## ------------------------- ##

# This section contains functions for adding, removing, and running hooks
# to the main code.  A hook is just a named list of of function, that can
# be run in order later on.

# func_hookable FUNC_NAME
# -----------------------
# Declare that FUNC_NAME will run hooks added with
# 'func_add_hook FUNC_NAME ...'.
func_hookable ()
{
    $debug_cmd

    func_append hookable_fns " $1"
}


# func_add_hook FUNC_NAME HOOK_FUNC
# ---------------------------------
# Request that FUNC_NAME call HOOK_FUNC before it returns.  FUNC_NAME must
# first have been declared "hookable" by a call to 'func_hookable'.
func_add_hook ()
{
    $debug_cmd

    case " $hookable_fns " in
      *" $1 "*) ;;
      *) func_fatal_error "'$1' does not accept hook functions." ;;
    esac

    eval func_append ${1}_hooks '" $2"'
}


# func_remove_hook FUNC_NAME HOOK_FUNC
# ------------------------------------
# Remove HOOK_FUNC from the list of functions called by FUNC_NAME.
func_remove_hook ()
{
    $debug_cmd

    eval ${1}_hooks='`$bs_echo "\$'$1'_hooks" |$SED "s| '$2'||"`'
}


# func_run_hooks FUNC_NAME [ARG]...
# ---------------------------------
# Run all hook functions registered to FUNC_NAME.
# It is assumed that the list of hook functions contains nothing more
# than a whitespace-delimited list of legal shell function names, and
# no effort is wasted trying to catch shell meta-characters or preserve
# whitespace.
func_run_hooks ()
{
    $debug_cmd

    case " $hookable_fns " in
      *" $1 "*) ;;
      *) func_fatal_error "'$1' does not support hook funcions.n" ;;
    esac

    eval _G_hook_fns=\$$1_hooks; shift

    for _G_hook in $_G_hook_fns; do
      eval $_G_hook '"$@"'

      # store returned options list back into positional
      # parameters for next 'cmd' execution.
      eval _G_hook_result=\$${_G_hook}_result
      eval set dummy "$_G_hook_result"; shift
    done

    func_quote_for_eval ${1+"$@"}
    func_run_hooks_result=$func_quote_for_eval_result
}



## --------------- ##
## Option parsing. ##
## --------------- ##

# In order to add your own option parsing hooks, you must accept the
# full positional parameter list in your hook function, remove any
# options that you action, and then pass back the remaining unprocessed
# options in '<hooked_function_name>_result', escaped suitably for
# 'eval'.  Like this:
#
#    my_options_prep ()
#    {
#        $debug_cmd
#
#        # Extend the existing usage message.
#        usage_message=$usage_message'
#      -s, --silent       don'\''t print informational messages
#    '
#
#        func_quote_for_eval ${1+"$@"}
#        my_options_prep_result=$func_quote_for_eval_result
#    }
#    func_add_hook func_options_prep my_options_prep
#
#
#    my_silent_option ()
#    {
#        $debug_cmd
#
#        # Note that for efficiency, we parse as many options as we can
#        # recognise in a loop before passing the remainder back to the
#        # caller on the first unrecognised argument we encounter.
#        while test $# -gt 0; do
#          opt=$1; shift
#          case $opt in
#            --silent|-s) opt_silent=: ;;
#            # Separate non-argument short options:
#            -s*)         func_split_short_opt "$_G_opt"
#                         set dummy "$func_split_short_opt_name" \
#                             "-$func_split_short_opt_arg" ${1+"$@"}
#                         shift
#                         ;;
#            *)            set dummy "$_G_opt" "$*"; shift; break ;;
#          esac
#        done
#
#        func_quote_for_eval ${1+"$@"}
#        my_silent_option_result=$func_quote_for_eval_result
#    }
#    func_add_hook func_parse_options my_silent_option
#
#
#    my_option_validation ()
#    {
#        $debug_cmd
#
#        $opt_silent && $opt_verbose && func_fatal_help "\
#    '--silent' and '--verbose' options are mutually exclusive."
#
#        func_quote_for_eval ${1+"$@"}
#        my_option_validation_result=$func_quote_for_eval_result
#    }
#    func_add_hook func_validate_options my_option_validation
#
# You'll alse need to manually amend $usage_message to reflect the extra
# options you parse.  It's preferable to append if you can, so that
# multiple option parsing hooks can be added safely.


# func_options [ARG]...
# ---------------------
# All the functions called inside func_options are hookable. See the
# individual implementations for details.
func_hookable func_options
func_options ()
{
    $debug_cmd

    func_options_prep ${1+"$@"}
    eval func_parse_options \
        ${func_options_prep_result+"$func_options_prep_result"}
    eval func_validate_options \
        ${func_parse_options_result+"$func_parse_options_result"}

    eval func_run_hooks func_options \
        ${func_validate_options_result+"$func_validate_options_result"}

    # save modified positional parameters for caller
    func_options_result=$func_run_hooks_result
}


# func_options_prep [ARG]...
# --------------------------
# All initialisations required before starting the option parse loop.
# Note that when calling hook functions, we pass through the list of
# positional parameters.  If a hook function modifies that list, and
# needs to propogate that back to rest of this script, then the complete
# modified list must be put in 'func_run_hooks_result' before
# returning.
func_hookable func_options_prep
func_options_prep ()
{
    $debug_cmd

    # Option defaults:
    opt_verbose=false
    opt_warning_types=

    func_run_hooks func_options_prep ${1+"$@"}

    # save modified positional parameters for caller
    func_options_prep_result=$func_run_hooks_result
}


# func_parse_options [ARG]...
# ---------------------------
# The main option parsing loop.
func_hookable func_parse_options
func_parse_options ()
{
    $debug_cmd

    func_parse_options_result=

    # this just eases exit handling
    while test $# -gt 0; do
      # Defer to hook functions for initial option parsing, so they
      # get priority in the event of reusing an option name.
      func_run_hooks func_parse_options ${1+"$@"}

      # Adjust func_parse_options positional parameters to match
      eval set dummy "$func_run_hooks_result"; shift

      # Break out of the loop if we already parsed every option.
      test $# -gt 0 || break

      _G_opt=$1
      shift
      case $_G_opt in
        --debug|-x)   debug_cmd='set -x'
                      func_echo "enabling shell trace mode"
                      $debug_cmd
                      ;;

        --no-warnings|--no-warning|--no-warn)
                      set dummy --warnings none ${1+"$@"}
                      shift
		      ;;

        --warnings|--warning|-W)
                      test $# = 0 && func_missing_arg $_G_opt && break
                      case " $warning_categories $1" in
                        *" $1 "*)
                          # trailing space prevents matching last $1 above
                          func_append_uniq opt_warning_types " $1"
                          ;;
                        *all)
                          opt_warning_types=$warning_categories
                          ;;
                        *none)
                          opt_warning_types=none
                          warning_func=:
                          ;;
                        *error)
                          opt_warning_types=$warning_categories
                          warning_func=func_fatal_error
                          ;;
                        *)
                          func_fatal_error \
                             "unsupported warning category: '$1'"
                          ;;
                      esac
                      shift
                      ;;

        --verbose|-v) opt_verbose=: ;;
        --version)    func_version ;;
        -\?|-h)       func_usage ;;
        --help)       func_help ;;

	# Separate optargs to long options (plugins may need this):
	--*=*)        func_split_equals "$_G_opt"
	              set dummy "$func_split_equals_lhs" \
                          "$func_split_equals_rhs" ${1+"$@"}
                      shift
                      ;;

       # Separate optargs to short options:
        -W*)
                      func_split_short_opt "$_G_opt"
                      set dummy "$func_split_short_opt_name" \
                          "$func_split_short_opt_arg" ${1+"$@"}
                      shift
                      ;;

        # Separate non-argument short options:
        -\?*|-h*|-v*|-x*)
                      func_split_short_opt "$_G_opt"
                      set dummy "$func_split_short_opt_name" \
                          "-$func_split_short_opt_arg" ${1+"$@"}
                      shift
                      ;;

        --)           break ;;
        -*)           func_fatal_help "unrecognised option: '$_G_opt'" ;;
        *)            set dummy "$_G_opt" ${1+"$@"}; shift; break ;;
      esac
    done

    # save modified positional parameters for caller
    func_quote_for_eval ${1+"$@"}
    func_parse_options_result=$func_quote_for_eval_result
}


# func_validate_options [ARG]...
# ------------------------------
# Perform any sanity checks on option settings and/or unconsumed
# arguments.
func_hookable func_validate_options
func_validate_options ()
{
    $debug_cmd

    # Display all warnings if -W was not given.
    test -n "$opt_warning_types" || opt_warning_types=" $warning_categories"

    func_run_hooks func_validate_options ${1+"$@"}

    # Bail if the options were screwed!
    $exit_cmd $EXIT_FAILURE

    # save modified positional parameters for caller
    func_validate_options_result=$func_run_hooks_result
}



## ------------------##
## Helper functions. ##
## ------------------##

# This section contains the helper functions used by the rest of the
# hookable option parser framework in ascii-betical order.


# func_fatal_help ARG...
# ----------------------
# Echo program name prefixed message to standard error, followed by
# a help hint, and exit.
func_fatal_help ()
{
    $debug_cmd

    eval \$bs_echo \""Usage: $usage"\"
    eval \$bs_echo \""$fatal_help"\"
    func_error ${1+"$@"}
    exit $EXIT_FAILURE
}


# func_help
# ---------
# Echo long help message to standard output and exit.
func_help ()
{
    $debug_cmd

    func_usage_message
    $bs_echo "$long_help_message"
    exit 0
}


# func_missing_arg ARGNAME
# ------------------------
# Echo program name prefixed message to standard error and set global
# exit_cmd.
func_missing_arg ()
{
    $debug_cmd

    func_error "Missing argument for '$1'."
    exit_cmd=exit
}


# func_split_equals STRING
# ------------------------
# Set func_split_equals_lhs and func_split_equals_rhs shell variables after
# splitting STRING at the '=' sign.
test -z "$_G_HAVE_XSI_OPS" \
    && (eval 'x=a/b/c;
      test 5aa/bb/cc = "${#x}${x%%/*}${x%/*}${x#*/}${x##*/}"') 2>/dev/null \
    && _G_HAVE_XSI_OPS=yes

if test yes = "$_G_HAVE_XSI_OPS"
then
  # This is an XSI compatible shell, allowing a faster implementation...
  eval 'func_split_equals ()
  {
      $debug_cmd

      func_split_equals_lhs=${1%%=*}
      func_split_equals_rhs=${1#*=}
      test "x$func_split_equals_lhs" = "x$1" \
        && func_split_equals_rhs=
  }'
else
  # ...otherwise fall back to using expr, which is often a shell builtin.
  func_split_equals ()
  {
      $debug_cmd

      func_split_equals_lhs=`expr "x$1" : 'x\([^=]*\)'`
      func_split_equals_rhs=
      test "x$func_split_equals_lhs" = "x$1" \
        || func_split_equals_rhs=`expr "x$1" : 'x[^=]*=\(.*\)$'`
  }
fi #func_split_equals


# func_split_short_opt SHORTOPT
# -----------------------------
# Set func_split_short_opt_name and func_split_short_opt_arg shell
# variables after splitting SHORTOPT after the 2nd character.
if test yes = "$_G_HAVE_XSI_OPS"
then
  # This is an XSI compatible shell, allowing a faster implementation...
  eval 'func_split_short_opt ()
  {
      $debug_cmd

      func_split_short_opt_arg=${1#??}
      func_split_short_opt_name=${1%"$func_split_short_opt_arg"}
  }'
else
  # ...otherwise fall back to using expr, which is often a shell builtin.
  func_split_short_opt ()
  {
      $debug_cmd

      func_split_short_opt_name=`expr "x$1" : 'x-\(.\)'`
      func_split_short_opt_arg=`expr "x$1" : 'x-.\(.*\)$'`
  }
fi #func_split_short_opt


# func_usage
# ----------
# Echo short help message to standard output and exit.
func_usage ()
{
    $debug_cmd

    func_usage_message
    $bs_echo "Run '$progname --help |${PAGER-more}' for full usage"
    exit 0
}


# func_usage_message
# ------------------
# Echo short help message to standard output.
func_usage_message ()
{
    $debug_cmd

    eval \$bs_echo \""Usage: $usage"\"
    echo
    $SED -n 's|^# ||
        /^Written by/{
          x;p;x
        }
	h
	/^Written by/q' < "$progpath"
    echo
    eval \$bs_echo \""$usage_message"\"
}


# func_version
# ------------
# Echo version message to standard output and exit.
func_version ()
{
    $debug_cmd

    printf '%s\n' "$progname $scriptversion"
    $SED -n '/^##/q
        /(C)/!b go
        :more
        /\./!{
          N
          s|\n# | |
          b more
        }
        :go
        /^# Written by /,/# warranty; / {
          s|^# ||
          s|^# *$||
          s|\((C)\)[ 0-9,-]*[ ,-]\([1-9][0-9]* \)|\1 \2|
          p
        }
        /^# Written by / {
          s|^# ||
          p
        }
        /^warranty; /q' < "$progpath"

    exit $?
}


# Local variables:
# mode: shell-script
# sh-indentation: 2
# eval: (add-hook 'write-file-hooks 'time-stamp)
# time-stamp-pattern: "10/scriptversion=%:y-%02m-%02d.%02H; # UTC"
# time-stamp-time-zone: "UTC"
# End:
#! /bin/sh

# Extract macro arguments from autotools input with GNU M4.
# Written by Gary V. Vaughan, 2010
#
# Copyright (C) 2010-2012 Free Software Foundation, Inc.
# This is free software; see the source for copying conditions.  There is NO
# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

# Make sure we've evaluated scripts we depend on.
test -z "$progpath" && . `echo "$0" |${SED-sed} 's|[^/]*$||'`/funclib.sh
test extract-trace = "$progname" && . `echo "$0" |${SED-sed} 's|[^/]*$||'`/options-parser

# Set a version string.
scriptversion=2012-10-07.10; # UTC

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Please report bugs or propose patches to gary@gnu.org.


## ------ ##
## Usage. ##
## ------ ##

# Run './extract-trace --help' for help with using this script from the
# command line.
#
# Or source first 'options-parser' and then this file into your own
# scripts in order to make use of the function and variable framework
# they define, and also to avoid the overhead of forking to run this
# script in its own process on every call.



## ------------------##
## Helper functions. ##
## ------------------##

# This section contains the helper functions used by the rest of
# 'extract-trace'.


# func_autoconf_configure MAYBE-CONFIGURE-FILE
# --------------------------------------------
# Ensure that MAYBE-CONFIGURE-FILE is the name of a file in the current
# directory which contains an uncommented call to AC_INIT.
func_autoconf_configure ()
{
    $debug_cmd

    _G_sed_no_comment='
      s|#.*$||
      s|^dnl .*$||
      s| dnl .*$||'
    _G_ac_init=

    # If we were passed a genuine file, make sure it calls AC_INIT.
    test -f "$1" \
      && _G_ac_init=`$SED "$_G_sed_no_comment" "$1" |grep AC_INIT`

    # Otherwise it is not a genuine Autoconf input file.
    test -n "$_G_ac_init"
    _G_status=$?

    test 0 -ne "$_G_status" \
      && func_verbose "'$1' not using Autoconf"

    (exit $_G_status)
}


# func_find_tool ENVVAR NAMES...
# ------------------------------
# Search for a required program.  Use the value of ENVVAR, if set,
# otherwise find the first of the NAMES that can be run (i.e.,
# supports --version).  If found, set ENVVAR to the program name,
# die otherwise.
func_find_tool ()
{
    $debug_cmd

    _G_find_tool_envvar=$1
    shift
    _G_find_tool_names=$@
    eval "_G_find_tool_res=\$$_G_find_tool_envvar"
    if test -n "$_G_find_tool_res"; then
      _G_find_tool_error_prefix="\$$find_tool_envvar: "
    else
      for _G_prog
      do
        if func_tool_version_output $_G_prog >/dev/null; then
          _G_find_tool_res=$_G_prog
          break
        fi
      done
    fi
    if test -n "$_G_find_tool_res"; then
      func_tool_version_output >/dev/null $_G_find_tool_res "\
${_G_find_tool_error_prefix}Cannot run '$_G_find_tool_res --version'"

      # Make sure the result is exported to the environment for children
      # to use.
      eval "$_G_find_tool_envvar=\$_G_find_tool_res"
      eval "export $_G_find_tool_envvar"
    else
      func_error "\
One of these is required:
       $_G_find_tool_names"
    fi
}


# func_tool_version_output CMD [FATAL-ERROR-MSG]
# ----------------------------------------------
# Attempt to run 'CMD --version', discarding errors.  The output can be
# ignored by redirecting stdout, and this function used simply to test
# whether the command exists and exits normally when passed a
# '--version' argument.
# When FATAL-ERROR-MSG is given, then this function will display the
# message and exit if running 'CMD --version' returns a non-zero exit
# status.
func_tool_version_output ()
{
    $debug_cmd

    _G_cmd=$1
    _G_fatal_error_msg=$2

    # Some tools, like 'git2cl' produce thousands of lines of output
    # unless stdin is /dev/null - in that case we want to return
    # successfully without saving all of that output.  Other tools,
    # such as 'help2man' exit with a non-zero status when stdin comes
    # from /dev/null, so we re-execute without /dev/null if that
    # happens.  This means that occasionally, the output from both calls
    # ends up in the result, but the alternative would be to discard the
    # output from one call, and hope the other produces something useful.
    { $_G_cmd --version </dev/null || $_G_cmd --version; } 2>/dev/null
    _G_status=$?

    test 0 -ne "$_G_status" && test -n "$_G_fatal_error_msg" \
        && func_fatal_error "$_G_fatal_error_msg"

    (exit $_G_status)
}


## -------------------- ##
## Resource management. ##
## -------------------- ##

# This section contains definitions for functions that each ensure a
# particular resource (a file, or a non-empty configuration variable for
# example) is available, and if appropriate to extract default values
# from pertinent package files.  Where a variable already has a non-
# empty value (as set by the package's 'bootstrap.conf'), that value is
# used in preference to deriving the default. Call them using their
# associated 'require_*' variable to ensure that they are executed, at
# most, once.
#
# It's entirely deliberate that calling these functions can set
# variables that don't obey the namespace limitations obeyed by the rest
# of this file, in order that that they be as useful as possible to
# callers.


# require_configure_ac
# --------------------
# Ensure that there is a 'configure.ac' or 'configure.in' file in the
# current directory which contains an uncommented call to AC_INIT, and
# that '$configure_ac' contains its name.
require_configure_ac=func_require_configure_ac
func_require_configure_ac ()
{
    $debug_cmd

    test -z "$configure_ac" \
      && func_autoconf_configure configure.ac && configure_ac=configure.ac
    test -z "$configure_ac" \
      && func_autoconf_configure configure.in && configure_ac=configure.in
    test -z "$configure_ac" \
      || func_verbose "found '$configure_ac'"

    require_configure_ac=:
}


# require_gnu_m4
# --------------
# Search for GNU M4, and export it in $M4.
require_gnu_m4=func_require_gnu_m4
func_require_gnu_m4 ()
{
    $debug_cmd

    test -n "$M4" || {
      # Find the first m4 binary that responds to --version.
      func_find_tool M4 gm4 gnum4 m4
    }

    test -n "$M4" || func_fatal_error "\
Please install GNU M4, or 'export M4=/path/to/gnu/m4'."

    func_verbose "export M4='$M4'"

    # Make sure the search result is visible to subshells
    export M4

    require_gnu_m4=:
}


## --------------- ##
## Core functions. ##
## --------------- ##

# This section contains the high level functions used when calling this
# file as a script. 'func_extract_trace' is probably the only one that you
# won't want to replace if you source this file into your own script.


# func_extract_trace MACRO_NAMES [FILENAME]...
# --------------------------------------------
# set '$func_extract_trace_result' to a colon delimited list of arguments
# to any of the comma separated list of MACRO_NAMES in FILENAME. If no
# FILENAME is given, then '$configure_ac' is assumed.
func_extract_trace ()
{
    $debug_cmd

    $require_configure_ac
    $require_gnu_m4

    _G_m4_traces=`$bs_echo "--trace=$1" |$SED 's%,% --trace=%g'`
    _G_re_macros=`$bs_echo "($1)" |$SED 's%,%|%g'`
    _G_macros="$1"; shift
    test $# -gt 0 || {
      set dummy $configure_ac
      shift
    }

    # Generate an error if the first file is missing
    <"$1"

    # Sadly, we can't use 'autom4te' tracing to extract macro arguments,
    # because it complains about things we want to ignore at bootstrap
    # time - like missing m4_include files; AC_PREREQ being newer than
    # the installed autoconf; and returns nothing when tracing
    # 'AM_INIT_AUTOMAKE' when aclocal hasn't been generated yet.
    #
    # The following tries to emulate a less persnickety version of (and
    # due to not having to wait for Perl startup on every invocation,
    # it's probably faster too):
    #
    #    autom4te --language=Autoconf --trace=$my_macro:\$% "$@"
    #
    # First we give a minimal set of macro declarations to M4 to prime
    # it for reading Autoconf macros, while still providing some of the
    # functionality generally used at m4-time to supply dynamic
    # arguments to Autocof functions, but without following
    # 'm4_s?include' files.
    _G_mini='
        # Initialisation.
        m4_changequote([,])
        m4_define([m4_copy],   [m4_define([$2], m4_defn([$1]))])
        m4_define([m4_rename], [m4_copy([$1], [$2])m4_undefine([$1])])

        # Disable these macros.
        m4_undefine([m4_dnl])
        m4_undefine([m4_include])
        m4_undefine([m4_m4exit])
        m4_undefine([m4_m4wrap])
        m4_undefine([m4_maketemp])

        # Copy and rename macros not handled by "m4 --prefix".
        m4_define([dnl],         [m4_builtin([dnl])])
        m4_copy([m4_define],     [m4_defun])
        m4_rename([m4_ifelse],   [m4_if])
        m4_ifdef([m4_mkstemp],   [m4_undefine([m4_mkstemp])])
        m4_rename([m4_patsubst], [m4_bpatsubst])
        m4_rename([m4_regexp],   [m4_bregexp])

        # "m4sugar.mini" - useful m4-time macros for dynamic arguments.
        # If we discover packages that need more m4 macros defined in
        # order to bootstrap correctly, add them here:
        m4_define([m4_bmatch],
            [m4_if([$#], 0, [], [$#], 1, [], [$#], 2, [$2],
                   [m4_if(m4_bregexp([$1], [$2]), -1,
                          [$0([$1], m4_shift3($@))], [$3])])])
        m4_define([m4_ifndef], [m4_ifdef([$1], [$3], [$2])])
        m4_define([m4_ifset],
            [m4_ifdef([$1], [m4_ifval(m4_defn([$1]), [$2], [$3])], [$3])])
        m4_define([m4_require], [$1])
        m4_define([m4_shift3], [m4_shift(m4shift(m4shift($@)))])

        # "autoconf.mini" - things from autoconf macros we care about.
        m4_copy([m4_defun], [AC_DEFUN])

        # Dummy definitions for the macros we want to trace.
        # AM_INIT_AUTOMAKE at least produces no trace without this.
    '

    _G_save=$IFS
    IFS=,
    for _G_macro in $_G_macros; do
      IFS=$_G_save
      func_append _G_mini "AC_DEFUN([$_G_macro])$nl"
    done
    IFS=$_G_save

    # We discard M4's stdout, but the M4 trace output from reading our
    # "autoconf.mini" followed by any other files passed to this
    # function is then scanned by sed to transform it into a colon
    # delimited argument list assigned to a shell variable.
    _G_transform='s|#.*$||; s|^dnl .*$||; s| dnl .*$||;'

    # Unfortunately, alternation in regexp addresses doesn't work in at
    # least BSD (and hence Mac OS X) sed, so we have to append a capture
    # and print block for each traced macro to the sed transform script.
    _G_save=$IFS
    IFS=,
    for _G_macro in $_G_macros; do
      IFS=$_G_save
      func_append _G_transform '
        /^m4trace: -1- '"$_G_macro"'/ {
          s|^m4trace: -1- '"$_G_macro"'[([]*||
          s|], [[]|:|g
          s|[])]*$|:|
          s|\(.\):$|\1|
          p
        }'
    done
    IFS=$_G_save

    # Save the command pipeline results for further use by callers of
    # this function.
    func_extract_trace_result=`$bs_echo "$_G_mini" \
      |$M4 -daq --prefix $_G_m4_traces - "$@" 2>&1 1>/dev/null \
      |$SED -n -e "$_G_transform"`
}


# func_extract_trace_first MACRO_NAMES [FILENAME]...
# --------------------------------------------------
# Exactly like func_extract_trace, except that only the first argument
# to the first invocation of one of the comma separated MACRO_NAMES is
# returned in '$func_extract_trace_first_result'.
func_extract_trace_first ()
{
    $debug_cmd

    func_extract_trace ${1+"$@"}
    func_extract_trace_first_result=`$bs_echo "$func_extract_trace_result" \
      |$SED -e 's|:.*$||g' -e 1q`
}


# func_main [ARG]...
# ------------------
func_main ()
{
    $debug_cmd

    # Configuration.
    usage='$progname MACRO_NAME FILE [...]'

    long_help_message='
The first argument to this program is the name of an autotools macro
whose arguments you want to extract by examining the files listed in the
remaining arguments using the same tool that Autoconf and Automake use,
GNU M4.

The arguments are returned separated by colons, with each traced call
on a separate line.'

    # Option processing.
    func_options "$@"
    eval set dummy "$func_options_result"; shift

    # Validate remaining non-option arguments.
    test $# -gt 1 \
        || func_fatal_help "not enough arguments"

    # Pass non-option arguments to extraction function.
    func_extract_trace "$@"

    # Display results.
    test -n "$func_extract_trace_result" \
        && $bs_echo "$func_extract_trace_result"

    # The End.
    exit $EXIT_SUCCESS
}


## --------------------------- ##
## Actually perform the trace. ##
## --------------------------- ##

# Only call 'func_main' if this script was called directly.
test extract-trace = "$progname" && func_main "$@"

# Local variables:
# mode: shell-script
# sh-indentation: 2
# eval: (add-hook 'write-file-hooks 'time-stamp)
# time-stamp-pattern: "10/scriptversion=%:y-%02m-%02d.%02H; # UTC"
# time-stamp-time-zone: "UTC"
# End:

# Set a version string for *this* script.
scriptversion=2012-10-21.12; # UTC

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Originally written by Paul Eggert.  The canonical version of this
# script is maintained as build-aux/bootstrap in gnulib, however, to
# be useful to your project, you should place a copy of it under
# version control in the top-level directory of your project.  The
# intent is that all customization can be done with a bootstrap.conf
# file also maintained in your version control; gnulib comes with a
# template build-aux/bootstrap.conf to get you started.

# Please report bugs or propose patches to bug-gnulib@gnu.org.


## ------ ##
## Usage. ##
## ------ ##

# Most GNUish projects do not keep all of the generated Autotool
# files under version control, but running all of the right tools
# with the right arguments, in the correct order to regenerate
# all of those files in readiness for configuration and building
# can be surprisingly involved!  Many projects have a 'bootstrap'
# script under version control to invoke Autotools and perform
# other assorted book-keeping with version numbers and the like.
#
# This bootstrap script aims to probe the configure.ac and top
# Makefile.am of your project to automatically determine what
# the correct ordering and arguments are and then run the tools for
# you.  In order to use it, you can generate an initial standalone
# script with:
#
#   gl/build-aux/inline-source gl/build-aux/bootstrap.in > bootstrap
#
# You should then store than script in version control for other
# developers in you project.  It will give you instructions about
# how to keep it up to date if the sources change.
#
# See gl/doc/bootstrap.texi for documentation on how to write
# a bootstrap.conf to customize it for your project's
# idiosyncracies.


## ================================================================== ##
##                                                                    ##
##     DO NOT EDIT THIS FILE, CUSTOMIZE IT USING A BOOTSTRAP.CONF     ##
##                                                                    ##
## ================================================================== ##

## ------------------------------- ##
## User overridable command paths. ##
## ------------------------------- ##

# All uppercase denotes values stored in the environment.  These
# variables should generally be overridden by the user - however, we do
# set them to 'true' in some parts of this script to prevent them being
# called at the wrong time by other tools that we call ('autoreconf',
# for example).
#
# We also allow 'LIBTOOLIZE', 'M4', 'SHA1SUM' and some others to be
# overridden, and export the result for child processes, but they are
# handled by the function 'func_find_tool' and not defaulted in this
# section.

: ${ACLOCAL="aclocal"}
: ${AUTOCONF="autoconf"}
: ${AUTOHEADER="autoheader"}
: ${AUTOM4TE="autom4te"}
: ${AUTOHEADER="autoheader"}
: ${AUTOMAKE="automake"}
: ${AUTOPOINT="autopoint"}
: ${AUTORECONF="autoreconf"}
: ${CMP="cmp"}
: ${CONFIG_SHELL="/bin/sh"}
: ${DIFF="diff"}
: ${EGREP="grep -E"}
: ${FGREP="grep -F"}
: ${GIT="git"}
: ${GREP="grep"}
: ${LN_S="ln -s"}
: ${RM="rm"}
: ${SED="sed"}

export ACLOCAL
export AUTOCONF
export AUTOHEADER
export AUTOM4TE
export AUTOHEADER
export AUTOMAKE
export AUTOPOINT
export AUTORECONF
export CONFIG_SHELL


## -------------- ##
## Configuration. ##
## -------------- ##

# A newline delimited list of triples of programs (that respond to
# --version), the minimum version numbers required (or just '-' in the
# version field if any version will be sufficient) and homepage URLs
# to help locate missing packages.
buildreq=

# Name of a file containing instructions on installing missing packages
# required in 'buildreq'.
buildreq_readme=README-hacking

# These are extracted from AC_INIT in configure.ac, though you can
# override those values in 'bootstrap.conf' if you prefer.
build_aux=
macro_dir=
package=
package_name=
package_version=
package_bugreport=

# These are extracted from 'gnulib-cache.m4', or else fall-back
# automatically on the gnulib defaults; unless you set the values
# manually in 'bootstrap.conf'.
doc_base=
gnulib_mk=
gnulib_name=
local_gl_dir=
source_base=
tests_base=

# The list of gnulib modules required at 'gnulib-tool' time.  If you
# check 'gnulib-cache.m4' into your repository, then this list will be
# extracted automatically.
gnulib_modules=

# Extra gnulib files that are not in modules, which override files of
# the same name installed by other bootstrap tools.
gnulib_non_module_files="
        build-aux/compile
        build-aux/install-sh
        build-aux/mdate-sh
        build-aux/texinfo.tex
        build-aux/depcomp
        build-aux/config.guess
        build-aux/config.sub
        doc/INSTALL
"

# Relative path to the local gnulib submodule, and url to the upstream
# git repository. If you have a gnulib entry in your .gitmodules file,
# these values are ignored.
gnulib_path=
gnulib_url=http://git.savannah.gnu.org/r/gnulib.git

# Additional gnulib-tool options to use.
gnulib_tool_options="
        --no-changelog
"

# bootstrap removes any macro-files that are not included by aclocal.m4,
# except for files listed in this variable which are always kept.
gnulib_precious="
        gnulib-tool.m4
"

# When truncating long commands for display, always allow at least this
# many characters before truncating.
min_cmd_len=160

# The command to download all .po files for a specified domain into
# a specified directory.  Fill in the first %s is the domain name, and
# the second with the destination directory.  Use rsync's -L and -r
# options because the latest/%s directory and the .po files within are
# all symlinks.
po_download_command_format=\
"rsync --delete --exclude '*.s1' -Lrtvz \
'translationproject.org::tp/latest/%s/' '%s'"

# Other locale categories that need message catalogs.
extra_locale_categories=

# Additional xgettext options to use.  Gnulib might provide you with an
# extensive list of additional options to append to this, but gettext
# 0.16.1 and newer appends them automaticaly, so you can safely ignore
# the complaints from 'gnulib-tool' if your $configure_ac states:
#
#    AM_GNU_GETTEXT_VERSION([0.16.1])
xgettext_options="
        --flag=_:1:pass-c-format
        --flag=N_:1:pass-c-format
"

# Package copyright holder for gettext files.  Defaults to FSF if unset.
copyright_holder=

# File that should exist in the top directory of a checked out hierarchy,
# but not in a distribution tarball.
checkout_only_file=

# Whether to use copies instead of symlinks by default (if set to true,
# the --copy option has no effect).
copy=false

# Set this to ".cvsignore .gitignore" in 'bootstrap.conf' if you want
# those files to be generated in directories like 'lib/', 'm4/', and 'po/',
# or set it to "auto" to make this script select which to use based
# on which version control system (if any) is used in the source directory.
# Or set it to "none" to ignore VCS ignore files entirely.  Default is
# "auto".
vc_ignore=


## ------------------- ##
## Hookable functions. ##
## ------------------- ##

# After 'bootstrap.conf' has been sourced, execution proceeds by calling
# 'func_bootstrap'.  Wherever a function is decorated with
# 'func_hookable func_name', you will find a matching 'func_run_hooks
# func_name' which executes all functions added with 'func_add_hook
# func_name my_func'.
#
# You might notice that many of these functions begin with a series of
# '$require_foo' lines.  See the docu-comments at the start of the
# 'Resource management' section for a description of what these are.


# func_bootstrap [ARG]...
# -----------------------
# All the functions called inside func_bootstrap are hookable. See the
# the individual implementations for details.
func_bootstrap ()
{
    $debug_cmd

    # Save the current positional parameters to prevent them being
    # corrupted by calls to 'set' in 'func_init'.
    func_quote_for_eval ${1+"$@"}
    _G_saved_positional_parameters=$func_quote_for_eval_result

    # Initialisation.
    func_init

    # Option processing.
    eval func_options "$_G_saved_positional_parameters"

    # Post-option preparation.
    func_prep

    # Ensure ChangeLog presence.
    func_ifcontains "$gnulib_modules" gitlog-to-changelog \
      func_ensure_changelog

    # Reconfigure the package.
    func_reconfigure

    # Ensure .version is up-to-date.
    func_update_dotversion

    # Finalisation.
    func_fini
}


# func_init
# ---------
# Any early initialisations can be hooked to this function.  Consider
# whether you can hook onto 'func_prep' instead, because if you hook
# any slow to execute code in here, it will also add to the time before
# './bootstrap --version' can respond.
func_hookable func_init
func_init ()
{
    $debug_cmd

    func_run_hooks func_init
}


# func_prep
# ---------
# Function to perform preparation for remaining bootstrap process. If
# your hooked code relies on the outcome of 'func_options' hook it here
# rather than to 'func_init'.
#
# All the functions called inside func_prep are hookable. See the
# individual implementations for details.
func_hookable func_prep
func_prep ()
{
    $debug_cmd

    $require_buildtools_uptodate
    $require_checkout_only_file

    $require_gnulib_merge_changelog

    # fetch update files from the translation project
    func_update_translations

    func_run_hooks func_prep
}


# func_update_translations
# ------------------------
# Update package po files and translations.
func_hookable func_update_translations
func_update_translations ()
{
    $debug_cmd

    $opt_skip_po || {
      test -d po && {
        $require_package

        func_update_po_files po $package || exit $?
      }

      func_run_hooks func_update_translations
    }
}


# func_reconfigure
# ----------------
# Reconfigure the current package by running the appropriate autotools in a
# suitable order.
func_hookable func_reconfigure
func_reconfigure ()
{
    $debug_cmd

    # Released 'autopoint' has the tendency to install macros that have
    # been obsoleted in current 'gnulib., so run this before 'gnulib-tool'.
    func_autopoint

    # Autoreconf runs 'aclocal' before 'libtoolize', which causes spurious
    # warnings if the initial 'aclocal' is confused by the libtoolized
    # (or worse: out-of-date) macro directory.
    func_libtoolize

    # If you need to do anything after 'gnulib-tool' is done, but before
    # 'autoreconf' runs, you don't need to override this whole function,
    # because 'func_gnulib_tool' is hookable.
    func_gnulib_tool

    func_autoreconf

    func_run_hooks func_reconfigure
}


# func_gnulib_tool
# ----------------
# Run 'gnulib-tool' to fetch gnulib modules into the current package.
#
# It's assumed that since you are using gnulib's 'bootstrap' script,
# you're also using gnulib elsewhere in your package.  If not, then
# you can replace this function in 'bootstrap.conf' with:
#
#   func_gnulib_tool () { :; }
#
# (although the function returns immediately if $gnulib_tool is set to
# true in any case).
func_hookable func_gnulib_tool
func_gnulib_tool ()
{
    $debug_cmd

    $require_gnulib_tool
    $require_libtoolize

    test true = "$gnulib_tool" || {
      if test -n "$gnulib_modules"; then
        $require_gnulib_cache
        $require_build_aux
        $require_macro_dir

        # Try not to pick up any stale values from 'gnulib-cache.m4'.
        rm -f "$gnulib_cache"

        gnulib_mode=--import

        # 'gnulib_modules' and others are maintained in 'bootstrap.conf':
        # Use 'gnulib --import' to fetch gnulib modules.
        test -n "$build_aux" \
            && func_append_uniq gnulib_tool_options " --aux-dir=$build_aux"
        test -n "$macro_dir" \
            && func_append_uniq gnulib_tool_options " --m4-base=$macro_dir"
        test -n "$doc_base" \
            && func_append_uniq gnulib_tool_options " --doc-base=$doc_base"
        test -n "$gnulib_name" \
            && func_append_uniq gnulib_tool_options " --lib=$gnulib_name"
        test -n "$local_gl_dir" \
            && func_append_uniq gnulib_tool_options " --local-dir=$local_gl_dir"
        test -n "$source_base" \
            && func_append_uniq gnulib_tool_options " --source-base=$source_base"
        test -n "$gnulib_mk" \
            && func_append_uniq gnulib_tool_options " --makefile-name=$gnulib_mk"
        test -n "$tests_base" && {
          func_append_uniq gnulib_tool_options " --tests-base=$tests_base"
          func_append_uniq gnulib_tool_options " --with-tests"
        }
      else

        # 'gnulib_modules' and others are cached in 'gnulib-cache.m4':
        # Use 'gnulib --update' to fetch gnulib modules.
        gnulib_mode=--update
      fi

      # Add a sensible default libtool option to gnulib_tool_options.
      # The embedded echo is to squash whitespace before globbing.
      case `echo " "$gnulib_tool_options" "` in
        *" --no-libtool "*|*" --libtool "*) ;;
        *)  if test true = "$LIBTOOLIZE"; then
              func_append_uniq gnulib_tool_options " --no-libtool"
            else
              func_append_uniq gnulib_tool_options " --libtool"
            fi
            ;;
      esac

      $opt_copy || func_append_uniq gnulib_tool_options " --symlink"

      func_append_uniq gnulib_tool_options " $gnulib_mode"
      func_append gnulib_tool_options " $gnulib_modules"

      # The embedded echo is to squash whitespace before display.
      gnulib_cmd=`echo $gnulib_tool $gnulib_tool_options`

      func_show_eval "$gnulib_cmd" 'exit $?'

      # Use 'gnulib-tool --copy-file' to install non-module files.
      func_install_gnulib_non_module_files
    }

    func_run_hooks func_gnulib_tool
}


# func_fini
# ---------
# Function to perform all finalisation for the bootstrap process.
func_hookable func_fini
func_fini ()
{
    $debug_cmd

    func_gettext_configuration
    func_clean_dangling_symlinks
    func_clean_unused_macros
    func_skip_po_recommendation

    func_run_hooks func_fini

    $require_bootstrap_uptodate

    func_echo "Done.  Now you can run './configure'."
}


# func_gettext_configuration
# --------------------------
# Edit configuration values into po/Makevars.
func_hookable func_gettext_configuration
func_gettext_configuration ()
{
    $debug_cmd

    $require_autopoint

    test true = "$AUTOPOINT" || {
      $require_copyright_holder
      $require_extra_locale_categories
      $require_package_bugreport

      # Escape xgettext options for sed Makevars generation below.
      # We have to delete blank lines in a separate script so that we don't
      # append \\\ to the penultimate line, and then delete the last empty
      # line, which messes up the variable substitution later in this
      # function.  Note that adding a literal \\\ requires double escaping
      # here, once for the execution subshell, and again for the assignment,
      # which is why there are actually 12 (!!) backslashes in the script.
      _G_xgettext_options=`echo "$xgettext_options$nl" |$SED '/^$/d' |$SED '
          $b
          s|$| \\\\\\\\\\\\|'`

      # Create gettext configuration.
      func_echo "Creating po/Makevars from po/Makevars.template ..."
      $RM -f po/Makevars
      $SED '
        /^EXTRA_LOCALE_CATEGORIES *=/s|=.*|= '"$extra_locale_categories"'|
        /^COPYRIGHT_HOLDER *=/s|=.*|= '"$copyright_holder"'|
        /^MSGID_BUGS_ADDRESS *=/s|=.*|= '"$package_bugreport"'|
        /^XGETTEXT_OPTIONS *=/{
          s|$| \\|
          a\
             '"$_G_xgettext_options"' \\\
             $${end_of_xgettext_options+}
        }
      ' po/Makevars.template >po/Makevars || exit 1
    }

    func_run_hooks func_gettext_configuration
}



## --------------- ##
## Core functions. ##
## --------------- ##

# This section contains the main functions called from the 'Hookable
# functions' (shown above), and are the ones you're  most likely
# to want to replace with your own implementations in 'bootstrap.conf'.


# func_autopoint
# --------------
# If this package uses gettext, then run 'autopoint'.
func_autopoint ()
{
    $debug_cmd

    $require_autopoint

    test true = "$AUTOPOINT" \
        || func_show_eval "$AUTOPOINT --force" 'exit $?'
}


# func_libtoolize
# ---------------
# If this package uses libtool, then run 'libtoolize'.
func_libtoolize ()
{
    $debug_cmd

    $require_libtoolize

    test true = "$LIBTOOLIZE" || {
      _G_libtoolize_options=
      $opt_copy && func_append _G_libtoolize_options " --copy"
      $opt_force && func_append _G_libtoolize_options " --force"
      $opt_verbose || func_append _G_libtoolize_options " --quiet"
      func_show_eval "$LIBTOOLIZE$_G_libtoolize_options" 'exit $?'
    }
}


# func_gnulib_tool_copy_file SRC DEST
# -----------------------------------
# Copy SRC, a path relative to the gnulib sub-tree, to DEST, a path
# relative to the top-level source directory using gnulib-tool so that
# any patches or replacements in $local_gl_dir are applied.
func_gnulib_tool_copy_file ()
{
    $debug_cmd

    $require_gnulib_path
    $require_gnulib_tool
    $require_patch

    gnulib_copy_cmd="$gnulib_tool --copy-file"
    $opt_copy || func_append gnulib_copy_cmd " --symlink"

    if test true = "$gnulib_tool"; then
      # If gnulib-tool is not available (e.g. bootstrapping in a
      # distribution tarball), make sure that at least we have some
      # version of the required file already in place.
      test -f "$2" || func_fatal_error "\
Can't find, copy or download '$2', a required
gnulib supplied file, please provide the location of a
complete 'gnulib' tree by setting 'gnulib_path' in your
'bootstrap.conf' or with the '--gnulib-srcdir' option -
or else specify the location of your 'git' binary by
setting 'GIT' in the environment so that a fresh
'gnulib' submodule can be cloned."
    else
      test -f "$gnulib_path/$1" || {
        func_error "'$gnulib_path/$1' does not exist"
        return 1
      }

      $gnulib_copy_cmd $1 $2
    fi
}


# func_install_gnulib_non_module_files
# ------------------------------------
# Get additional non-module files from gnulib, overriding existing files.
func_install_gnulib_non_module_files ()
{
    $debug_cmd

    $require_build_aux
    $require_gnulib_tool

    test -n "$gnulib_non_module_files" && {
      maybe_exit_cmd=:

      for file in $gnulib_non_module_files; do
        case $file in
          */COPYING*) dest=COPYING;;
          */INSTALL) dest=INSTALL;;
	  build-aux/missing) dest=
            func_warning settings "\
Please remove build-aux/missing from gnulib_module_files in
'bootstrap.conf', as it may clash with Automake's version."
            ;;
          build-aux/*) dest=$build_aux/`expr "$file" : 'build-aux/\(.*\)'`;;
          *) dest=$file;;
        esac

        # Be sure to show all copying errors before bailing out
	test -z "$dest" \
	    || func_gnulib_tool_copy_file "$file" "$dest" \
	    || maybe_exit_cmd="exit $EXIT_FAILURE"
      done

      $maybe_exit_cmd
    }
}


# func_ensure_changelog
# ---------------------
# Even with 'gitlog-to-changelog' generated ChangeLogs, automake
# will not run to completion with no ChangeLog file.
func_ensure_changelog ()
{
    $debug_cmd

    test -f ChangeLog && mv -f ChangeLog ChangeLog~

    cat >ChangeLog <<'EOT'
## ---------------------- ##
## DO NOT EDIT THIS FILE! ##
## ---------------------- ##

ChangeLog is generated by gitlog-to-changelog.
EOT

    _G_message="creating dummy 'ChangeLog'"
    test -f ChangeLog~ \
      && func_append _G_message ' (backup in ChangeLog~)'
    func_verbose "$_G_message"

    return 0
}


# func_autoreconf
# ---------------
# Being careful not to re-run 'autopoint' or 'libtoolize', and not to
# try to run 'autopoint', 'libtoolize' or 'autoheader' on packages that
# don't use them, defer to 'autoreconf' for execution of the remaining
# autotools to bootstrap this package.
func_autoreconf ()
{
    $debug_cmd

    $require_autoheader
    $require_build_aux  # automake and others put files in here
    $require_macro_dir  # aclocal and others put files in here

    # We ran these manually already, and autoreconf won't exec ':'
    save_AUTOPOINT=$AUTOPOINT; AUTOPOINT=true
    save_LIBTOOLIZE=$LIBTOOLIZE; LIBTOOLIZE=true

    _G_autoreconf_options=
    $opt_copy || func_append _G_autoreconf_options " --symlink"
    $opt_force && func_append _G_autoreconf_options " --force"
    $opt_verbose && func_append _G_autoreconf_options " --verbose"
    func_show_eval "$AUTORECONF$_G_autoreconf_options --install" 'exit $?'

    AUTOPOINT=$save_AUTOPOINT
    LIBTOOLIZE=$save_LIBTOOLIZE
}


# func_check_configuration VARNAME [CONFIGURE_MACRO]
# --------------------------------------------------
# Exit with a suitable diagnostic for an important configuration change
# that needs to be made before bootstrap can run correctly.
func_check_configuration ()
{
    $debug_cmd

    $require_configure_ac

    eval 'test -n "$'$1'"' || {
      _G_error_msg="please set '$1' in 'bootstrap.conf'"
      if test -n "$configure_ac" && test -n "$2"; then
        func_append _G_error_msg "
or add the following (or similar) to your '$configure_ac':
$2"
      fi

      func_fatal_error "$_G_error_msg"
    }
}


# func_clean_dangling_symlinks
# ----------------------------
# Remove any dangling symlink matching "*.m4" or "*.[ch]" in some
# gnulib-populated directories. Such .m4 files would cause aclocal to
# fail.  The following requires GNU find 4.2.3 or newer. Considering
# the usual portability constraints of this script, that may seem a very
# demanding requirement, but it should be ok.  Ignore any failure,
# which is fine, since this is only a convenience to help developers
# avoid the relatively unusual case in which a symlinked-to .m4 file is
# git-removed from gnulib between successive runs of this script.
func_clean_dangling_symlinks ()
{
    $debug_cmd

    $require_macro_dir
    $require_source_base

    func_verbose "cleaning dangling symlinks"

    find "$macro_dir" "$source_base" \
        -depth \( -name '*.m4' -o -name '*.[ch]' \) \
        -type l -xtype l -delete > /dev/null 2>&1
}


# func_clean_unused_macros
# ------------------------
# Autopoint can result in over-zealously adding macros into $macro_dir
# even though they are not actually used, for example tests to help
# build the 'intl' directory even though you have specified
# 'AM_GNU_GETTEXT([external])' in your configure.ac.  This function
# looks removes any macro files that can be found in gnulib,  but
# are not 'm4_include'd by 'aclocal.m4'.
func_clean_unused_macros ()
{
    $debug_cmd

    $require_gnulib_path
    $require_macro_dir

    test -n "$gnulib_path" && test -f aclocal.m4 && {
      aclocal_m4s=`find . -name aclocal.m4 -print`

      # We use 'ls|grep' instead of 'ls *.m4' to avoid exceeding
      # command line length limits in some shells.
      for file in `cd "$macro_dir" && ls -1 |grep '\.m4$'`; do

	# Remove a macro file when aclocal.m4 does not m4_include it...
        func_grep_q 'm4_include([[]'$macro_dir/$file'])' $aclocal_m4s \
            || test ! -f "$gnulib_path/m4/$file" || {

              # ...and there is an identical file in gnulib...
              if func_cmp_s "$gnulib_path/m4/$file" "$macro_dir/$file"; then

                # ...and it's not in the precious list ('echo' is needed
                # here to squash whitespace for the match expression).
                case " "`echo $gnulib_precious`" " in
                  *" $file "*) ;;
                  *) rm -f "$macro_dir/$file"
                     func_verbose \
                       "removing unused gnulib file '$macro_dir/$file'"
                esac
              fi
        }
      done
    }
}


# func_skip_po_recommendation
# ---------------------------
# If there is a po directory, and '--skip-po' wasn't passed, let the
# user know that they can use '--skip-po' on subsequent invocations.
func_skip_po_recommendation ()
{
    $debug_cmd

    test ! -d po \
        || $opt_skip_po \
        || func_warning recommend "\
If your pofiles are up-to-date, you can rerun bootstrap
as '$progname --skip-po' to avoid redownloading."
}


# func_update_dotversion
# ----------------------
# Even with 'gitlog-to-changelog' generated ChangeLogs, automake
# will not run to completion with no ChangeLog file.
func_update_dotversion ()
{
    $debug_cmd

    test -f "$build_aux/git-version-gen" && {
      _G_message="updating .version"
      test -f .version && {
        mv .version .version~
	func_append _G_message " (backup in .version~)"
      }
      func_verbose "updating .version"

      $build_aux/git-version-gen dummy-arg > .version
    }
}



## -------------------- ##
## Resource management. ##
## -------------------- ##

# This section contains definitions for functions that each ensure a
# particular resource (a file, or a non-empty configuration variable for
# example) is available, and if appropriate to extract default values
# from pertinent package files.  Where a variable already has a non-
# empty value (as set by the package's 'bootstrap.conf'), that value is
# used in preference to deriving the default. Call them using their
# associated 'require_*' variable to ensure that they are executed, at
# most, once.


# require_checkout_only_file
# --------------------------
# Bail out  if this package only bootstraps properly from a repository
# checkout.
require_checkout_only_file=func_require_checkout_only_file
func_require_checkout_only_file ()
{
    $debug_cmd

    $opt_force || {
      test -n "$checkout_only_file" && test ! -f "$checkout_only_file" \
          && func_fatal_error "\
Bootstrapping from a non-checked-out distribution is risky.
If you wish to bootstrap anyway, use the '--force' option."
    }

    require_checkout_only_file=:
}


# require_aclocal_amflags
# -----------------------
# Ensure '$aclocal_amflags' has a sensible default, extracted from
# 'Makefile.am' if necessary.
require_aclocal_amflags=func_require_aclocal_amflags
func_require_aclocal_amflags ()
{
    $debug_cmd

    $require_makefile_am

    _G_sed_extract_aclocal_amflags='s|#.*$||
        /^[	 ]*ACLOCAL_AMFLAGS[	 ]*=/ {
            s|^.*=[	 ]*\(.*\)|aclocal_amflags="\1"|
            p
        }'

    _G_aclocal_flags_cmd=`$SED -n "$_G_sed_extract_aclocal_amflags" \
        "$makefile_am"`
    eval "$_G_aclocal_flags_cmd"

    func_verbose "ACLOCAL_AMFLAGS='$aclocal_amflags'"

    require_aclocal_amflags=:
}


# require_autoheader
# ------------------
# Skip autoheader if it's not needed.
require_autoheader=func_require_autoheader
func_require_autoheader ()
{
    $debug_cmd

    test true = "$AUTOHEADER" || {
      func_extract_trace AC_CONFIG_HEADERS
      test -n "$func_extract_trace_result" \
	  || func_extract_trace AC_CONFIG_HEADER

      test -n "$func_extract_trace_result" || {
        AUTOHEADER=true

        func_verbose "export AUTOHEADER='$AUTOHEADER'"

        # Make sure the search result is visible to subshells
        export AUTOHEADER
      }
    }

    require_autoheader=:
}


# require_autopoint
# -----------------
# Skip autopoint if it's not needed.
require_autopoint=func_require_autopoint
func_require_autopoint ()
{
    $debug_cmd

    test true = "$AUTOPOINT" || {
      func_extract_trace AM_GNU_GETTEXT_VERSION

      test -n "$func_extract_trace_result" || {
        AUTOPOINT=true

        func_verbose "export AUTOPOINT='$AUTOPOINT'"

        # Make sure the search result is visible to subshells
        export AUTOPOINT
      }
    }

    require_autopoint=:
}


# require_bootstrap_uptodate
# --------------------------
# Complain if the version of bootstrap in the gnulib directory differs
# from the one we are running.
require_bootstrap_uptodate=func_require_bootstrap_uptodate
func_require_bootstrap_uptodate ()
{
    $debug_cmd

    $require_build_aux

    _G_bootstrap_sources="
      $build_aux/bootstrap.in
      $build_aux/extract-trace
      $build_aux/funclib.sh
      $build_aux/options-parser
    "

    _G_missing_bootstrap_sources=false
    for _G_src in $_G_bootstrap_sources; do
      test -f "$_G_src" || _G_missing_bootstrap_sources=:
    done

    if $_G_missing_bootstrap_sources; then
      func_warning upgrade "\
Please add bootstrap to your gnulib_modules list in
'bootstrap.conf', so that I can tell you when there are
updates available."
    else
      $build_aux/inline-source $build_aux/bootstrap.in > bootstrap.new

      if func_cmp_s "$progpath" bootstrap.new; then
        rm -f bootstrap.new
	func_verbose "bootstrap script up to date"
      else
        func_warning upgrade "\
An updated bootstrap script has been generated for you in
'bootstrap.new'.  After you've verified that you want
the changes, you can update with:
    cat bootstrap.new > $progname
    ./$progname

Or you can disable this check permanently by adding the
following to 'bootstrap.conf':
    require_bootstrap_uptodate=:"
      fi
    fi

    require_bootstrap_uptodate=:
}


# require_build_aux
# -----------------
# Ensure that '$build_aux' is set, and if it doesn't already point to an
# existing directory, create one.
require_build_aux=func_require_build_aux
func_require_build_aux ()
{
    $debug_cmd

    test -n "$build_aux" || {
      func_extract_trace_first AC_CONFIG_AUX_DIR
      build_aux=$func_extract_trace_first_result
      func_check_configuration build_aux \
          "AC_CONFIG_AUX_DIR([name of a directory for build scripts])"

      func_verbose "build_aux='$build_aux'"
    }

    $require_vc_ignore_files

    # If the build_aux directory doesn't exist, create it now, and mark it
    # as ignored for the VCS.
    if test ! -d "$build_aux"; then
      func_show_eval "mkdir '$build_aux'"

      test -n "$vc_ignore_files" \
          || func_insert_sorted_if_absent "$build_aux" $vc_ignore_files
    fi

    require_build_aux=:
}


# require_buildreq_autobuild
# --------------------------
# Try to find whether the bootstrap requires autobuild.
require_buildreq_autobuild=func_require_buildreq_autobuild
func_require_buildreq_autobuild ()
{
    $debug_cmd

    $require_macro_dir

    test -f "$macro_dir/autobuild.m4" \
        || printf '%s\n' "$buildreq" |func_grep_q '^[	 ]*autobuild' \
        || {
      func_extract_trace AB_INIT
      test -n "$func_extract_trace_result" && {
        func_append buildreq 'autobuild - http://josefsson.org/autobuild/
'
        func_verbose "auto-adding 'autobuild' to build requirements"
      }
    }

    require_buildreq_autobuild=:
}


# require_buildreq_autoconf
# require_buildreq_autopoint
# require_buildreq_libtoolize
# ---------------------------
# Try to find the minimum compatible version of autoconf/libtool
# required to bootstrap successfully, and add it to '$buildreq'.
for tool in autoconf libtoolize autopoint; do
  b=$tool
  v=require_buildreq_${tool}
  f=func_$v
  case $tool in
    autoconf) m=AC_PREREQ ;;
    libtoolize) m=LT_PREREQ; b=libtool ;;
    autopoint) m=AM_GNU_GETTEXT_VERSION b=gettext ;;
  esac

  eval $v'='$f'
  '$f' ()
  {
    $debug_cmd

    # The following is ignored if undefined, but might be necessary
    # in order for `func_find_tool` to run.
    ${require_'$tool'-:}

    printf '\''%s\n'\'' "$buildreq" |func_grep_q '\''^[	 ]*'$tool\'' || {
      func_extract_trace '$m'
      _G_version=$func_extract_trace_result
      test -n "$_G_version" && {
        func_append buildreq "\
            '$tool' $_G_version http://www.gnu.org/s/'$b'
"
        func_verbose \
            "auto-adding '\'$tool'-'$_G_version\'' to build requirements"
      }
    }

    '$v'=:
  }
'
done


# require_buildreq_automake
# -------------------------
# Try to find the minimum compatible version of automake required to
# bootstrap successfully, and add it to '$buildreq'.
require_buildreq_automake=func_require_buildreq_automake
func_require_buildreq_automake ()
{
    $debug_cmd

    # if automake is not already listed in $buildreq...
    printf '%s\n' "$buildreq" |func_grep_q automake || {
      func_extract_trace AM_INIT_AUTOMAKE

      # ...and AM_INIT_AUTOMAKE is declared...
      test -n "$func_extract_trace_result" && {
        automake_version=`$bs_echo "$func_extract_trace_result" \
           |$SED -e 's|[^0-9]*||' -e 's| .*$||'`
        test -n "$automake_version" || automake_version=-

        func_append buildreq "\
            automake $automake_version http://www.gnu.org/s/automake
"
        func_verbose \
            "auto-adding 'automake-$automake_version' to build requirements"
      }
    }

    require_buildreq_automake=:
}


# require_buildreq_patch
# ----------------------
# Automatically add a patch build-requirement if there are diff files
# in $local_gl_dir.
require_buildreq_patch=func_require_buildreq_patch
func_require_buildreq_patch ()
{
    $debug_cmd

    # This ensures PATCH is set appropriately by the time
    # func_check_versions enforces $buildreq.
    $require_patch

    # If patch is not already listed in $buildreq...
    printf '%s\n' "$buildreq" |func_grep_q '^[	 ]*patch' || {
      # The ugly find invocation is necessary to exit with non-zero
      # status for old find binaries that don't support -exec fully.
      if test ! -d "$local_gl_dir" \
          || find "$local_gl_dir" -name *.diff -exec false {} \; ; then :
      else
          func_append buildreq 'patch - http://www.gnu.org/s/patch
'
      fi
    }

    require_buildreq_patch=:
}


# require_buildtools_uptodate
# ---------------------------
# Ensure all the packages listed in BUILDREQS are available on the build
# machine at the minimum versions or better.
require_buildtools_uptodate=func_require_buildtools_uptodate
func_require_buildtools_uptodate ()
{
    $debug_cmd

    $require_buildreq_autobuild
    $require_buildreq_autoconf
    $require_buildreq_automake
    $require_buildreq_libtoolize
    $require_buildreq_autopoint
    $require_buildreq_patch

    test -n "$buildreq" && {
      _G_error_hdr=

      func_check_versions $buildreq
      $func_check_versions_result || {
        test -n "$buildreq_readme" \
            && test -f "$buildreq_readme" \
            && _G_error_hdr="\
$buildreq_readme explains how to obtain these prerequisite programs:
"
        func_strtable 0 11 12 36 \
            "Program" "Min_version" "Homepage" $buildreq
        func_fatal_error "$_G_error_hdr$func_strtable_result"
      }
    }

    require_buildtools_uptodate=:
}


# require_copyright_holder
# ------------------------
# Ensure there is a sensible non-empty default value in '$copyright_holder'.
require_copyright_holder=func_require_copyright_holder
func_require_copyright_holder ()
{
    $debug_cmd

    test -n "$copyright_holder" || {
      copyright_holder='Free Software Foundation, Inc.'
      func_warning settings "\
Please set copyright_holder explicitly in 'bootstrap.conf';
defaulting to '$copyright_holder'."
    }

    require_copyright_holder=:
}


# require_dotgitmodules
# ---------------------
# Ensure we have a '.gitmodules' file, with appropriate 'gnulib' settings.
require_dotgitmodules=func_require_dotgitmodules
func_require_dotgitmodules ()
{
    $debug_cmd

    $require_git

    test true = "$GIT" || {
      # A gnulib entry in .gitmodules always takes precedence.
      _G_path=`$GIT config --file .gitmodules submodule.gnulib.path 2>/dev/null`

      test -n "$_G_path" || {
        $require_vc_ignore_files

        func_verbose "creating '.gitmodules'"

        # If the .gitmodules file doesn't exist, create it now, and mark
        # it as ignored for the VCS.
        test -n "$gnulib_path" || gnulib_path=gnulib
        test -n "$gnulib_url"  || gnulib_url=http://git.savannah.gnu.org/r/gnulib.git

        {
          echo '[submodule "gnulib"]'
          echo "	path = $gnulib_path"
          echo "	url = $gnulib_url"
        } >> .gitmodules

        test -n "$vc_ignore_files" \
          || func_insert_sorted_if_absent ".gitmodules" $vc_ignore_files
      }
    }

    require_dotgitmodules=:
}


# require_extra_locale_categories
# -------------------------------
# Ensure there is a default value in '$extra_locale_categories'
require_extra_locale_categories=func_require_extra_locale_categories
func_require_extra_locale_categories ()
{
    $debug_cmd

    # Defaults to empty, so run with whatever value may have been set in
    # 'bootstrap.conf'.
    require_extra_locale_categories=:
}


# require_git
# -----------
# Ignore git if it's not available, or we're not in a git checkout tree.
#
#
# ***** WARNING ***** 
#
# This function is replaced by fontforge_require_git which is
# contained in bootstrap.conf. If you expect func_require_git to
# execute please look instead at fontforge_require_git for debugging.
#
require_git=func_require_git
func_require_git ()
{
    $debug_cmd

    $opt_skip_git && GIT=true

    test true = "$GIT" || {
      if test -f .gitignore && ($GIT --version) >/dev/null 2>&1; then :; else
      GIT=true
      fi
    }

    func_verbose "GIT='$GIT'"

    require_git=:
}


# require_gnulib_cache
# --------------------
# Ensure there is a non-empty default for '$gnulib_cache', and that it
# names an existing file.
require_gnulib_cache=func_require_gnulib_cache
func_require_gnulib_cache ()
{
    $debug_cmd

    $require_macro_dir

    test -n "$gnulib_cache" \
      || gnulib_cache=$macro_dir/gnulib-cache.m4

    func_verbose "found '$gnulib_cache'"

    require_gnulib_cache=:
}


# require_gnulib_merge_changelog
# ------------------------------
# See if we can use gnulib's git-merge-changelog merge driver.
require_gnulib_merge_changelog=func_require_gnulib_merge_changelog
func_require_gnulib_merge_changelog ()
{
    $debug_cmd

    test -f ChangeLog && {
      $require_git

      func_grep_q '^\(/\|\)ChangeLog$' .gitignore || test true = "$GIT" || {
        if $GIT config merge.merge-changelog.driver >/dev/null; then
          :
        elif (git-merge-changelog --version) >/dev/null 2>&1; then
          func_echo "initializing git-merge-changelog driver"
          $GIT config merge.merge-changelog.name 'GNU-style ChangeLog merge driver'
          $GIT config merge.merge-changelog.driver 'git-merge-changelog %O %A %B'
        else
          func_warning recommend \
              "Consider installing git-merge-changelog from gnulib."
        fi
      }
    }

    require_gnulib_merge_changelog=:
}


# require_gnulib_mk
# -----------------
# Ensure gnulib_mk has a sensible value, extracted from 'gnulib-cache.m4'
# if possible, otherwise letting 'gnulib-tool' pick a default.
require_gnulib_mk=func_require_gnulib_mk
func_require_gnulib_mk ()
{
    $debug_cmd

    test -f "$gnulib_cache" && test -z "$gnulib_mk" && {
      $require_gnulib_cache
      $require_macro_dir

      func_extract_trace_first "gl_MAKEFILE_NAME" "$gnulib_cache"
      gnulib_mk=$func_extract_trace_first_result

      test -n "$gnulib_mk" && func_verbose "gnulib_mk='$gnulib_mk'"
    }

    require_gnulib_mk=:
}


# require_gnulib_path
# require_gnulib_url
# -------------------
# Ensure 'gnulib_path' and 'gnulib_url' are set.
require_gnulib_path=func_require_dotgitmodules_parameters
require_gnulib_url=func_require_dotgitmodules_parameters
func_require_dotgitmodules_parameters ()
{
    $debug_cmd

    $require_git

    test true = "$GIT" && {
      # If we can't find git (or if the user specified '--skip-git'),
      # then use an existing gnulib directory specified with
      # '--gnulib-srcdir' if possible.
      test -n "$gnulib_path" \
          || test ! -x "$opt_gnulib_srcdir/gnulib-tool" \
          || gnulib_path=$opt_gnulib_srcdir
    }


    $require_dotgitmodules

    test -f .gitmodules && {
      # Extract the parameters with sed, since git may be missing
      test -n "$gnulib_path" \
        || gnulib_path=`$SED -e '/^.submodule "gnulib".$/,${
                                   /[	 ]*path *= */{
			             s|[   ]*||g;s|^[^=]*=||;p
			           }
		                 }
				 d' .gitmodules |$SED 1q`
      test -n "$gnulib_url" \
        || gnulib_url=`$SED -e '/^.submodule "gnulib".$/,${
                                  /[	 ]*url *= */{
			            s|[   ]*||g;s|^[^=]*=||;p
			          }
		                }
				d' .gitmodules |$SED 1q`

      func_verbose "gnulib_path='$gnulib_path'"
      func_verbose "gnulib_url='$gnulib_url'"
    }

    require_gnulib_path=:
    require_gnulib_url=:
}


# require_gnulib_submodule
# ------------------------
# Ensure that there is a current gnulib submodule at '$gnulib_path'.
require_gnulib_submodule=func_require_gnulib_submodule
func_require_gnulib_submodule ()
{
    $debug_cmd

    $require_git

    if test true = "$GIT"; then
      func_warning recommend \
          "No 'git' found; imported gnulib modules may be outdated."
    else
      $require_gnulib_path
      $require_gnulib_url

      if test -f .gitmodules && test -f "$gnulib_path/gnulib-tool"; then
        : All present and correct.

      elif test -n "$opt_gnulib_srcdir"; then
        # Older git can't clone into an empty directory.
        rmdir "$gnulib_path" 2>/dev/null
        func_show_eval "$GIT clone --reference '$opt_gnulib_srcdir' \
                '$gnulib_url' '$gnulib_path'" \
            || func_fatal_error "Unable to fetch gnulib submodule."

      # Without --gnulib-srcdir, and no existing checked out submodule, we
      # create a new shallow clone of the remote gnulib repository.
      else
        trap func_cleanup_gnulib 1 2 13 15

        shallow=
        $GIT clone -h 2>&1 |func_grep_q -- --depth \
            && shallow='--depth 365'

        func_show_eval "$GIT clone $shallow '$gnulib_url' '$gnulib_path'" \
          func_cleanup_gnulib

	# FIXME: Solaris /bin/sh will try to execute '-' if any of
	#        these signals are caught after this.
        trap - 1 2 13 15
      fi

      # Make sure we've checked out the correct revision of gnulib.
      func_show_eval "$GIT submodule init" \
          && func_show_eval "$GIT submodule update" \
          ||  func_fatal_error "Unable to update gnulib submodule."
    fi

    require_gnulib_submodule=:
}


# require_gnulib_tool
# -------------------
# Ensure that '$gnulib_tool' is set, and points to an executable file,
# or else fall back to using the binary 'true' if the main gnulib
# files appear to have been imported already.
require_gnulib_tool=func_require_gnulib_tool
func_require_gnulib_tool ()
{
    $debug_cmd

    $require_gnulib_submodule

    test true = "$gnulib_tool" || {
      $require_gnulib_path

      test -n "$gnulib_tool" \
        || gnulib_tool=$gnulib_path/gnulib-tool

      test -x "$gnulib_tool" || {
        gnulib_tool=true
        func_warning recommend \
            "No 'gnulib-tool' found; gnulib modules may be missing."
      }

      test true = "$gnulib_tool" \
          || func_verbose "found '$gnulib_tool'"
    }

    require_gnulib_tool=:
}


# require_libtoolize
# ------------------
# Skip libtoolize if it's not needed.
require_libtoolize=func_require_libtoolize
func_require_libtoolize ()
{
    $debug_cmd

    # Unless we're not searching for libtool use by this package, set
    # LIBTOOLIZE to true if none of 'LT_INIT', 'AC_PROG_LIBTOOL' and
    # 'AM_PROG_LIBTOOL' are used in configure.
    test true = "$LIBTOOLIZE" || {
      func_extract_trace LT_INIT
      test -n "$func_extract_trace_result" || func_extract_trace AC_PROG_LIBTOOL
      test -n "$func_extract_trace_result" || func_extract_trace AM_PROG_LIBTOOL
      test -n "$func_extract_trace_result" || LIBTOOLIZE=true
    }

    test -n "$LIBTOOLIZE" || {
      # Find libtoolize, named glibtoolize in Mac Ports, but prefer
      # user-installed libtoolize to ancient glibtoolize shipped by
      # Apple with Mac OS X when Mac Ports is not installed.
      func_find_tool LIBTOOLIZE libtoolize glibtoolize
    }

    func_verbose "export LIBTOOLIZE='$LIBTOOLIZE'"

    # Make sure the search result is visible to subshells
    export LIBTOOLIZE

    require_libtoolize=:
}


# require_macro_dir
# -----------------
# Ensure that '$macro_dir' is set, and if it doesn't already point to an
# existing directory, create one.
require_macro_dir=func_require_macro_dir
func_require_macro_dir ()
{
    $debug_cmd

    # Sometimes this is stored in 'configure.ac'.
    test -n "$macro_dir" || {
      # AC_CONFIG_MACRO_DIRS takes a space delimited list of directories,
      # but we only care about the first one in bootstrap.
      func_extract_trace_first AC_CONFIG_MACRO_DIRS
      macro_dir=`expr "x$func_extract_trace_first_result" : 'x\([^	 ]*\)'`
    }
    test -n "$macro_dir" || {
      func_extract_trace_first AC_CONFIG_MACRO_DIR
      macro_dir=$func_extract_trace_first_result
    }

    # Otherwise we might find it in 'Makefile.am'.
    test -n "$macro_dir" || {
      $require_aclocal_amflags

      # Take the argument following the first '-I', if any.
      _G_minus_I_seen=false
      for _G_arg in $aclocal_amflags; do
        case $_G_minus_I_seen,$_G_arg in
          :,*)   macro_dir=$_G_arg; break ;;
          *,-I)  _G_minus_I_seen=: ;;
          *,-I*) macro_dir=`expr x$_G_arg : 'x-I\(.*\)$'`; break ;;
        esac
      done
    }

    func_verbose "macro_dir='$macro_dir'"

    func_check_configuration macro_dir \
        "AC_CONFIG_MACRO_DIRS([name of a directory for configure m4 files])"

    $require_vc_ignore_files

    # If the macro_dir directory doesn't exist, create it now, and mark it
    # as ignored for the VCS.
    if test ! -d "$macro_dir"; then
      mkdir "$macro_dir" || func_permissions_error "$macro_dir"

      test -n "$vc_ignore_files" \
        || func_insert_sorted_if_absent "$macro_dir" $vc_ignore_files
    fi

    require_macro_dir=:
}


# require_makefile_am
# -------------------
# Ensure there is a 'Makefile.am' in the current directory.
# names an existing file.
require_makefile_am=func_require_makefile_am
func_require_makefile_am ()
{
    $debug_cmd

    test -n "$makefile_am" \
      || makefile_am=Makefile.am

    <"$makefile_am"

    func_verbose "found '$makefile_am'"

    require_makefile_am=:
}


# require_package
# ---------------
# Ensure that '$package' contains a sensible default value.
require_package=func_require_package
func_require_package ()
{
    $debug_cmd

    test -n "$package" || {
      $require_package_name

      package=`echo "$package_name" \
        |$SED -e 's/GNU //' \
	      -e 'y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/'`
    }

    func_verbose "package='$package'"

    require_package=:
}


# require_package_bugreport
# -------------------------
# Ensure that this has a sensible value, extracted from 'configure.ac'
# if appropriate (and possible!).
require_package_bugreport=func_require_package_bugreport
func_require_package_bugreport ()
{
    $debug_cmd

    func_extract_trace AC_INIT

    save_ifs=$IFS
    IFS=:
    set dummy $func_extract_trace_result
    IFS=$save_ifs
    shift

    test -n "$package_bugreport" || package_bugreport=$3
    func_check_configuration package_bugreport \
      "AC_INIT([$package_name], [$package_version], [bug-$package@gnu.org])"
    func_verbose "package_bugreport='$package_bugreport'"

    require_package_bugreport=:
}


# require_package_name
# --------------------
# Ensure that this has a sensible value, extracted from 'configure.ac'
# if appropriate (and possible!).
require_package_name=func_require_package_name
func_require_package_name ()
{
    $debug_cmd

    func_extract_trace AC_INIT

    save_ifs=$IFS
    IFS=:
    set dummy $func_extract_trace_result
    IFS=$save_ifs
    shift

    test -n "$package_name" || package_name=$1
    func_check_configuration package_name \
      "AC_INIT([name of your package], [package version number])"
    func_verbose "package_name='$package_name'"

    require_package_name=:
}


# require_package_version
# -----------------------
# Ensure that this has a sensible value, extracted from 'configure.ac'
# if appropriate (and possible!).  While we might have set all the
# parameters extracted from AC_INIT at once, 'package_version' in
# particular is not necessarily available as early as the others, since
# 'git-version-gen' is often involved, and until then we can't rely on
# getting a correct version number from an AC_INIT extraction.
require_package_version=func_require_package_version
func_require_package_version ()
{
    $debug_cmd

    func_extract_trace AC_INIT

    save_ifs=$IFS
    IFS=:
    set dummy $func_extract_trace_result
    IFS=$save_ifs
    shift

    test -n "$package_version" || package_version=$2
    test -n "$package_version" || {
      # The embedded echo is to squash whitespace before globbing.
      case " "`echo $gnulib_modules`" " in
	*" git-version-gen "*)
	  func_fatal_error "\
cannot \$require_package_version in bootstrap.conf before
func_gnulib_tool has installed the 'git-version-gen' script."
	  ;;
	*)
          func_check_configuration package_version \
            "AC_INIT([name of your package], [package version number])"
	  ;;
      esac
    }
    func_verbose "package_version='$package_version'"

    require_package_version=:
}


# require_patch
# -------------
# Find patch, according to the PATCH environment variable, or else
# searching the user's PATH.
require_patch=func_require_patch
func_require_patch ()
{
    $debug_cmd

    test -n "$PATCH" || {
      # Find a patch program, preferring gpatch which is usually better
      # than the vendor patch.
      func_find_tool PATCH gpatch patch
    }

    func_verbose "export PATCH='$PATCH'"

    # Make sure the search result is visible to subshells
    export PATCH

    require_patch=:
}


# require_source_base
# -------------------
# Ensure that source_base has a sensible value, extracted from
# 'gnulib-cache.m4' if possible.
require_source_base=func_require_source_base
func_require_source_base ()
{
    $debug_cmd

    $require_gnulib_cache

    test -f "$gnulib_cache" && test -z "$source_base" && {
      $require_macro_dir

      func_extract_trace_first "gl_SOURCE_BASE" "$gnulib_cache"

      source_base=$func_extract_trace_first_result

      func_verbose "source_base='$source_base'"
    }

    require_source_base=:
}


# require_vc_ignore_files
# -----------------------
# Ensure that '$vc_ignore' has been processed to list VCS ignore files
# in '$vc_ignore_files'
require_vc_ignore_files=func_require_vc_ignore_files
func_require_vc_ignore_files ()
{
    $debug_cmd

    test -n "$vc_ignore" || vc_ignore=auto

    if test auto = "$vc_ignore" && test -z "$vc_ignore_files"; then
      vc_ignore_files=
      test -d .git && vc_ignore_files=.gitignore
      test -d CVS && vc_ignore_files="$vc_ignore_files .cvsignore"
    else
      vc_ignore_files=$vc_ignore
    fi

    func_verbose "vc_ignore_files='$vc_ignore_files'"

    require_vc_ignore_files=:
}


## ------------------##
## Helper functions. ##
## ------------------##

# This section contains the helper functions used by the rest of 'bootstrap'.

# func_len STRING
# ---------------
# STRING may not start with a hyphen.
if (eval 'x=123; test x${#x} = "x3"') 2>/dev/null
then
  # This is an XSI compatible shell, allowing a faster implementation...
  eval 'func_len ()
  {
    $debug_cmd

    func_len_result=${#1}
  }'
else
  # ...otherwise fall back to using expr, which is often a shell builtin.
  func_len ()
  {
    $debug_cmd

    func_len_result=`expr "$1" : ".*" 2>/dev/null || echo 0`
  }
fi


# func_unset VAR
# --------------
# Portably unset VAR.
# In some shells, an 'unset VAR' statement leaves a non-zero return
# status if VAR is already unset, which might be problematic if the
# statement is used at the end of a function (thus poisoning its return
# value) or when 'set -e' is active (causing even a spurious abort of
# the script in this case).
func_unset ()
{
    { eval $1=; unset $1; }
}
unset=func_unset


# func_cmp_s FILE1 FILE2
# ----------------------
# Return non-zero exit status unless FILE1 and FILE2 are identical, without
# any output at all, even error messages.
func_cmp_s ()
{
    $debug_cmd

    # This function relies on non-zero exit status, which will cause the
    # program to exit when running in 'set -e' mode.
    $CMP "$@" >/dev/null 2>&1
}


# func_grep_q EXPRESSION [FILENAME..]
# -----------------------------------
# Check whether EXPRESSION matches any line of any listed FILENAME,
# without any output at all, even error messages.
func_grep_q ()
{
    $debug_cmd

    # This function relies on non-zero exit status, which will cause the
    # program to exit when running in 'set -e' mode.
    $GREP "$@" >/dev/null 2>&1
}


# func_ifcontains LIST MEMBER YES-CMD [NO-CMD]
# --------------------------------------------
# If whitespace-separated LIST contains MEMBER then execute YES-CMD,
# otherwise if NO-CMD was give, execute that.
func_ifcontains ()
{
    $debug_cmd

    # The embedded echo is to squash whitespace before globbing.
    _G_wslist=`$bs_echo " "$1" "`
    _G_member=$2
    _G_yes_cmd=$3
    _G_no_cmd=${4-":"}

    case $_G_wslist in
      *" $_G_member "*)
        eval "$_G_yes_cmd"
	_G_status=$?
	;;
      *)
	eval "$_G_no_cmd"
	_G_status=$?
	;;
    esac

    test 0 -eq "$_G_status" || exit $_G_status
}


# func_strpad STR WIDTH CHAR
# --------------------------
# Trim STR, or pad with CHAR to force a total length of WIDTH.
func_strpad ()
{
    $debug_cmd

    _G_width=`expr "$2" - 1`
    func_strpad_result=`$bs_echo "$1" |$SED '
        :a
        s|^.\{0,'"$_G_width"'\}$|&'"$3"'|
        ta
    '`
}


# func_strrpad STR WIDTH CHAR
# ---------------------------
# Trim STR, or right-justify-pad with CHAR to force a total length of
# WIDTH.
func_strrpad ()
{
    $debug_cmd

    _G_width=`expr "$2" - 1`
    func_strrpad_result=`$bs_echo "$1" |$SED '
        :a
        s|^.\{0,'"$_G_width"'\}$|'"$3"'&|
        ta
    '`
}


# func_strrow INDENT FIELD WIDTH [FIELDn WIDTHn]...
# -------------------------------------------------
# Return a string containing each FIELD left justified to WIDTH, with
# the whole thing indented by INDENT spaces.  This function is used to
# render one row of aligned columns for a table by func_strtable().
func_strrow ()
{
    $debug_cmd

    func_strrow_linelen=$1; shift

    _G_row=
    while test $# -gt 0; do
      func_strrow_linelen=`expr $func_strrow_linelen + $2`
      func_strpad "$1" $2 " "
      func_append _G_row "$func_strpad_result"
      shift; shift
    done

    func_strrpad "$_G_row" $func_strrow_linelen " "
    func_strrow_result=$func_strrpad_result
}


# func_strtable INDENT WIDTH1...WIDTHn HEADER1...HEADERn FIELD1...FIELDn
# ----------------------------------------------------------------------
# Generate a string of newline-separated rows arranged in lined-up
# columns of the given WIDTHs, with the entire table indented by INDENT
# spaces.  The number of columns is determined by the number of integer
# valued WIDTH arguments following INDENT.  The next set (i.e. a number
# of arguments equal to the number of WIDTH arguments) of fields are
# treated as the table's column HEADERs, and are separated from the
# remainder of the table by an indented row of '-' characters. Remaining
# arguments are each aligned below the next available header, wrapping
# to a new row as necessary.  Finally another row of '-' characters is
# added to mark the end of the table.
#
# For example an unindented 3 column table with 2 rows of data would be
# generated by this call:
#
#    func_strtable 3 20 10 25 \
#        Header1 Header2 Header3 \
#        Row1Col1 Row1Col2 Row1Col3 \
#        Row2Col1 Row2Col2 Row2Col3
#
# returning the following string:
#
# "   Header1             Header2   Header3
#     -------------------------------------------------------
#     Row1Col1            Row1Col2  Row1Col3
#     Row2Col1            Row2Col2  Row2Col3
#     -------------------------------------------------------"
func_strtable ()
{
    $debug_cmd

    # Save the indent value, we'll need it for each row we render.
    _G_indent=$1; shift

    # Collect remaining numeric args into a list for reuse between
    # members of each row when we call func_strrow later.
    _G_widths=$1; shift
    while test 0 -lt `expr "$1" : '[1-9][0-9]*$'`; do
      func_append _G_widths " $1"; shift
    done

    # Extract the same number of positional parameters as there are
    # width elements - we'll do the header rows separately so that
    # we can insert a divider line.
    _G_header=$_G_indent
    for _G_width in $_G_widths; do
      func_append _G_header " $1 $_G_width"; shift
    done
    func_strrow $_G_header

    # Strip off the indent, and make a divider with '-' chars, then
    # reindent.
    _G_divider=`$bs_echo "$func_strrow_result" \
        |$SED 's|[^ ]|-|g
            :a
            s|- |--|g
            ta
        '`

    # Append the header and divider to the running result.
    func_append func_strtable_result "\
$func_strrow_result
$_G_divider
"

    # The remaining rows are zipped between the width values we
    # unwound earlier just like the header row above.
    while test $# -gt 0; do
      _G_row=$_G_indent
      for _G_width in $_G_widths; do
        func_append _G_row " $1 $_G_width"; shift
      done
      func_strrow $_G_row
      func_append func_strtable_result "\
$func_strrow_result
"
    done

    # Mark the end of the table with a final divider line.
    func_append func_strtable_result "$_G_divider"
}


# func_internal_error ARG...
# --------------------------
# Echo program name prefixed message to standard error, and exit.
func_internal_error ()
{
    func_fatal_error "\
INTERNAL: " ${1+"$@"} "
          Please report this bug to 'bug-gnulib@gnu.org'
          in as much detail as possible."
}


# func_permissions_error FILE-OR-DIRECTORY
# ----------------------------------------
# Echo program name prefixed permissions error message to standard
# error, and exit.
func_permissions_error ()
{
    $debug_cmd

    func_fatal_error "Failed to create '$1', check permissions."
}


# func_show_eval CMD [FAIL_EXP]
# -----------------------------
# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is
# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP
# is given, then evaluate it.
func_show_eval ()
{
    $debug_cmd

    $require_term_colors

    _G_cmd=$1
    _G_fail_exp=${2-':'}

    ${opt_silent-'false'} || {
      func_quote_for_eval $_G_cmd
      eval func_truncate_cmd $func_quote_for_eval_result
      func_echo "running: $tc_bold$func_truncate_cmd_result$tc_reset"
    }

    ${opt_dry_run-'false'} || {
      eval "$_G_cmd"
      _G_status=$?
      test 0 -eq "$_G_status" || eval "(exit $_G_status); $_G_fail_exp"
    }
}


# func_truncate_cmd CMD [ARG]...
# ------------------------------
# For unreasonably long commands (such as a gnulib-tool invocation with
# the full module list for import), truncate CMD after the second non-
# option ARG.
func_truncate_cmd ()
{
    $debug_cmd

    _G_last_arg_opt_p=false
    func_truncate_cmd_result=

    set dummy "$@"; shift

    while test $# -gt 0; do
      _G_opt=$1; shift

      test -n "$func_truncate_cmd_result" \
          && func_append func_truncate_cmd_result ' '
      func_append func_truncate_cmd_result "$_G_opt"

      func_len "x$func_truncate_cmd_result"

      case $_G_opt in
        -*) _G_last_arg_opt_p=: ;;
        *)  $_G_last_arg_opt_p \
                || test "$min_cmd_len" -gt "$func_len_result" \
                || break
            _G_last_arg_opt_p=false
            ;;
      esac
    done

    test $# -gt 0 && func_append func_truncate_cmd_result "..."
}


# func_insert_sorted_if_absent STR FILE...
# ----------------------------------------
# If $STR is not already on a line by itself in $FILE, insert it,
# sorting the new contents of the file and replacing $FILE with the result.
func_insert_sorted_if_absent ()
{
    $debug_cmd

    str=$1
    shift

    for file
    do
      test -f "$file" || touch "$file"

      func_grep_q "$str" "$file" \
          && func_verbose "inserting '$str' into '$file'"

      $bs_echo "$str" |sort -u - "$file" |func_cmp_s - "$file" \
        || $bs_echo "$str" |sort -u - "$file" -o "$file" \
        || func_permissions_error "$file"
    done
}


# func_sort_ver VER1 VER2
# -----------------------
# 'sort -V' is not generally available.
# Note this deviates from the version comparison in automake
# in that it treats 1.5 < 1.5.0, and treats 1.4.4a < 1.4-p3a
# but this should suffice as we won't be specifying old
# version formats or redundant trailing .0 in bootstrap.conf.
# If we did want full compatibility then we should probably
# use m4_version_compare from autoconf.
func_sort_ver ()
{
    $debug_cmd

    ver1=$1
    ver2=$2

    # Split on '.' and compare each component.
    i=1
    while :; do
      p1=`echo "$ver1" |cut -d. -f$i`
      p2=`echo "$ver2" |cut -d. -f$i`
      if test ! "$p1"; then
        echo "$1 $2"
        break
      elif test ! "$p2"; then
        echo "$2 $1"
        break
      elif test ! "$p1" = "$p2"; then
        if test "$p1" -gt "$p2" 2>/dev/null; then # numeric comparison
          echo "$2 $1"
        elif test "$p2" -gt "$p1" 2>/dev/null; then # numeric comparison
          echo "$1 $2"
        else # numeric, then lexicographic comparison
          lp=`printf "$p1\n$p2\n" |sort -n |tail -n1`
          if test "$lp" = "$p2"; then
            echo "$1 $2"
          else
            echo "$2 $1"
          fi
        fi
        break
      fi
      i=`expr $i + 1`
    done
}


# func_get_version APP
# --------------------
# echo the version number (if any) of APP, which is looked up along your
# PATH.
func_get_version ()
{
    $debug_cmd

    _G_app=$1

    # Rather than uncomment the sed script in-situ, strip the comments
    # programatically before passing the result to $SED for evaluation.
    sed_get_version=`$bs_echo '# extract version within line
          s|.*[v ]\{1,\}\([0-9]\{1,\}\.[.a-z0-9-]*\).*|\1|
          t done

          # extract version at start of line
          s|^\([0-9]\{1,\}\.[.a-z0-9-]*\).*|\1|
          t done

          d

          :done
          # the following essentially does s|5.005|5.5|
          s|\.0*\([1-9]\)|.\1|g
          p
          q' \
    |$SED '/^[	 ]*#.*$/d'`

    func_tool_version_output $_G_app >/dev/null
    _G_status=$?

    test 0 -ne "$_G_status" \
      || $_G_app --version 2>&1 |$SED -n "$sed_get_version"

    (exit $_G_status)
}


# func_check_versions APP1 VER1 URL1 ...[APPN VERN URLN]
# ------------------------------------------------------
func_check_versions ()
{
    $debug_cmd

    func_check_versions_result=:

    while test $# -gt 0; do
      _G_app=$1; shift
      _G_reqver=$1; shift
      _G_url=$1; shift

      # Honor $APP variables ($TAR, $AUTOCONF, etc.)
      _G_appvar=`echo $_G_app |tr '[a-z]' '[A-Z]'`
      test TAR = "$_G_appvar" && _G_appvar=AMTAR
      eval "_G_app=\${$_G_appvar-$_G_app}"
      _G_instver=`func_get_version $_G_app`

      test -z "$_G_instver" \
          || func_verbose "found '$_G_app' version $_G_instver."

      # Fail if --version didn't work.
      if test -z "$_G_instver"; then
        func_error "Prerequisite '$_G_app' not found. Please install it, or
'export $_G_appvar=/path/to/$_G_app'."
        func_check_versions_result=false

      # Fail if a new version than what we have is required.
      elif test x- != "x$_G_reqver"; then
        _G_newer=`func_sort_ver $_G_reqver $_G_instver |cut -d' ' -f2`
        test "$_G_newer" != "$_G_instver" && {
          func_error "\
'$_G_app' version == $_G_instver is too old
'$_G_app' version >= $_G_reqver is required"
          func_check_versions_result=false
        }
      fi
    done
}


# func_cleanup_gnulib
# -------------------
# Recursively delete everything below the path in the global variable
# GNULIB_PATH.
func_cleanup_gnulib ()
{
    $debug_cmd

    _G_status=$?
    $RM -fr "$gnulib_path"
    exit $_G_status
}


# func_download_po_files SUBDIR DOMAIN
# ------------------------------------
func_download_po_files ()
{
    $debug_cmd

    func_echo "getting translations into $1 for $2..."
    _G_cmd=`printf "$po_download_command_format" "$2" "$1"`
    eval "$_G_cmd"
}


# func_update_po_files PO_DIR DOMAIN
# ----------------------------------
# Mirror .po files to $po_dir/.reference and copy only the new
# or modified ones into $po_dir.  Also update $po_dir/LINGUAS.
# Note po files that exist locally only are left in $po_dir but will
# not be included in LINGUAS and hence will not be distributed.
func_update_po_files ()
{
    $debug_cmd

    # Directory containing primary .po files.
    # Overwrite them only when we're sure a .po file is new.
    _G_po_dir=$1
    _G_domain=$2

    # Mirror *.po files into this dir.
    # Usually contains *.s1 checksum files.
    _G_ref_po_dir=$_G_po_dir/.reference

    test -d "$_G_ref_po_dir" || mkdir $_G_ref_po_dir || return
    func_download_po_files $_G_ref_po_dir $_G_domain \
      && ls "$_G_ref_po_dir"/*.po 2>/dev/null \
         |$SED -e 's|.*/||' -e 's|\.po$||' > "$_G_po_dir/LINGUAS" || return

    # Find sha1sum, named gsha1sum on MacPorts, and shasum on MacOS 10.6+.
    func_find_tool SHA1SUM sha1sum gsha1sum shasum

    _G_langs=`cd $_G_ref_po_dir && echo *.po|$SED 's|\.po||g'`
    test '*' = "$_G_langs" && _G_langs=x
    for _G_po in $_G_langs; do
      case $_G_po in x) continue;; esac
      _G_new_po=$_G_ref_po_dir/$_G_po.po
      _G_cksum_file=$_G_ref_po_dir/$_G_po.s1
      if ! test -f "$_G_cksum_file" ||
          ! test -f "$_G_po_dir/$_G_po.po" ||
          ! $SHA1SUM -c --status "$_G_cksum_file" \
              < "$_G_new_po" > /dev/null; then
        echo "updated $_G_po_dir/$_G_po.po..."
        cp "$_G_new_po" "$_G_po_dir/$_G_po.po" \
          && $SHA1SUM < "$_G_new_po" > "$_G_cksum_file"
      fi
    done
}



## --------------- ##
## Option parsing. ##
## --------------- ##

# Hook in the functions to make sure our own options are parsed during
# the option parsing loop.

usage='$progpath [OPTION]...'

# Short help message in response to '-h'.  Add to this in 'bootstrap.conf'
# if you accept any additional options.
usage_message="Common Bootstrap Options:
   -c, --copy         copy files instead of creating symbolic links.
       --debug        enable verbose shell tracing
   -n, --dry-run      print commands rather than running them
   -f, --force        attempt to bootstrap even if the sources seem not
                      to have been checked out.
       --gnulib-srcdir=DIRNAME
                      specify a local directory where gnulib sources
                      reside. Use this if you already have the gnulib
                      sources on your machine, and don't want to waste
                      your bandwidth downloading them again.  Defaults to
                      \$GNULIB_SRCDIR.
       --no-warnings  equivalent to '-Wnone'
       --skip-git     do not fetch files from remote repositories
       --skip-po      do not download po files.
   -v, --verbose      verbosely report processing
       --version      print version information and exit
   -W, --warnings=CATEGORY
                      report the warnings falling in CATEGORY [all]
   -h, --help         print short or long help message and exit
"

# Additional text appended to 'usage_message' in response to '--help'.
long_help_message=$long_help_message"
       'recommend'    show warnings about missing recommended packages
       'settings'     show warnings about missing '$progname.conf' settings
       'upgrade'      show warnings about out-dated files

If the file '$progname.conf' exists in the same directory as this
script, its contents are read as shell variables to configure the
bootstrap.

For build prerequisites, environment variables like \$AUTOCONF and
\$AMTAR are honored.

Running without arguments will suffice in most cases.
"

# Warning categories used by 'bootstrap', append others if you use them
# in your 'bootstrap.conf'.
warning_categories='recommend settings upgrade'


# bootstrap_options_prep [ARG]...
# -------------------------------
# Preparation for options parsed by Bootstrap.
bootstrap_options_prep ()
{
    $debug_cmd

    # Option defaults:
    opt_copy=${copy-'false'}
    opt_dry_run=false
    opt_force=false
    opt_gnulib_srcdir=$GNULIB_SRCDIR
    opt_skip_git=false
    opt_skip_po=false

    # Pass back the list of options we consumed.
    func_quote_for_eval ${1+"$@"}
    bootstrap_options_prep_result=$func_quote_for_eval_result
}
func_add_hook func_options_prep bootstrap_options_prep


# bootstrap_parse_options [ARG]...
# --------------------------------
# Provide handling for Bootstrap specific options.
bootstrap_parse_options ()
{
    $debug_cmd

    # Perform our own loop to consume as many options as possible in
    # each iteration.
    while test $# -gt 0; do
      _G_opt=$1
      shift
      case $_G_opt in
        --dry-run|--dryrun|-n)
                      opt_dry_run=: ;;
        --copy|-c)    opt_copy=: ;;
        --force|-f)   opt_force=: ;;

        --gnulib-srcdir)
                      test $# = 0 && func_missing_arg $_G_opt && break
                      opt_gnulib_srcdir=$1
                      shift
                      ;;

        --skip-git)   opt_skip_git=: ;;
        --skip-po)    opt_skip_po=: ;;

        # Separate non-argument short options:
        -c*|-f*|-n*)
                      func_split_short_opt "$_G_opt"
                      set dummy "$func_split_short_opt_name" \
                          "-$func_split_short_opt_arg" ${1+"$@"}
                      shift
                      ;;

        *)            set dummy "$_G_opt" ${1+"$@"}; shift; break ;;
      esac
    done

    # save modified positional parameters for caller
    func_quote_for_eval ${1+"$@"}
    bootstrap_parse_options_result=$func_quote_for_eval_result
}
func_add_hook func_parse_options bootstrap_parse_options


# bootstrap_validate_options [ARG]...
# -----------------------------------
# Perform any sanity checks on option settings and/or unconsumed
# arguments.
bootstrap_validate_options ()
{
    $debug_cmd

    # Validate options.
    test $# -gt 0 \
        && func_fatal_help "too many arguments"

    # Pass back the (empty) list of unconsumed options.
    func_quote_for_eval ${1+"$@"}
    bootstrap_validate_options_result=$func_quote_for_eval_result
}
func_add_hook func_validate_options bootstrap_validate_options


## -------------------------------------------------- ##
## Source package customisations in 'bootstrap.conf'. ##
## -------------------------------------------------- ##

# Override the default configuration, if necessary.
# Make sure that bootstrap.conf is sourced from the current directory
# if we were invoked as "sh bootstrap".
case $0 in
  */*) test -r "$0.conf" && . "$0.conf" ;;
  *) test -r "$0.conf" && . ./"$0.conf" ;;
esac


## ------------------------------- ##
## Actually perform the bootstrap. ##
## ------------------------------- ##

func_bootstrap ${1+"$@"}

# The End.
exit ${exit_status-$EXIT_SUCCESS}

# Local variables:
# mode: shell-script
# sh-indentation: 2
# eval: (add-hook 'write-file-hooks 'time-stamp)
# time-stamp-pattern: "20/scriptversion=%:y-%02m-%02d.%02H; # UTC"
# time-stamp-time-zone: "UTC"
# End:
